<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><meta http-equiv=x-ua-compatible content="IE=edge, chrome=1"><title>네트워크 모니터링이 궁금할땐 ? Packetbeat ! - 👨‍💻꿈꾸는 태태태의 공간</title><meta name=Description content><meta property="og:title" content="네트워크 모니터링이 궁금할땐 ? Packetbeat !"><meta property="og:description" content="모니터링은 서비스 로직 개발 만큼 한번씩 고민해보고 경험해 봤을 중요한 영역이라 할 수 있다. 그중 웹서버에서 제공해주는 엑세스 로그는 운영하고 있는 웹서비스에 대해 여러가지 측면에서 분석할 수 있는 가장 강력한 아이템 중에 하나라고 생각한다. 이를 통해 사용자들이 어떤 url을 많이 호출하고, 어떤 user-agent형태를 사용하는지 알게 되면 그에 따라 서비스 전략을 변경할수도 있고 악의적으로 공격적인 요청에 대해 웹서버단에서 차단을 할 수 있기 때문이다. 이렇게 inbound 트래픽(외부에서 들어오는 요청)에 대해서는 엑세스 로그를 잘 분석하면 기존의 웹 어플리케이션과는 전혀 무관하게 모니터링이 가능하지만 반대로 outbund 트래픽(외부로 나가는 요청)에 대해서는 어떤식으로 모니터링을 할 수 있을까?
월급통장의 inbound 트래픽보다 outbound 트래픽이 너무 많은 요즘&mldr;이미지 출처 : https://www.app24moa.com/feedDetail/2/2002&#34; 월급통장의 inbound 트래픽보다 outbound 트래픽이 너무 많은 요즘&mldr;
이미지 출처 : https://www.app24moa.com/feedDetail/2/2002  예컨데, 날씨 서비스를 하기 위해 외부에서 서울날씨라는 페이지를 조회했을 경우 기상청 API에서 넘겨받은 데이터를 가공하여 보여준다고 가정해보자. 이때 기상청에서 제공해주는 특정 API중에 어느 하나가 늦게 응답이 온다거나, 특정시간대에 에러응답을 받을경우 과연 이를 어떤식으로 모니터링 할수 있을까? 어플리케이션 코드에 모니터링을 위한 코드를 추가할 것인가? 혹 하나의 서버에서 A모듈은 java로, B모듈은 python으로 개발되었을 경우 각각 모듈마다 모니터링을 위한 코드를 추가하는 식으로 하다보면 비지니스 로직을 방해하거나 오히려 추가한 코드 또한 관리해야 하는 배보다 배꼽이 더 커져버릴 상황도 생길수 있다. 어플리케이션의 비지니스 로직과는 무관하게 서버 자체에서 외부로 나가는 네트워크 트래픽에 대해 모니터링을 할 수 있는 가벼우면서도 심플한 모듈을 찾고 싶었다. 어플리케이션의 개발언어가 무엇이든 상관없이 별도의 에이전트 형식으로 띄워두기만 하면 네트워크 트래픽을 수집 및 분석, 나아가서는 모니터링까지 할수있는&mldr; 그래서 찾다보니 역시나 이러한 고민을 누군가는 하고 있었고 오픈소스까지 되어있는 Elastic Stack 의 Beat중 Packetbeat라는 데이터 수집모듈을 알게 되었다.
 역시 내가 하고있는 고민은 이미 누군가 했던 고민들&mldr; 이러한 고민에 대해 해결하는 방법을 보다 빨리 찾는게 경쟁력이 될텐데&mldr;
 이번 포스팅에서는 Packetbeat 에 대해 간단히 알아보고 이를 활용하여 outbound 트래픽에 대해 모니터링을 해보며 어떤식으로 활용할 수 있는지에 대해 알아보고자 한다.
Packetbeat ? ElasticStack 중에 데이터 수집기 플랫폼인 Beats중 네트워크 트래픽 데이터에 대해 수집을 할 수 있는 데이터 수집기를 제공하고 있다. pcap라이브러리를 이용하여 서버의 네트워크 레벨에서 데이터를 수집 및 분석한 후 외부로(Elasticsearch, Logstash, Kafka 등) 전송해주는 경량 네트워크 패킷 분석기라고 공식 홈페이지에 소개되고 있다. 몇번 사용해보면서 느낀 장점들은 다음과 같다.
 설치 및 실행이 너무 간단하다. 설정값 튜닝을 통해 간단하지만, 그러한 간단함에 비해서 너무 강력한 수집이 가능하다. 앞서 이야기 했던 어플리케이션 코드와는 전혀 무관하게 작동한다.  무엇을 해볼것인가?! (a.k.a. 목표) 필자가 운영하는 Daily-DevBlog 라는 서비스가 있다. (갑분 서비스 홍보) 여러 사람들의 rss를 조회하고 파싱해서 메일을 보내주는 서비스 인데, packetbeat 사용 예시를 들기위해 조금 변형하여 모든 rss를 접근하고 가장 최신글의 제목을 출력하는 아주 간단한 python 스크립트로 outbound 트래픽을 발생시켜 보고자 한다. 그리고 packetbeat 를 이용하여 외부로 호출되는 트래픽을 수집하고 Elasticsearch 로 인덱싱 하여 최종적으로는 어느 rss의 속도가 가장 느린지 실행되는 python코드와는 전혀 관련없이 모니터링 해보고자 한다. python 코드는 다음과 같다.
 참고로 필자는 awesome-devblog의 운영자분께 해당 데이터 사용에 대해 허락을 받은 상태이다.
 import requests, yaml, feedparser blog_info_list_yml_url = 'https://raw.githubusercontent.com/sarojaba/awesome-devblog/master/db.yml' blog_info_list_yml = requests.get(url=blog_info_list_yml_url).text blog_info_yaml_parse_list = yaml.load(blog_info_list_yml) for blog_info in blog_info_yaml_parse_list : if 'rss' not in blog_info.keys() or not blog_info['rss']: continue rss_url = blog_info['rss'] try : parse_feed = feedparser.parse(rss_url) except : continue parse_feed_data = parse_feed.entries[0] print(blog_info['name'], '|', parse_feed_data['title'], '|', parse_feed_data['link']) 위 코드를 실행하면 아래처럼 아주 간단하게 블로그 주인의 이름과 최신글 제목, 링크가 출력이 된다."><meta property="og:type" content="article"><meta property="og:url" content="https://taetaetae.github.io/2019/09/08/network-monitor-by-packetbeat/"><meta property="og:image" content="https://taetaetae.github.io/images/network-monitor-by-packetbeat/packetbeat_rgb.png"><meta property="article:published_time" content="2019-09-08T18:11:34+00:00"><meta property="article:modified_time" content="2019-09-08T18:11:34+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://taetaetae.github.io/images/network-monitor-by-packetbeat/packetbeat_rgb.png"><meta name=twitter:title content="네트워크 모니터링이 궁금할땐 ? Packetbeat !"><meta name=twitter:description content="모니터링은 서비스 로직 개발 만큼 한번씩 고민해보고 경험해 봤을 중요한 영역이라 할 수 있다. 그중 웹서버에서 제공해주는 엑세스 로그는 운영하고 있는 웹서비스에 대해 여러가지 측면에서 분석할 수 있는 가장 강력한 아이템 중에 하나라고 생각한다. 이를 통해 사용자들이 어떤 url을 많이 호출하고, 어떤 user-agent형태를 사용하는지 알게 되면 그에 따라 서비스 전략을 변경할수도 있고 악의적으로 공격적인 요청에 대해 웹서버단에서 차단을 할 수 있기 때문이다. 이렇게 inbound 트래픽(외부에서 들어오는 요청)에 대해서는 엑세스 로그를 잘 분석하면 기존의 웹 어플리케이션과는 전혀 무관하게 모니터링이 가능하지만 반대로 outbund 트래픽(외부로 나가는 요청)에 대해서는 어떤식으로 모니터링을 할 수 있을까?
월급통장의 inbound 트래픽보다 outbound 트래픽이 너무 많은 요즘&mldr;이미지 출처 : https://www.app24moa.com/feedDetail/2/2002&#34; 월급통장의 inbound 트래픽보다 outbound 트래픽이 너무 많은 요즘&mldr;
이미지 출처 : https://www.app24moa.com/feedDetail/2/2002  예컨데, 날씨 서비스를 하기 위해 외부에서 서울날씨라는 페이지를 조회했을 경우 기상청 API에서 넘겨받은 데이터를 가공하여 보여준다고 가정해보자. 이때 기상청에서 제공해주는 특정 API중에 어느 하나가 늦게 응답이 온다거나, 특정시간대에 에러응답을 받을경우 과연 이를 어떤식으로 모니터링 할수 있을까? 어플리케이션 코드에 모니터링을 위한 코드를 추가할 것인가? 혹 하나의 서버에서 A모듈은 java로, B모듈은 python으로 개발되었을 경우 각각 모듈마다 모니터링을 위한 코드를 추가하는 식으로 하다보면 비지니스 로직을 방해하거나 오히려 추가한 코드 또한 관리해야 하는 배보다 배꼽이 더 커져버릴 상황도 생길수 있다. 어플리케이션의 비지니스 로직과는 무관하게 서버 자체에서 외부로 나가는 네트워크 트래픽에 대해 모니터링을 할 수 있는 가벼우면서도 심플한 모듈을 찾고 싶었다. 어플리케이션의 개발언어가 무엇이든 상관없이 별도의 에이전트 형식으로 띄워두기만 하면 네트워크 트래픽을 수집 및 분석, 나아가서는 모니터링까지 할수있는&mldr; 그래서 찾다보니 역시나 이러한 고민을 누군가는 하고 있었고 오픈소스까지 되어있는 Elastic Stack 의 Beat중 Packetbeat라는 데이터 수집모듈을 알게 되었다.
 역시 내가 하고있는 고민은 이미 누군가 했던 고민들&mldr; 이러한 고민에 대해 해결하는 방법을 보다 빨리 찾는게 경쟁력이 될텐데&mldr;
 이번 포스팅에서는 Packetbeat 에 대해 간단히 알아보고 이를 활용하여 outbound 트래픽에 대해 모니터링을 해보며 어떤식으로 활용할 수 있는지에 대해 알아보고자 한다.
Packetbeat ? ElasticStack 중에 데이터 수집기 플랫폼인 Beats중 네트워크 트래픽 데이터에 대해 수집을 할 수 있는 데이터 수집기를 제공하고 있다. pcap라이브러리를 이용하여 서버의 네트워크 레벨에서 데이터를 수집 및 분석한 후 외부로(Elasticsearch, Logstash, Kafka 등) 전송해주는 경량 네트워크 패킷 분석기라고 공식 홈페이지에 소개되고 있다. 몇번 사용해보면서 느낀 장점들은 다음과 같다.
 설치 및 실행이 너무 간단하다. 설정값 튜닝을 통해 간단하지만, 그러한 간단함에 비해서 너무 강력한 수집이 가능하다. 앞서 이야기 했던 어플리케이션 코드와는 전혀 무관하게 작동한다.  무엇을 해볼것인가?! (a.k.a. 목표) 필자가 운영하는 Daily-DevBlog 라는 서비스가 있다. (갑분 서비스 홍보) 여러 사람들의 rss를 조회하고 파싱해서 메일을 보내주는 서비스 인데, packetbeat 사용 예시를 들기위해 조금 변형하여 모든 rss를 접근하고 가장 최신글의 제목을 출력하는 아주 간단한 python 스크립트로 outbound 트래픽을 발생시켜 보고자 한다. 그리고 packetbeat 를 이용하여 외부로 호출되는 트래픽을 수집하고 Elasticsearch 로 인덱싱 하여 최종적으로는 어느 rss의 속도가 가장 느린지 실행되는 python코드와는 전혀 관련없이 모니터링 해보고자 한다. python 코드는 다음과 같다.
 참고로 필자는 awesome-devblog의 운영자분께 해당 데이터 사용에 대해 허락을 받은 상태이다.
 import requests, yaml, feedparser blog_info_list_yml_url = 'https://raw.githubusercontent.com/sarojaba/awesome-devblog/master/db.yml' blog_info_list_yml = requests.get(url=blog_info_list_yml_url).text blog_info_yaml_parse_list = yaml.load(blog_info_list_yml) for blog_info in blog_info_yaml_parse_list : if 'rss' not in blog_info.keys() or not blog_info['rss']: continue rss_url = blog_info['rss'] try : parse_feed = feedparser.parse(rss_url) except : continue parse_feed_data = parse_feed.entries[0] print(blog_info['name'], '|', parse_feed_data['title'], '|', parse_feed_data['link']) 위 코드를 실행하면 아래처럼 아주 간단하게 블로그 주인의 이름과 최신글 제목, 링크가 출력이 된다."><meta name=application-name content="👨‍💻꿈꾸는 태태태의 공간"><meta name=apple-mobile-web-app-title content="👨‍💻꿈꾸는 태태태의 공간"><meta name=naver-site-verification content="2d1cdbb963ba178aa7cbf58500afc668cae1e645"><meta name=google-site-verification content="vvFCdv0-GuQhEWG8vtNJfA7YSY2HYQ1hpHh9P-a6Pv8"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://taetaetae.github.io/2019/09/08/network-monitor-by-packetbeat/><link rel=prev href=https://taetaetae.github.io/2019/08/04/apache-load-balancing/><link rel=next href=https://taetaetae.github.io/2019/09/29/woowabros-spring-batch/><link rel=stylesheet href=/lib/normalize/normalize.min.css><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=/lib/fontawesome-free/all.min.css><link rel=stylesheet href=/lib/animate/animate.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"네트워크 모니터링이 궁금할땐 ? Packetbeat !","inLanguage":"en","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/taetaetae.github.io\/2019\/09\/08\/network-monitor-by-packetbeat\/"},"genre":"posts","keywords":"packetbeat, network, archives-2019","wordcount":1107,"url":"https:\/\/taetaetae.github.io\/2019\/09\/08\/network-monitor-by-packetbeat\/","datePublished":"2019-09-08T18:11:34+00:00","dateModified":"2019-09-08T18:11:34+00:00","publisher":{"@type":"Organization","name":"태태태"},"author":{"@type":"Person","name":"태태태"},"description":""}</script></head><body header-desktop=auto header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem('theme')?localStorage.getItem('theme')==='dark':('auto'==='auto'?window.matchMedia('(prefers-color-scheme: dark)').matches:'auto'==='dark'))&&document.body.setAttribute('theme','dark');</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title="👨‍💻꿈꾸는 태태태의 공간">👨‍💻꿈꾸는 태태태의 공간</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/>Posts </a><a class=menu-item href=/tags/>Tags </a><a class=menu-item href=/categories/>Categories </a><span class="menu-item delimiter"></span><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme"><i class="fas fa-adjust fa-fw"></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title="👨‍💻꿈꾸는 태태태의 공간">👨‍💻꿈꾸는 태태태의 공간</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><a class=menu-item href=/posts/>Posts</a><a class=menu-item href=/tags/>Tags</a><a class=menu-item href=/categories/>Categories</a><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme">
<i class="fas fa-adjust fa-fw"></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>Contents</h2><div class=toc-content id=toc-content-auto></div><script async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script><ins class=adsbygoogle style=display:inline-block;width:260px;height:600px data-ad-client=ca-pub-5788330009690816 data-ad-slot=2248955907></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({});</script></div><article class="page single"><h1 class="single-title animated flipInX">네트워크 모니터링이 궁금할땐 ? Packetbeat !</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=https://taetaetae.github.io/resume title=Author target=_blank rel="noopener noreffer author" class=author><i class="fas fa-user-circle fa-fw"></i>태태태</a></span>&nbsp;<span class=post-category>included in <a href=/categories/tech/><i class="far fa-folder fa-fw"></i>Tech</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime=2019-09-08>2019-09-08</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;1107 words&nbsp;
<i class="far fa-clock fa-fw"></i>&nbsp;6 minutes&nbsp;</div></div><div class=featured-image><img class=lazyload src=/svg/loading.min.svg data-src=/images/network-monitor-by-packetbeat/packetbeat_rgb.png data-srcset="/images/network-monitor-by-packetbeat/packetbeat_rgb.png, /images/network-monitor-by-packetbeat/packetbeat_rgb.png 1.5x, /images/network-monitor-by-packetbeat/packetbeat_rgb.png 2x" data-sizes=auto alt=/images/network-monitor-by-packetbeat/packetbeat_rgb.png title=/images/network-monitor-by-packetbeat/packetbeat_rgb.png></div><div class="details toc" id=toc-static kept><div class="details-summary toc-title"><span>Contents</span>
<span><i class="details-icon fas fa-angle-right"></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#packetbeat->Packetbeat ?</a></li><li><a href=#무엇을-해볼것인가-aka-목표>무엇을 해볼것인가?! (a.k.a. 목표)</a></li><li><a href=#백문이-불여일견-백견이-불여일타>백문이 불여일견? 백견이 불여일타!</a></li><li><a href=#무엇을-모니터링-할-수-있을까>무엇을 모니터링 할 수 있을까?</a></li><li><a href=#마치며>마치며</a></li></ul></nav></div></div><div class=content id=content><script src=https://ads-partners.coupang.com/g.js></script><script>new PartnersCoupang.G({"id":195296,"trackingCode":"AF5596407","subId":null,"template":"carousel","width":"680","height":"140"});</script><p>모니터링은 서비스 로직 개발 만큼 한번씩 고민해보고 경험해 봤을 중요한 영역이라 할 수 있다. 그중 웹서버에서 제공해주는 엑세스 로그는 운영하고 있는 웹서비스에 대해 여러가지 측면에서 분석할 수 있는 가장 강력한 아이템 중에 하나라고 생각한다. 이를 통해 사용자들이 어떤 url을 많이 호출하고, 어떤 user-agent형태를 사용하는지 알게 되면 그에 따라 서비스 전략을 변경할수도 있고 악의적으로 공격적인 요청에 대해 웹서버단에서 차단을 할 수 있기 때문이다.
이렇게 <code>inbound 트래픽(외부에서 들어오는 요청)</code>에 대해서는 엑세스 로그를 잘 분석하면 기존의 웹 어플리케이션과는 전혀 무관하게 모니터링이 가능하지만 반대로 <code>outbund 트래픽(외부로 나가는 요청)</code>에 대해서는 어떤식으로 모니터링을 할 수 있을까?</p><figure><a class=lightgallery href=/images/network-monitor-by-packetbeat/passbook.jpg title=/images/network-monitor-by-packetbeat/passbook.jpg data-thumbnail=/images/network-monitor-by-packetbeat/passbook.jpg data-sub-html="<h2>월급통장의 inbound 트래픽보다 outbound 트래픽이 너무 많은 요즘&mldr;이미지 출처 : https://www.app24moa.com/feedDetail/2/2002</h2>"><img class=lazyload src=/svg/loading.min.svg data-src=/images/network-monitor-by-packetbeat/passbook.jpg data-srcset="/images/network-monitor-by-packetbeat/passbook.jpg, /images/network-monitor-by-packetbeat/passbook.jpg 1.5x, /images/network-monitor-by-packetbeat/passbook.jpg 2x" data-sizes=auto alt=/images/network-monitor-by-packetbeat/passbook.jpg width=80%></a><figcaption class=image-caption>월급통장의 inbound 트래픽보다 outbound 트래픽이 너무 많은 요즘&mldr;<br>이미지 출처 : <a href=https://www.app24moa.com/feedDetail/2/2002>https://www.app24moa.com/feedDetail/2/2002</a></figcaption></figure><p>예컨데, 날씨 서비스를 하기 위해 외부에서 <code>서울날씨</code>라는 페이지를 조회했을 경우 기상청 API에서 넘겨받은 데이터를 가공하여 보여준다고 가정해보자. 이때 기상청에서 제공해주는 특정 API중에 어느 하나가 늦게 응답이 온다거나, 특정시간대에 에러응답을 받을경우 과연 이를 어떤식으로 모니터링 할수 있을까? 어플리케이션 코드에 <code>모니터링을 위한 코드</code>를 추가할 것인가? 혹 하나의 서버에서 A모듈은 java로, B모듈은 python으로 개발되었을 경우 각각 모듈마다 모니터링을 위한 코드를 추가하는 식으로 하다보면 비지니스 로직을 방해하거나 오히려 추가한 코드 또한 관리해야 하는 배보다 배꼽이 더 커져버릴 상황도 생길수 있다.
어플리케이션의 비지니스 로직과는 무관하게 서버 자체에서 외부로 나가는 네트워크 트래픽에 대해 모니터링을 할 수 있는 <code>가벼우면서도 심플한 모듈</code>을 찾고 싶었다. 어플리케이션의 개발언어가 무엇이든 상관없이 별도의 에이전트 형식으로 띄워두기만 하면 네트워크 트래픽을 수집 및 분석, 나아가서는 모니터링까지 할수있는&mldr; 그래서 찾다보니 역시나 이러한 고민을 누군가는 하고 있었고 오픈소스까지 되어있는 Elastic Stack 의 Beat중 <code>Packetbeat</code>라는 데이터 수집모듈을 알게 되었다.</p><blockquote><p>역시 내가 하고있는 고민은 이미 누군가 했던 고민들&mldr; 이러한 고민에 대해 해결하는 방법을 보다 빨리 찾는게 경쟁력이 될텐데&mldr;</p></blockquote><p>이번 포스팅에서는 Packetbeat 에 대해 간단히 알아보고 이를 활용하여 outbound 트래픽에 대해 모니터링을 해보며 어떤식으로 활용할 수 있는지에 대해 알아보고자 한다.</p><h2 id=packetbeat->Packetbeat ?</h2><p>ElasticStack 중에 데이터 수집기 플랫폼인 <code>Beats</code>중 네트워크 트래픽 데이터에 대해 수집을 할 수 있는 데이터 수집기를 제공하고 있다. <a href=https://ko.wikipedia.org/wiki/Pcap target=_blank rel="noopener noreffer">pcap</a>라이브러리를 이용하여 서버의 네트워크 레벨에서 데이터를 수집 및 분석한 후 외부로(Elasticsearch, Logstash, Kafka 등) 전송해주는 <code>경량 네트워크 패킷 분석기</code>라고 <a href=https://www.elastic.co/kr/products/beats/packetbeat target=_blank rel="noopener noreffer">공식 홈페이지</a>에 소개되고 있다.
몇번 사용해보면서 느낀 장점들은 다음과 같다.</p><ul><li>설치 및 실행이 너무 간단하다.</li><li>설정값 튜닝을 통해 간단하지만, 그러한 간단함에 비해서 너무 강력한 수집이 가능하다.</li><li>앞서 이야기 했던 어플리케이션 코드와는 전혀 무관하게 작동한다.</li></ul><h2 id=무엇을-해볼것인가-aka-목표>무엇을 해볼것인가?! (a.k.a. 목표)</h2><p>필자가 운영하는 <a href=http://daily-devblog.com target=_blank rel="noopener noreffer">Daily-DevBlog</a> 라는 서비스가 있다. <del>(갑분 서비스 홍보)</del> 여러 사람들의 rss를 조회하고 파싱해서 메일을 보내주는 서비스 인데, packetbeat 사용 예시를 들기위해 조금 변형하여 모든 rss를 접근하고 가장 최신글의 제목을 출력하는 아주 간단한 python 스크립트로 outbound 트래픽을 발생시켜 보고자 한다.
그리고 packetbeat 를 이용하여 외부로 호출되는 트래픽을 수집하고 Elasticsearch 로 인덱싱 하여 최종적으로는 어느 rss의 속도가 가장 느린지 실행되는 python코드와는 전혀 관련없이 모니터링 해보고자 한다.
python 코드는 다음과 같다.</p><blockquote><p>참고로 필자는 <code>awesome-devblog</code>의 운영자분께 해당 데이터 사용에 대해 허락을 받은 상태이다.</p></blockquote><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=kn>import</span> <span class=nn>requests</span><span class=o>,</span> <span class=nn>yaml</span><span class=o>,</span> <span class=nn>feedparser</span>

<span class=n>blog_info_list_yml_url</span> <span class=o>=</span> <span class=s1>&#39;https://raw.githubusercontent.com/sarojaba/awesome-devblog/master/db.yml&#39;</span>
<span class=n>blog_info_list_yml</span> <span class=o>=</span> <span class=n>requests</span><span class=o>.</span><span class=n>get</span><span class=p>(</span><span class=n>url</span><span class=o>=</span><span class=n>blog_info_list_yml_url</span><span class=p>)</span><span class=o>.</span><span class=n>text</span>
<span class=n>blog_info_yaml_parse_list</span> <span class=o>=</span> <span class=n>yaml</span><span class=o>.</span><span class=n>load</span><span class=p>(</span><span class=n>blog_info_list_yml</span><span class=p>)</span>

<span class=k>for</span> <span class=n>blog_info</span> <span class=ow>in</span> <span class=n>blog_info_yaml_parse_list</span> <span class=p>:</span>
    <span class=k>if</span> <span class=s1>&#39;rss&#39;</span> <span class=ow>not</span> <span class=ow>in</span> <span class=n>blog_info</span><span class=o>.</span><span class=n>keys</span><span class=p>()</span> <span class=ow>or</span> <span class=ow>not</span> <span class=n>blog_info</span><span class=p>[</span><span class=s1>&#39;rss&#39;</span><span class=p>]:</span>
        <span class=k>continue</span>
    <span class=n>rss_url</span> <span class=o>=</span> <span class=n>blog_info</span><span class=p>[</span><span class=s1>&#39;rss&#39;</span><span class=p>]</span>
    <span class=k>try</span> <span class=p>:</span>
        <span class=n>parse_feed</span> <span class=o>=</span> <span class=n>feedparser</span><span class=o>.</span><span class=n>parse</span><span class=p>(</span><span class=n>rss_url</span><span class=p>)</span>
    <span class=k>except</span> <span class=p>:</span>
        <span class=k>continue</span>

    <span class=n>parse_feed_data</span> <span class=o>=</span>  <span class=n>parse_feed</span><span class=o>.</span><span class=n>entries</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
    <span class=k>print</span><span class=p>(</span><span class=n>blog_info</span><span class=p>[</span><span class=s1>&#39;name&#39;</span><span class=p>],</span> <span class=s1>&#39;|&#39;</span><span class=p>,</span> <span class=n>parse_feed_data</span><span class=p>[</span><span class=s1>&#39;title&#39;</span><span class=p>],</span> <span class=s1>&#39;|&#39;</span><span class=p>,</span> <span class=n>parse_feed_data</span><span class=p>[</span><span class=s1>&#39;link&#39;</span><span class=p>])</span>

</code></pre></div><p>위 코드를 실행하면 아래처럼 아주 간단하게 <code>블로그 주인의 이름</code>과 <code>최신글 제목</code>, <code>링크</code>가 출력이 된다.</p><figure><a class=lightgallery href=/images/network-monitor-by-packetbeat/rss_python_script.jpg title=/images/network-monitor-by-packetbeat/rss_python_script.jpg data-thumbnail=/images/network-monitor-by-packetbeat/rss_python_script.jpg data-sub-html="<h2>그러고 보니 너무 오랜만에 글쓰네&mldr; (숙연)</h2>"><img class=lazyload src=/svg/loading.min.svg data-src=/images/network-monitor-by-packetbeat/rss_python_script.jpg data-srcset="/images/network-monitor-by-packetbeat/rss_python_script.jpg, /images/network-monitor-by-packetbeat/rss_python_script.jpg 1.5x, /images/network-monitor-by-packetbeat/rss_python_script.jpg 2x" data-sizes=auto alt=/images/network-monitor-by-packetbeat/rss_python_script.jpg width=80%></a><figcaption class=image-caption>그러고 보니 너무 오랜만에 글쓰네&mldr; (숙연)</figcaption></figure><h2 id=백문이-불여일견-백견이-불여일타>백문이 불여일견? 백견이 불여일타!</h2><p>언제 어디서부터 유래된 이야기 인지는 모르지만 &ldquo;백번 듣는것이 한번 보는것보다 못하고, 백번 보는것이 한번 타자 치는것보다 못하다&rdquo; 라는 <code>개발버전</code> 속담이 있다. 자, 위에서 정의한 목표를 이루기 위해 실제로 각종 모듈을 설치해 보도록 하자! ( 필자가 테스트 했던 서버의 환경은 CentOS 7.4 64Bit 이니 참고 )</p><ul><li>Elasticsearch
이왕 설치하는거 가장 최신버전인 7.3.1을 설치해보자! (버전업이 빨라도 너~무 빨라&mldr;)</li></ul><div class=highlight><pre class=chroma><code class=language-markdown data-lang=markdown>// 다운을 받고
wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-7.3.1-linux-x86_64.tar.gz
// 압축을 푼다음
tar -zxvf elasticsearch-7.3.1-linux-x86_64.tar.gz
cd elasticsearch-7.3.1/conf
// 각종 설정후
vi elasticsearch.yml
	node.name: node-1
	network.host: 0.0.0.0
	discovery.seed_hosts: [&#34;localhost&#34;]
	cluster.initial_master_nodes: [&#34;node-1&#34;]
// 실행
bin/elasticsearch
</code></pre></div><p><code>http://server-url:9200</code>접근시 아래처럼 나오면 설치 성공</p><div class=highlight><pre class=chroma><code class=language-json data-lang=json><span class=p>{</span>
	<span class=nt>&#34;name&#34;</span><span class=p>:</span> <span class=s2>&#34;node-1&#34;</span><span class=p>,</span>
	<span class=nt>&#34;cluster_name&#34;</span><span class=p>:</span> <span class=s2>&#34;elasticsearch&#34;</span><span class=p>,</span>
	<span class=nt>&#34;cluster_uuid&#34;</span><span class=p>:</span> <span class=s2>&#34;---&#34;</span><span class=p>,</span>
	<span class=nt>&#34;version&#34;</span><span class=p>:</span> <span class=p>{</span>
		<span class=nt>&#34;number&#34;</span><span class=p>:</span> <span class=s2>&#34;7.3.1&#34;</span><span class=p>,</span>
		<span class=err>~~~</span>
	<span class=p>},</span>
	<span class=nt>&#34;tagline&#34;</span><span class=p>:</span> <span class=s2>&#34;You Know, for Search&#34;</span>
<span class=p>}</span>
</code></pre></div><ul><li>Kibana</li></ul><div class=highlight><pre class=chroma><code class=language-markdown data-lang=markdown>// 다운을 받고 
wget https://artifacts.elastic.co/downloads/kibana/kibana-7.3.1-linux-x86_64.tar.gz
// 압축을 푼 다음
tar -zxvf kibana-7.3.1-linux-x86_64.tar.gz
cd kibana-7.3.1-linux-x86_64/config
// 각종 설정후
vi kibana.yml
	server.host: &#34;~.~.~.~&#34;
	elasticsearch.hosts: [&#34;http://~.~.~.~:9200&#34;]
// 실행
bin/kibana
</code></pre></div><p><code>http://server-url:5601</code>접근시 키바나 화면이 나오면 설치 성공</p><ul><li>Packetbeat</li></ul><div class=highlight><pre class=chroma><code class=language-markdown data-lang=markdown>// 다운을 받고
wget https://artifacts.elastic.co/downloads/beats/packetbeat/packetbeat-7.3.1-linux-x86_64.tar.gz
// 압축을 푼 다음
tar -zxvf packetbeat-7.3.1-linux-x86_64.tar.gz
// 각종 설정후 실행 (root 권한으로 실행해야 함)
sudo chown root:root packetbeat.yml
sudo vi packetbeat.yml
	output.elasticsearch:
	  # Array of hosts to connect to.
	  hosts: [&#34;~.~.~.~:9200&#34;]
sudo ./packetbeat -e -c packetbeat.yml
</code></pre></div><p>이렇게 하고나서 키바나에 가보면 아래처럼 Packetbeat 인덱스 패턴을 만들수 있고 수집이 되고있는것 까지 확인 가능하다.</p><figure><a class=lightgallery href=/images/network-monitor-by-packetbeat/packetbeat_es_kibana.jpg title=/images/network-monitor-by-packetbeat/packetbeat_es_kibana.jpg data-thumbnail=/images/network-monitor-by-packetbeat/packetbeat_es_kibana.jpg data-sub-html="<h2>데이터가 엄~청 다양하고 많이 수집된다.</h2>"><img class=lazyload src=/svg/loading.min.svg data-src=/images/network-monitor-by-packetbeat/packetbeat_es_kibana.jpg data-srcset="/images/network-monitor-by-packetbeat/packetbeat_es_kibana.jpg, /images/network-monitor-by-packetbeat/packetbeat_es_kibana.jpg 1.5x, /images/network-monitor-by-packetbeat/packetbeat_es_kibana.jpg 2x" data-sizes=auto alt=/images/network-monitor-by-packetbeat/packetbeat_es_kibana.jpg width=80%></a><figcaption class=image-caption>데이터가 엄~청 다양하고 많이 수집된다.</figcaption></figure><h2 id=무엇을-모니터링-할-수-있을까>무엇을 모니터링 할 수 있을까?</h2><p>이제 각종 구성은 했으니 처음에 목표한 <code>어느 rss가 가장 느린가</code>를 체크해 볼 시간이다. python 스크립트를 돌리면 packetbeat 에 의해 네트워크 트래픽이 수집~분석~Elasticsearch에 인덱싱이 되고 이를 키바나의 비쥬얼라이즈를 통해 적절하게 만들어보면 아래처럼 너무나도 간단하게 어느 rss의 응답속도가 가장 느린지 확인할 수 있다. <code>event.duration</code> 필드는 기본적으로 nano second 이다보니 아래 그림에서는 2.6초가 가장 오래걸린 rss url 이라 볼 수 있다.</p><figure><a class=lightgallery href=/images/network-monitor-by-packetbeat/visualize.jpg title=/images/network-monitor-by-packetbeat/visualize.jpg data-thumbnail=/images/network-monitor-by-packetbeat/visualize.jpg data-sub-html="<h2>보라, 키바나의 강력한 비쥬얼라이즈 기능을! (아 눈부셔)</h2>"><img class=lazyload src=/svg/loading.min.svg data-src=/images/network-monitor-by-packetbeat/visualize.jpg data-srcset="/images/network-monitor-by-packetbeat/visualize.jpg, /images/network-monitor-by-packetbeat/visualize.jpg 1.5x, /images/network-monitor-by-packetbeat/visualize.jpg 2x" data-sizes=auto alt=/images/network-monitor-by-packetbeat/visualize.jpg width=80%></a><figcaption class=image-caption>보라, 키바나의 강력한 비쥬얼라이즈 기능을! (아 눈부셔)</figcaption></figure><p>한가지 더, packetbeat를 설치하고 기본 설정으로 실행하게 되면 불필요한(outbound 트래픽만을 수집하겠다던 목표와는 무관한) 데이터들도 수집되다보니 아무래도 cpu에 불필요한 부하가 발생할수 있고(아무래도 모든 네트워크 트래픽을 트래킹 하고 분석해야하니&mldr;) Elasticsearch 에도 불필요한 데이터가 인덱싱 되곤 한다. 그래서 지금의 Packetbeat 뿐만 아니라 오픈소스를 사용할 경우엔 설정값들을 정확히 알고 목적에 맞는 커스터마이징은 필수인듯 하다. 필자는 http의 outbound 트래픽만을 보고 싶었기 때문에 아래처럼 packetbeat 설정을 하고 다시 실행 해보면 Elasticsearch 에 수집되는 도큐먼트 사이즈가 확연하게 차이나는 것을 확인할 수 있다.</p><div class=highlight><pre class=chroma><code class=language-markdown data-lang=markdown>packetbeat.protocols: # 아래 2개 이외에는 전부 주석처리
<span class=k>-</span> type: http
  ports: [80] # 80 port 의 http를 수집하겠다.
<span class=k>-</span> type: tls
  ports:
     <span class=k>-</span> 443   # 443 의 tls를 수집하겠다.

processors:
  <span class=k>-</span> drop_event.when.equals.network.direction : &#34;inbound&#34; # inbound는 수집하지 않겠다.
</code></pre></div><figure><a class=lightgallery href=/images/network-monitor-by-packetbeat/packetbeat_config.jpg title=/images/network-monitor-by-packetbeat/packetbeat_config.jpg data-thumbnail=/images/network-monitor-by-packetbeat/packetbeat_config.jpg data-sub-html="<h2>좌측이 기본, 우측이 불필요 데이터 제외하고 나서의 수집 상태</h2>"><img class=lazyload src=/svg/loading.min.svg data-src=/images/network-monitor-by-packetbeat/packetbeat_config.jpg data-srcset="/images/network-monitor-by-packetbeat/packetbeat_config.jpg, /images/network-monitor-by-packetbeat/packetbeat_config.jpg 1.5x, /images/network-monitor-by-packetbeat/packetbeat_config.jpg 2x" data-sizes=auto alt=/images/network-monitor-by-packetbeat/packetbeat_config.jpg width=50%></a><figcaption class=image-caption>좌측이 기본, 우측이 불필요 데이터 제외하고 나서의 수집 상태</figcaption></figure><p>사실 위 설정값은 <a href=https://www.facebook.com/groups/elasticsearch.kr/permalink/2384124035006756/ target=_blank rel="noopener noreffer">페이스북 한국 Elasticsearch 유저그룹</a>에 문의해서 알게된 내용이다. 역시 커뮤니티 파워, 집단지성의 힘을 다시한번 느낄 수 있었다. (모르면 물어보자! + 문제에 대해 좀더 잘 검색하도록 노력하자!)</p><h2 id=마치며>마치며</h2><p>Packetbeat 을 사용하면서 가장 좋았던 점은 기존 로직과는 전혀 무관하게 작동하는 점이 가장 좋았다. 이러한 점은 어느 상황에서도 서비스 코드 디펜던시가 없어 자유롭게 활용이 가능하다는 뜻으로 해석을 해보곤 한다.</p><figure><a class=lightgallery href=/images/network-monitor-by-packetbeat/angry.jpg title=/images/network-monitor-by-packetbeat/angry.jpg data-thumbnail=/images/network-monitor-by-packetbeat/angry.jpg data-sub-html="<h2>마냥 좋다고 운영환경에 무작정 도입하면 이런 따사로운 눈빛을 받을 수 있으니 참고이미지 출처 : https://namu.wiki/w/%EB%82%98%EB%8A%94%20%EC%9E%90%EC%97%B0%EC%9D%B8%EC%9D%B4%EB%8B%A4</h2>"><img class=lazyload src=/svg/loading.min.svg data-src=/images/network-monitor-by-packetbeat/angry.jpg data-srcset="/images/network-monitor-by-packetbeat/angry.jpg, /images/network-monitor-by-packetbeat/angry.jpg 1.5x, /images/network-monitor-by-packetbeat/angry.jpg 2x" data-sizes=auto alt=/images/network-monitor-by-packetbeat/angry.jpg width=50%></a><figcaption class=image-caption>마냥 좋다고 운영환경에 무작정 도입하면 이런 따사로운 눈빛을 받을 수 있으니 참고<br>이미지 출처 : <a href=https://namu.wiki/w/%EB%82%98%EB%8A%94%20%EC%9E%90%EC%97%B0%EC%9D%B8%EC%9D%B4%EB%8B%A4>https://namu.wiki/w/%EB%82%98%EB%8A%94%20%EC%9E%90%EC%97%B0%EC%9D%B8%EC%9D%B4%EB%8B%A4</a></figcaption></figure><p>필자는 최근 운영환경에도 packetbeat를 적용해서 outbound 트래픽을 모니터링 하고 문제가 있는 엔드포인트에 대해 자동으로 점검을 하는 시스템을 만들려고 하고 있는데, 네트워크 패킷을 전부 까보며(?) 아무래도 cpu 성능에 지장을 줄수밖에 없는 오픈소스 모듈이다보니 다양한 테스트를 통해 서비스 운영에 영향이 없도록 설정값들을 튜닝해 가며 적용해봐야 할 것 같다. (무작정 좋다고 적용하다 오히려 큰 화를 부를 수 있다&mldr;)</p><p>내가 맛있어 하는 음식이 남들도 맛있으리란 법 없듯, 소개팅에 나가기전 준비한 멘트가 전부 먹히리라는 법 없듯&mldr;
모든 상황에는 튜닝은 필수다. 그 튜닝을 얼마나 잘, 그리고 센스있게 하냐가 포인트!</p><script src=https://ads-partners.coupang.com/g.js></script><script>new PartnersCoupang.G({"id":195296,"trackingCode":"AF5596407","subId":null,"template":"carousel","width":"680","height":"140"});</script></div><center><style>.bmc-button img{width:27px!important;margin-bottom:1px!important;box-shadow:none!important;border:none!important;vertical-align:middle!important}.bmc-button{line-height:29px!important;height:30px!important;text-decoration:none!important;display:inline-flex!important;color:#000!important;background-color:#fd0!important;border-radius:3px!important;border:1px solid transparent!important;padding:1px 9px!important;font-size:22px!important;letter-spacing:.6px!important;box-shadow:0 1px 2px rgba(190,190,190,.5)!important;-webkit-box-shadow:0 1px 2px 2px rgba(190,190,190,.5)!important;margin:0 auto!important;font-family:cookie,cursive!important;-webkit-box-sizing:border-box!important;box-sizing:border-box!important;-o-transition:.3s all linear!important;-webkit-transition:.3s all linear!important;-moz-transition:.3s all linear!important;-ms-transition:.3s all linear!important;transition:.3s all linear!important}.bmc-button:hover,.bmc-button:active,.bmc-button:focus{-webkit-box-shadow:0 1px 2px 2px rgba(190,190,190,.5)!important;text-decoration:none!important;box-shadow:0 1px 2px 2px rgba(190,190,190,.5)!important;opacity:.85!important;color:#000!important}</style><link href="https://fonts.googleapis.com/css?family=Cookie" rel=stylesheet><center><br><a class=bmc-button target=_blank href=https://www.buymeacoffee.com/taetaetae><img src=https://www.buymeacoffee.com/assets/img/BMC-btn-logo.svg alt="Buy me a coffee"><span style=margin-left:5px>Buy me a coffee</span></a>
<a href=https://bit.ly/ddbSupport target=_blank><img src=https://i.imgur.com/peaYpjh.png style=height:28px></a></center><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>Updated on 2019-09-08</span></div><div class=post-info-license></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span><a href=javascript:void(0); title="Share on Twitter" data-sharer=twitter data-url=https://taetaetae.github.io/2019/09/08/network-monitor-by-packetbeat/ data-title="네트워크 모니터링이 궁금할땐 ? Packetbeat !" data-hashtags=packetbeat,network,archives-2019><i class="fab fa-twitter fa-fw"></i></a><a href=javascript:void(0); title="Share on Facebook" data-sharer=facebook data-url=https://taetaetae.github.io/2019/09/08/network-monitor-by-packetbeat/ data-hashtag=packetbeat><i class="fab fa-facebook-square fa-fw"></i></a><a href=javascript:void(0); title="Share on Linkedin" data-sharer=linkedin data-url=https://taetaetae.github.io/2019/09/08/network-monitor-by-packetbeat/><i class="fab fa-linkedin fa-fw"></i></a><a href=javascript:void(0); title="Share on Blogger" data-sharer=blogger data-url=https://taetaetae.github.io/2019/09/08/network-monitor-by-packetbeat/ data-title="네트워크 모니터링이 궁금할땐 ? Packetbeat !" data-description><i class="fab fa-blogger fa-fw"></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fas fa-tags fa-fw"></i>&nbsp;<a href=/tags/packetbeat/>packetbeat</a>,&nbsp;<a href=/tags/network/>network</a>,&nbsp;<a href=/tags/archives-2019/>archives-2019</a></section><section><span><a href=javascript:void(0); onclick=window.history.back();>Back</a></span>&nbsp;|&nbsp;<span><a href=/>Home</a></span></section></div><div class=post-nav><a href=/2019/08/04/apache-load-balancing/ class=prev rel=prev title="아파치 로드밸런싱으로 여러 WAS 운영하기"><i class="fas fa-angle-left fa-fw"></i>아파치 로드밸런싱으로 여러 WAS 운영하기</a>
<a href=/2019/09/29/woowabros-spring-batch/ class=next rel=next title="우아한 스프링 배치 테크세미나 정리 및 후기 (by 우아한 형제들)">우아한 스프링 배치 테크세미나 정리 및 후기 (by 우아한 형제들)<i class="fas fa-angle-right fa-fw"></i></a></div></div><div id=comments><div id=utterances></div><noscript>Please enable JavaScript to view the comments powered by <a href=https://utteranc.es/>Utterances</a>.</noscript></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line>Powered by <a href=https://gohugo.io/ target=_blank rel="noopener noreffer" title="Hugo 0.74.3">Hugo</a> | Theme - <a href=https://github.com/dillonzq/LoveIt target=_blank rel="noopener noreffer" title="LoveIt 0.2.10"><i class="far fa-kiss-wink-heart fa-fw"></i>LoveIt</a></div><div class=footer-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2016 - 2021</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=https://taetaetae.github.io/resume target=_blank>태태태</a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title="Back to Top"><i class="fas fa-arrow-up fa-fw"></i></a><a href=# id=view-comments class=fixed-button title="View Comments"><i class="fas fa-comment fa-fw"></i></a></div><link rel=stylesheet href=/lib/lightgallery/lightgallery.min.css><script type=text/javascript src=/lib/smooth-scroll/smooth-scroll.min.js></script><script type=text/javascript src=/lib/lazysizes/lazysizes.min.js></script><script type=text/javascript src=/lib/lightgallery/lightgallery.min.js></script><script type=text/javascript src=/lib/lightgallery/lg-thumbnail.min.js></script><script type=text/javascript src=/lib/lightgallery/lg-zoom.min.js></script><script type=text/javascript src=/lib/clipboard/clipboard.min.js></script><script type=text/javascript src=/lib/sharer/sharer.min.js></script><script type=text/javascript>window.config={"code":{"copyTitle":"Copy to clipboard","maxShownLines":500},"comment":{"utterances":{"darkTheme":"github-dark","issueTerm":"pathname","label":"Comment","lightTheme":"github-light","repo":"taetaetae/blog-comment"}},"lightGallery":{"actualSize":false,"exThumbImage":"data-thumbnail","hideBarsDelay":2000,"selector":".lightgallery","speed":400,"thumbContHeight":80,"thumbWidth":80,"thumbnail":true}};</script><script type=text/javascript src=/js/theme.min.js></script><script type=text/javascript>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}gtag('js',new Date());gtag('config','UA-86432198-1',{'anonymize_ip':true});</script><script type=text/javascript src="https://www.googletagmanager.com/gtag/js?id=UA-86432198-1" async></script></body></html>