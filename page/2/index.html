<!doctype html><html lang=en><head><meta name=generator content="Hugo 0.74.3"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><meta http-equiv=x-ua-compatible content="IE=edge, chrome=1"><title>👨‍💻꿈꾸는 태태태의 공간</title><meta name=Description content><meta property="og:title" content="👨‍💻꿈꾸는 태태태의 공간"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="https://taetaetae.github.io/"><meta property="og:updated_time" content="2021-03-28T11:41:33+09:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="👨‍💻꿈꾸는 태태태의 공간"><meta name=twitter:description content><meta name=application-name content="👨‍💻꿈꾸는 태태태의 공간"><meta name=apple-mobile-web-app-title content="👨‍💻꿈꾸는 태태태의 공간"><meta name=naver-site-verification content="2d1cdbb963ba178aa7cbf58500afc668cae1e645"><meta name=google-site-verification content="vvFCdv0-GuQhEWG8vtNJfA7YSY2HYQ1hpHh9P-a6Pv8"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://taetaetae.github.io/><link rel=alternate href=/index.xml type=application/rss+xml title="👨‍💻꿈꾸는 태태태의 공간"><link rel=feed href=/index.xml type=application/rss+xml title="👨‍💻꿈꾸는 태태태의 공간"><link rel=stylesheet href=/lib/normalize/normalize.min.css><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=/lib/fontawesome-free/all.min.css><link rel=stylesheet href=/lib/animate/animate.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"WebSite","url":"https:\/\/taetaetae.github.io\/","inLanguage":"en","author":{"@type":"Person","name":"태태태"},"name":"👨‍💻꿈꾸는 태태태의 공간"}</script></head><body header-desktop=auto header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem('theme')?localStorage.getItem('theme')==='dark':('auto'==='auto'?window.matchMedia('(prefers-color-scheme: dark)').matches:'auto'==='dark'))&&document.body.setAttribute('theme','dark');</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title="👨‍💻꿈꾸는 태태태의 공간">👨‍💻꿈꾸는 태태태의 공간</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/>Posts </a><a class=menu-item href=/tags/>Tags </a><a class=menu-item href=/categories/>Categories </a><span class="menu-item delimiter"></span><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme"><i class="fas fa-adjust fa-fw"></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title="👨‍💻꿈꾸는 태태태의 공간">👨‍💻꿈꾸는 태태태의 공간</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><a class=menu-item href=/posts/>Posts</a><a class=menu-item href=/tags/>Tags</a><a class=menu-item href=/categories/>Categories</a><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme">
<i class="fas fa-adjust fa-fw"></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class="page home" posts><div class=home-profile><div class=home-avatar><a href=https://taetaetae.github.io/resume title=resume target=_blank><img class=lazyload src=/svg/loading.min.svg data-src=/images/profile.png data-srcset="/images/profile.png, /images/profile.png 1.5x, /images/profile.png 2x" data-sizes=auto alt=/images/profile.png title=/images/profile.png></a></div><h2 class=home-subtitle><div id=id-1 class=typeit></div></h2><div class=links><a href=https://github.com/taetaetae title=GitHub target=_blank rel="noopener noreffer me"><i class="fab fa-github-alt fa-fw"></i></a><a href=https://linkedin.com/in/%ed%83%9c%ea%b4%80-%ea%b6%8c-517825129/ title=LinkedIn target=_blank rel="noopener noreffer me"><i class="fab fa-linkedin fa-fw"></i></a><a href=https://www.instagram.com/_taetaetae title=Instagram target=_blank rel="noopener noreffer me"><i class="fab fa-instagram fa-fw"></i></a><a href=https://facebook.com/taetaetae0 title=facebook target=_blank rel="noopener noreffer me"><i class="fab fa-facebook fa-fw"></i></a><a href=mailto:taetaetae_@naver.com title=Email rel=me><i class="far fa-envelope fa-fw"></i></a><a href=/index.xml title=RSS target=_blank rel="noopener noreffer me"><i class="fas fa-rss fa-fw"></i></a></div></div><article class="single summary" itemscope itemtype=http://schema.org/Article><div class=featured-image-preview><a href=/posts/jenkins-job-parallel-processing-by-pipeline/><img class=lazyload src=/svg/loading.min.svg data-src=/images/jenkins-job-parallel-processing-by-pipeline/pipeline.jpg data-srcset="/images/jenkins-job-parallel-processing-by-pipeline/pipeline.jpg, /images/jenkins-job-parallel-processing-by-pipeline/pipeline.jpg 1.5x, /images/jenkins-job-parallel-processing-by-pipeline/pipeline.jpg 2x" data-sizes=auto alt=/images/jenkins-job-parallel-processing-by-pipeline/pipeline.jpg title=/images/jenkins-job-parallel-processing-by-pipeline/pipeline.jpg></a></div><h1 class=single-title itemprop="name headline"><a href=/posts/jenkins-job-parallel-processing-by-pipeline/>Jenkins Job을 병렬로 실행해서 속도를 개선해보자. (by. Pipeline)</a></h1><div class=post-meta><span class=post-author><a href=https://taetaetae.github.io/resume title=Author target=_blank rel="noopener noreffer author" class=author><i class="fas fa-user-circle fa-fw"></i>태태태</a></span>&nbsp;<span class=post-publish>published on <time datetime=2020-12-06>2020-12-06</time></span>&nbsp;<span class=post-category>included in <a href=/categories/tech/><i class="far fa-folder fa-fw"></i>Tech</a></span></div><div class=content>﻿　관리하는 URL이 200응답을 주고 있는지 모니터링을 한다고 가정해보자. 다양한 방법이 생각나겠지만 가장 처음으로 떠오른 건 단연 Jenkins. 간단하게 사용할 언어에 맞춰 Execute Script를 작성하고 스케줄링을 걸어 놓으면 큰 수고 없이 모니터링을 구성할 수 있게 된다. 아래는 python script로 작성해 보았다.
import requests url="http://모니터링url" status_code = requests.get(url).status_code if status_code != 200: print(f'응답 실패 :{url}, status : {status_code}') exit(1) ﻿　하지만 모니터링을 해야 하는 URL이 1개에서 여러 개로 늘어난다면 어떻게 될까? 단순하게 작성한 Script를 아래처럼 약간 수정하면 되긴 하지만 URL마다 응답속도가 다를 경우 순차적으로 실행하다 보니 실행 속도는 느릴 수밖에 없다.
import requests urls = [ "http://모니터링url-1", "http://모니터링url-2", "http://모니터링url-3" ] for url in urls: status_code = requests.get(url).status_code if status_code != 200: print(f'응답 실패 :{url}, status : {status_code}') exit(1) ﻿ 이러한 경우, 빠른 속도를 보장하기 위해서는 병렬로 실행을 해야 한다는 건 누구나 다 알지만 그렇다고 Thread를 사용하기엔 벌써부터 덜컥 부담이 된다. 그렇다고 Job을 URL 개수만큼 늘리기에는 배보다 배꼽이 더 커버리고&mldr; 그러다 발견한 기능이 바로 Jenkins Pipeline!
　이번 포스팅에서는 Jenkins Job을 동시에 여러 번 사용해야 하는 경우를 Pipeline을 통해서 개선한 내용에 대하여 공유해보려 한다. Jenkins Pipeline에 대해 들어만 봤는데 이번에 실제로 사용해보니 생각보다 쉽게 개선할 수 있었고 옵션들을 상황에 맞게 조합을 잘 한다면 상당히 활용성이 높아 보이는 기능인 것 같다.
기존상황 　테﻿스트를 위해 임의로 느린 응답을 생성하도록 URL을 구성하고 위에서 이야기했던 것처럼 Job 하나에 아주 심플하게 Python script를 작성하고 실행해보도록 하자. 임의로 느린 응답은 http://slowwly.robertomurray.co.uk/ 에서 제공하는 기능을 활용하였다.﻿
import requests urls = [ "http://slowwly.robertomurray.co.uk/delay/0/url/https://www.naver.com/", "http://slowwly.robertomurray.co.uk/delay/100/url/https://www.naver.com/", "http://slowwly.robertomurray.co.uk/delay/200/url/https://www.naver.com/", "http://slowwly.robertomurray.co.uk/delay/500/url/https://www.naver.com/", "http://slowwly.robertomurray.co.uk/delay/1000/url/https://www.naver.com/", "http://slowwly.robertomurray.co.uk/delay/2000/url/https://www.naver.com/", "http://slowwly.robertomurray.co.uk/delay/5000/url/https://www.naver.com/", "http://slowwly.robertomurray.co.uk/delay/10000/url/https://www.naver.com/", "http://slowwly.robertomurray.co.uk/delay/20000/url/https://www.naver.com/" ] for url in urls: status_code = requests.get(url).status_code if status_code != 200: print(f'응답 실패 :{url}, status : {status_code}') exit(1) print(f'응답성공 : {url}') 그래서 실행해보면 50초가 소요되었다. 자, 이제 개선을 해보자!
개선을 해보자 　﻿전체적인 개선의 흐름은 하나의 Job에 모니터링하고자 하는 url을 파라미터로 받아서 처리할 수 있도록 설정하고, 이를 Jenkins Pipeline 을 통해 여러 URL을 동시에 모니터링하게 구성하는 것이다. 그러면 두 개의 Job(파라미터로 받아 모니터링하는 Job, Jenkins Pipeline Job) 만으로 보다 빠르고 효율적인 구성을 할 수 있을 것으로 상상을 하고.
Job을 범용적으로 (Jenkins paramters 활용) 　﻿위에서 샘플로 작성하였던 Python script는 url 이 늘어날수록 Job 안에 script를 수정해야 한다. 그렇게 해도 무방하지만 이번 개선의 목표는 하나의 Job을 Pipeline 이 병렬로 컨트롤하도록 설정해야 했기 때문에 Jenkins Job에 파라미터를 받을 수 있도록 아래처럼 Jenkins Job 설정에 파라미터를 설정하고 Python script 또한 수정해 주자.
﻿Job > 구성 > 이 빌드는 매개변수가 있습니다" ﻿Job > 구성 > 이 빌드는 매개변수가 있습니다 import requests, os url = os.environ['url'] status_code = requests.get(url).status_code if status_code != 200: print(f'응답 실패 :{url}, status : {status_code}') exit(1) print(f'응답성공 : {url}') 병렬 실행을 위한 Jenkins 설정 　﻿Jenkins Job 을 생성하면 기본적으로 Job마다의 대기열(Queue)이 있어 Job이 실행 중이라면 시작된 시간 순서대로 기다렸다가 앞선 Job이 종료가 되면 이어서 실행되는 구조이다. 하지만 우리는 Job을 병렬로 실행해야 했기에 Job 설정 중 필요한 경우 concurrent 빌드 실행 옵션을 켜줘서 기다리지 않고 병렬로 실행될 수 있도록 해준다.
﻿Job > 구성 > 필요한 경우 concurrent 빌드 실행" ﻿Job > 구성 > 필요한 경우 concurrent 빌드 실행 　﻿또한 Jenkins Job 자체는 병렬로 실행되도록 설정되었다 해도 기본적으로 Jenkins 자체의 대기열은 한정되어 있기 때문에 적당히 늘려줘서 여러 개의 Job이 대기 열 없이 동시에 실행될 수 있도록 해준다.</div><div class=post-footer><a href=/posts/jenkins-job-parallel-processing-by-pipeline/>Read More</a><div class=post-tags><i class="fas fa-tags fa-fw"></i>&nbsp;<a href=/tags/jenkins/>jenkins</a>,&nbsp;<a href=/tags/pipeline/>pipeline</a>,&nbsp;<a href=/tags/archives-2020/>archives-2020</a></div></div></article><article class="single summary" itemscope itemtype=http://schema.org/Article><div class=featured-image-preview><a href=/posts/blog-reorganization-by-hugo/><img class=lazyload src=/svg/loading.min.svg data-src=/images/blog-reorganization-by-hugo/hexo_to_hugo.png data-srcset="/images/blog-reorganization-by-hugo/hexo_to_hugo.png, /images/blog-reorganization-by-hugo/hexo_to_hugo.png 1.5x, /images/blog-reorganization-by-hugo/hexo_to_hugo.png 2x" data-sizes=auto alt=/images/blog-reorganization-by-hugo/hexo_to_hugo.png title=/images/blog-reorganization-by-hugo/hexo_to_hugo.png></a></div><h1 class=single-title itemprop="name headline"><a href=/posts/blog-reorganization-by-hugo/>기술블로그 개편기 (by HUGO)</a></h1><div class=post-meta><span class=post-author><a href=https://taetaetae.github.io/resume title=Author target=_blank rel="noopener noreffer author" class=author><i class="fas fa-user-circle fa-fw"></i>태태태</a></span>&nbsp;<span class=post-publish>published on <time datetime=2020-11-29>2020-11-29</time></span>&nbsp;<span class=post-category>included in <a href=/categories/tech/><i class="far fa-folder fa-fw"></i>Tech</a></span></div><div class=content>웹서비스 개발자라면 나만의 블로그쯤은 있어야지 하며 기술 블로그를 시작한 지도 어느덧 4년이 되었다. 처음엔 그저 새로 알게 된 기술이나 삽질하며 경험한 것들 중에 핵심만을 적어놓는 수준이었다. (지금 다시 보면 뭔가 오글거리는 건 기분 탓이겠지&mldr;) 그렇게 계속 글을 써오면서 글쓰기라는 것에 관심을 갖게 되고 내 글이 누군가에게 도움이 될 거라는 기대에 조금이라도 글을 잘 써보고자 단순 기록 용이 아닌 하나의 &lsquo;글&rsquo;을 쓰려고 노력해 온 것 같다.
　일주일에 한 개는 써야지. 한 달에 한 개는 써야지. 하며 자꾸 나 자신과의 타협을 하다가 최근에는 회사에서 운영하는 서비스 개편 때문에 정신없이 바쁘다는 핑계로 &lsquo;블로그&rsquo;에 &lsquo;ㅂ&rsquo;자도 생각하지 못하게 된다. 무엇이 문제일까?라는 생각은 결국 내 기술 블로그도 회사 서비스처럼 &lsquo;개편&rsquo;을 해보자는 생각으로 도달하게 되었고 간단할 것만 같았던 기술 블로그 개편 작업은 꽤 오랫동안 + 다양한 삽질들로 작업을 하게 된다.
　이번 포스팅에서는 기술 블로그를 개편하며 겪었던 내용들에 대해 정리해보고자 한다. 기존에 기술 블로그를 운영하시는 분들이나 이번에 새롭게 시작하시는 분들께 도움이 될 거라 기대한다. 더불어 서비스 &lsquo;출시&rsquo; 가 아닌 개편&rsquo;이라는 과정 속에서 느끼게 되었던 인사이트도 간략하게 작성해볼까 한다.
기술블로그 플랫폼 선택 　처음 블로그를 쓰기 시작했을 때 포털서비스의 글쓰기 플랫폼을 사용하지 않은 이유는 단 하나다. &lsquo;글쓰기&rsquo; 뿐만 아니라 개발자이기에 웹사이트(블로그)를 내 입맛에 맞게 커스터마이징 하기 위해서. 그 이유로 hexo 라는 프레임워크에 github의 호스팅을 사용하여 운영을 해왔다. 그렇게 블로그를 운영해오면서 느꼈던 불편했던 부분들과 개편을 하며 기대하는 부분들을 정리하면 아래와 같다.
테마(UI)가 이뻐야 하고 기능들이 많으면 좋겠다. 기술 블로그인 만큼 코드가 많이 삽입되니 코드 표현 또한 이뻐야 한다. 테마 또는 프레임워크의 커뮤니티가 활발해야 한다. 페이지 생성 또는 만들어진 웹페이지의 성능이 좋아야 한다. 글을 작성하고 배포하는 과정이 심플하고 깔끔해야 한다. ﻿ 　위와 같은 이유를 기반으로 검색을 해보다 SSG(쓱 쇼핑몰 아님, Static site generators)를 깔끔하게 정리해 놓은 사이트를 발견한다. 정말 다양한 플랫폼들을 살펴보며 필자에게 맞는 게 어떤 건지 고민하다 결국 hugo 를 선택하게 된다. hugo를 선택한 이유는 go라는 언어를 사용한다는 것과 (간접적으로라도 다른 언어를 경험해보고 싶어서 + go 언어가 빠르다는 소리를 어디선가 들어서) 테마들이 너무 다양했기 때문이다.
﻿아주 대놓고 빠르다고 하니&mldr; 쓰고 싶어진다." ﻿아주 대놓고 빠르다고 하니&mldr; 쓰고 싶어진다. 　결국 hugo에 hugo-ranking-trend라는 사이트에서 상위에 랭크가 되어있고 기술 블로그 성격에 적합할 것 같은 LoveIt이라는 테마를 사용하기로 결정하였다. 자 그럼 시작해볼까?!
hugo 는 어떻게 쓰는거야? ﻿　대부분의 오픈소스는 hello world 혹은 quick start 같이 처음 접하는 사람들을 위한 도큐먼트가 있기 마련. hugo도 마찬가지로 quick-start가 있었고 이를 천천히 따라 하면 생각보다 쉽게 초기 세팅을 할 수 있었&mldr; 을꺼라 기대했지만 약간 초기 설정 과정이 어려워서 남겨 두고자 한다.
참고로 필자는 윈도 10 환경에서 구성하였다. mac이라면 더 쉽게 설정할 수 있는 것 같은데 이 부분은 OS의 차이에서 생겨나는 어쩔 수 없는 약간의 장벽이라 생각한다. 이쁜 테마와 새로운 환경을 사용할 수 있다는 기대감으로 꾹 참아본다.
기본설정 　﻿git이 설치되어 있다는 가정하에 우선 hugo는 go 언어기반으로 돌아가기에 우선 go를 설치해야 한다. 다운로드페이지에서 환경에 맞는 설치 파일을 다운로드하고 설치를 해준다. 다음으로 패키지 관리자인 chocolatey 또한 설치가 필요하다. 공식 홈페이지페이지에서 나와있는 순서대로 진행하면 설치 완료. 필자는 여기서 진행이 잘 안됐었는데, &lsquo;관리자 권한&rsquo;으로 PowerShell 을 실행시켜야지만 성공을 할 수 있었다.﻿
﻿　위 설정이 완료되었으면 드디어 hugo를 설치해 주고 초기화를 해준 뒤 샘플로 글 하나를 만들고 서버를 띄우면 끝.
# chocolatey 에 의해 hugo 설치 choco install hugo -confirm # hugo 초기화 hugo new site quickstart # post 생성 hugo new posts/post-name.</div><div class=post-footer><a href=/posts/blog-reorganization-by-hugo/>Read More</a><div class=post-tags><i class="fas fa-tags fa-fw"></i>&nbsp;<a href=/tags/hugo/>hugo</a>,&nbsp;<a href=/tags/blog/>blog</a>,&nbsp;<a href=/tags/github-actions/>github-actions</a>,&nbsp;<a href=/tags/archives-2020/>archives-2020</a></div></div></article><article class="single summary" itemscope itemtype=http://schema.org/Article><div class=featured-image-preview><a href=/2020/10/04/a-good-developer-in-terms-of-log-and-monitoring/><img class=lazyload src=/svg/loading.min.svg data-src=/images/a-good-developer-in-terms-of-Log-and-Monitoring/logAndMonitoring-logo.jpg data-srcset="/images/a-good-developer-in-terms-of-Log-and-Monitoring/logAndMonitoring-logo.jpg, /images/a-good-developer-in-terms-of-Log-and-Monitoring/logAndMonitoring-logo.jpg 1.5x, /images/a-good-developer-in-terms-of-Log-and-Monitoring/logAndMonitoring-logo.jpg 2x" data-sizes=auto alt=/images/a-good-developer-in-terms-of-Log-and-Monitoring/logAndMonitoring-logo.jpg title=/images/a-good-developer-in-terms-of-Log-and-Monitoring/logAndMonitoring-logo.jpg></a></div><h1 class=single-title itemprop="name headline"><a href=/2020/10/04/a-good-developer-in-terms-of-log-and-monitoring/>그런 개발자로 괜찮은가 - '로그 & 모니터링' 편</a></h1><div class=post-meta><span class=post-author><a href=https://taetaetae.github.io/resume title=Author target=_blank rel="noopener noreffer author" class=author><i class="fas fa-user-circle fa-fw"></i>태태태</a></span>&nbsp;<span class=post-publish>published on <time datetime=2020-10-04>2020-10-04</time></span>&nbsp;<span class=post-category>included in <a href=/categories/essay/><i class="far fa-folder fa-fw"></i>essay</a></span></div><div class=content>캐릭터를 육성하며 게임하는 경우를 생각해 보자. 더 좋은 아이템을 얻거나 퀘스트를 달성하기 위해 당신은 다양한 방법을 통해 캐릭터를 성장시킨다. 사냥을 하다 체력이 떨어지게 되면 물약을 먹고, 캐릭터의 능력 중 부족한 부분이 있으면 훈련을 더 하거나 그에 맞는 아이템을 장착하게 된다. 이렇게 캐릭터의 &lsquo;상태&rsquo;를 적절한 UI를 통해 사용자에게 알려주기 때문에 &lsquo;확인&rsquo;이 가능하고 &lsquo;대응&rsquo;이 가능하게 된다.
　우리가 만드는 애플리케이션 또한 위에서 이야기 한 게임상의 캐릭터가 아닐까 싶다. 복잡한 스펙을 다양한 테스트 케이스를 만들며 로직 동작에는 이상이 없음을 확인했다면 그걸로 만족할 수 있을까? 개발자의 &lsquo;레벨&rsquo;은 이 부분에서 차이가 난다고 생각한다. 운영환경에 출시한 애플리케이션에 에러가 나는지, 트래픽이 얼마나 들어오고 있고 트래픽의 유형은 또 어떠한지, 요청에 대한 응답속도는 어떻고 서버의 시스템 지표에는 문제가 없는지 등등. 애플리케이션의 유형에 따라 다양하겠지만 적절한 로그를 이용하여 애플리케이션의 &lsquo;상태&rsquo;를 확인하고 문제가 있다면 &lsquo;대응&rsquo;하는 게 꼭 필요하다고 생각한다.
　이번 포스팅에서는 크게 로깅과 모니터링에 대해 알아보고자 한다. 이를 통해 애플리케이션의 &lsquo;개발&rsquo;에만 집중하고 있던 관점을 보다 더 높은 곳에서 바라보며 애플리케이션의 &lsquo;운영&rsquo; 측면에서도 고민해 보는 기회가 되었으면 한다.
필자는 서버 개발자이다 보니 글의 내용이 다소 서버 개발자의 시선에서 작성하게 되었다. 하지만 &lsquo;개발자&rsquo;라면 유형만 다르지 대부분 비슷하기 때문에 크게 다르지 않다고 생각한다.
로그는 어떤걸, 어떻게 남겨야 할까? 　﻿로그가 왜 필요한지에 대한 내용은 다루지 않겠다. (굳이 말하지 않아도 그만큼 중요하다는 표현이 더 어울릴 수도 있겠다.) 그렇다면 우선 어떤 로그를 남겨야 할까?
필자가 꿈나무 시절때 나누었던 조직장님과의 대화 내용" 필자가 꿈나무 시절때 나누었던 조직장님과의 대화 내용 　﻿아직까지도 기억에 남아있는 예전 조직 장님과의 대화. 일단 로그는 최대한 많이 (과하게) 남겨야 한다고 생각한다. 그다음 불필요한 로그들은 제거하거나 레벨을 낮추는 등 상황에 맞도록 커스터마이징이 필요하다. 경험을 해보면 알겠지만 운영환경에 애플리케이션을 배포하고 서비스를 운영하다 보면 개발 환경에서 만나기 어렵거나 경험해보지 못한 상황이 발생하곤 한다. 이럴 때 상황에 맞는 로그들이 있다면 미리 남겨둔 로그를 통해 더 효과적으로 상황을 파악할 수 있다. 트래픽의 정보(request url, parameter, UA, remote ip 등)를 남겨서 외부에서 호출하는 형태를 분석하는데 활용할 수도 있고, 애플리케이션에서 외부로 호출을 하고 난 뒤에 받는 응답에 대해서 로그를 남겨두면 외부 통신의 오류를 파악하는 데 도움이 될 수 있다. 어떤 로그를 남겨야 하는가에 대한 고민은 운영하는 애플리케이션이 어떤 행동을 하는가에 관점을 두고 고민해보면 좀 더 쉽게 찾을 수 있을 것이라 생각한다.
　로그를 남기는 방법 또한 다양하다. 시스템 로컬에 파일로 남기거나 특정 로그 서버를 설정하여 여러 대의 서버 로그를 한곳에서 볼 수도 있다. 다만 로그를 &lsquo;남기는&rsquo; 것 또한 하나의 비용에 포함되기 때문에 애플리케이션의 기능에 최대한 영향이 가지 않도록 최대한 빠른 시간 내에 처리가 되도록 해야 한다. (혹은 비동기로 남기거나 등)
　로그를 남기는 이유 중 가장 큰 이유는 &lsquo;나중에 보기 위해서&rsquo;이다. 그만큼 한번 로그를 남길 때에도 보기 좋게 남겨야 한다. 예컨대, 아래에 적어놓은 로그 방식의 경우 작은 차이지만 나중에 볼 때 꽤 큰 차이를 유발한다. ﻿
안좋은 예 try { ... } catch (Exception e){ log.Error(e); // 어떤 상황이지..? } 보다 조금 더 좋은 예 try { ... } catch (Exception e){ log.Error("url : " + url + ", parameter : " + parameter + ", remote ip : " + remoteIp, e); // 로그는 가급적 자세하게 ! } 로그가 가져다 주는 또 다른 세상 　로그는 또 다른 데이터가 될 수 있다.</div><div class=post-footer><a href=/2020/10/04/a-good-developer-in-terms-of-log-and-monitoring/>Read More</a><div class=post-tags><i class="fas fa-tags fa-fw"></i>&nbsp;<a href=/tags/log/>log</a>,&nbsp;<a href=/tags/monitoring/>monitoring</a>,&nbsp;<a href=/tags/a-good-developer/>a-good-developer</a>,&nbsp;<a href=/tags/archives-2020/>archives-2020</a></div></div></article><article class="single summary" itemscope itemtype=http://schema.org/Article><div class=featured-image-preview><a href=/2020/09/07/github-pullrequest-build/><img class=lazyload src=/svg/loading.min.svg data-src=/images/github-pullrequest-build/programmer-github-jenkins.jpg data-srcset="/images/github-pullrequest-build/programmer-github-jenkins.jpg, /images/github-pullrequest-build/programmer-github-jenkins.jpg 1.5x, /images/github-pullrequest-build/programmer-github-jenkins.jpg 2x" data-sizes=auto alt=/images/github-pullrequest-build/programmer-github-jenkins.jpg title=/images/github-pullrequest-build/programmer-github-jenkins.jpg></a></div><h1 class=single-title itemprop="name headline"><a href=/2020/09/07/github-pullrequest-build/>빌드/테스트는 내가 해줄게. 너는 코딩에 집중해 (by GitHub Pull Request Builder)</a></h1><div class=post-meta><span class=post-author><a href=https://taetaetae.github.io/resume title=Author target=_blank rel="noopener noreffer author" class=author><i class="fas fa-user-circle fa-fw"></i>태태태</a></span>&nbsp;<span class=post-publish>published on <time datetime=2020-09-07>2020-09-07</time></span>&nbsp;<span class=post-category>included in <a href=/categories/tech/><i class="far fa-folder fa-fw"></i>Tech</a></span></div><div class=content>git 은 분산 버전 관리 시스템 중 가장 잘 알려져 있다고 해도 과언이 아닐 정도로 대부분의 시스템에서 사용되고 있는 것 같다. 이를 웹서비스에서 보다 편하게 사용할 수 있도록 한 시스템이 Github. Github 을 사용하는 이유 중에 가장 큰 이유를 하나만 이야기해보자면 바로 온라인상에서 코드 리뷰를 할 수 있는 pullRequest라는 기능 때문이 아닐까 조심스럽게 생각을 해본다.
　pullRequest는 work branch에서 작업한 내용을 base branch로 merge 전 꼭 코드 리뷰가 아니더라도 작업한 내용에 대해서 다양한 검사를 자동화할 수 있는 강력한 기능들이 많다. 이러한 자동화는 CI(지속적 통합) 관점에서 매우 중요한데 코드에 대해 체크해야 할 부분들(빌드, 테스트, 정적 분석 등)을 &ldquo;알아서&rdquo; 해준다면 작업자는 오롯이 비즈니스 로직 개발에 대해서만 신경 쓸 수 있으니 생산성 절약 측면에서 엄청난 효과를 볼 수 있다.
내가 하는일에만 집중할 수 있게! 출처 : https://www.clien.net/service/board/park/10453442" 내가 하는일에만 집중할 수 있게! 출처 : https://www.clien.net/service/board/park/10453442 이번 포스팅에서는 그중에서도 아주 간단한 설정만으로 work branch의 빌드 상태를 검사해 볼 수 있는 Jenkins의 Github Pull Request Builder를 설치 및 활용해 보고자 한다.
사실 최근 팀에서 CI 서버를 이전해야 했었다. 머릿속에서는 어떻게 하면 되겠지 싶었지만 막상 해보려니 Jenkins 버전업도 되었고 뭐부터 해야 할지 허둥대는 필자가 부끄러웠다. 이참에 정리를 해보며 다시 한번 리마인드 하는 시간을 가져보고자 한다. (이래서 기억보다 기록이 중요하다.)
준비물 　전체적인 흐름은 아래 그림처럼 흘러가기 때문에 당연히 서버에 Jenkins 가 설치되어 있어야 한다. Jenkins 설치는 필자의 포스팅(Jenkins 설치 치트키)를 참고해 보는 것도 좋을 것 같다.
전체적인 흐름" 전체적인 흐름 　참고로 필자는 GitHub Enterprise 버전에서 사용했는데 일반 Github에서도 동일한 방법으로 사용 가능하다.
Github과 Jenkins의 연동을 위한 2가지 설정 　Github 과 Jenkins 가 통신이 되도록 설정해 줘야 한다. 그래야 Github의 코드를 받아서 Jenkins 가 빌드를 하고 그 빌드 결과를 다시 Github에 리포트가 가능해지기 때문이다. 먼저 첫 번째로 ssh 설정으로 Github의 코드를 가져오도록 ssh 설정을 해두자. ssh 설정하는 방법은 필자의 포스팅(Github과 Jenkins 연동하기)편을 확인해보면 될 것 같다.
　그다음으로 아래에서 이야기할 GitHub Pull Request Builder라는 Jenkins plugin 이 빌드가 끝난 뒤에 결과를 리포팅 해줄 수 있는 인증 토큰을 발급받아두자. Github > Settings > Developer settings > Personal access tokens 화면에서 키를 생성하고 만들어진 키를 저장해 둔다. (이 키는 보안에 유의해야 하고, 화면 경고(?)에서도 볼 수 있듯이 키는 생성 시 한 번밖에 볼 수 없기 때문에 미리 저장해 둬야 한다.)
인증토큰을 미리 받아두자." 인증토큰을 미리 받아두자. Jenkins 설정 　Jenkins > 관리 > pluginManager에 들어가 GitHub Pull Request Builder를 검색 후 설치해 준다. 그러고 나서 Jenkins > 관리 > 환경설정에 들어가 보면 아래와 같이 GitHub Pull Request Builder 항목이 생긴 것을 확인할 수 있고 위에서 설정한 인증토큰을 아래처럼 등록 후 저장을 한다.
credentials 을 위에서 발급받은 인증토큰으로 등록해준다." credentials 을 위에서 발급받은 인증토큰으로 등록해준다. 　Jenkins job을 하나 만들고 pullRequest 가 발생했을 때 자동으로 실행될 수 있도록 설정을 해준다. 먼저 General 탭에 Github project에 Github url 을 적어주고
　소스 코드 관리 탭에서 ssh 주소를 적고 위에서 미리 설정한 ssh 키로 credentials 값을 넣어준다. 전에도 이야기했지만 이 부분에서 오류가 발생하면 빨간색 글씨로 오류 내용이 나오고 아래 화면처럼 오류가 없다면 아무것도 안 나온다. Refspec 에 +refs/pull/*:refs/remotes/origin/pr/* 라고 적어주고 브랜치 설정은 파라미터로 받아와서 pullRequest를 발생시킨 브랜치를 빌드 할 수 있도록 ${sha1} 라고 적어주자.</div><div class=post-footer><a href=/2020/09/07/github-pullrequest-build/>Read More</a><div class=post-tags><i class="fas fa-tags fa-fw"></i>&nbsp;<a href=/tags/github/>github</a>,&nbsp;<a href=/tags/pullrequest/>pullRequest</a>,&nbsp;<a href=/tags/jenkins/>jenkins</a>,&nbsp;<a href=/tags/ci/>ci</a>,&nbsp;<a href=/tags/archives-2020/>archives-2020</a></div></div></article><article class="single summary" itemscope itemtype=http://schema.org/Article><div class=featured-image-preview><a href=/2020/07/12/toy-projects-second-year-review/><img class=lazyload src=/svg/loading.min.svg data-src=/images/toy-projects-second-year-review/ddb.jpg data-srcset="/images/toy-projects-second-year-review/ddb.jpg, /images/toy-projects-second-year-review/ddb.jpg 1.5x, /images/toy-projects-second-year-review/ddb.jpg 2x" data-sizes=auto alt=/images/toy-projects-second-year-review/ddb.jpg title=/images/toy-projects-second-year-review/ddb.jpg></a></div><h1 class=single-title itemprop="name headline"><a href=/2020/07/12/toy-projects-second-year-review/>벌써 2년 (feat. 토이프로젝트 회고,가치,수입)</a></h1><div class=post-meta><span class=post-author><a href=https://taetaetae.github.io/resume title=Author target=_blank rel="noopener noreffer author" class=author><i class="fas fa-user-circle fa-fw"></i>태태태</a></span>&nbsp;<span class=post-publish>published on <time datetime=2020-07-12>2020-07-12</time></span>&nbsp;<span class=post-category>included in <a href=/categories/review/><i class="far fa-folder fa-fw"></i>review</a></span></div><div class=content>정확히 2018년 07월 12일 필자의 첫 토이 프로젝트인 ‘기술 블로그 구독 서비스’를 오픈하게 된다. 얼마나 많이 구독(가입) 하겠어 하는 생각이 부끄러울 만큼 6개월이 지나 구독자 수는 1,000명을 넘기고 1년이 지나 2,000명.어느덧 달력을 보니 오늘이 정확하게 토이 프로젝트를 서비스한지 벌써 2년이 되는 날. 구독자 수는 어느덧 3,000명을 넘어선다. 뭔가 뿌듯하면서도 서비스를 좀 더 디벨롭 하지 못한 필자 자신을 돌아보니 괜히 마음이 무거워지고.
뭔가 해야하는데&mldr; 괜히 눈치만 보이네&mldr;출처 : http://egloos.zum.com/nievess/v/657827" 뭔가 해야하는데&mldr; 괜히 눈치만 보이네&mldr;
출처 : http://egloos.zum.com/nievess/v/657827 　지난 2년 동안을 돌이켜보며 서비스를 어떻게 운영해 왔는지, 그리고 토이 프로젝트가 필자에게 어떤 영향을 주었는지 되돌아보며 셀프 리뷰를 해 보고자 한다.
서비스 자체 평가 심플한 기능 　말 그대로 토이 프로젝트이기 때문에 기능 또한 아주 간단하다. awesome-devblog에서 제공하는 개인/단체 블로그들의 포스팅을 조회하여 어제 작성된 글들만 모아 발송한다. 거기에 주간 많이 클릭된 포스팅을 모아서 한 번 더 발송하는 기능까지. 추가적인 기능을 더 디벨롭 해야 하는데 아이디어가 없어서 인지 디벨롭 할 힘이 안 나서 인지 유지만 하고 있는 상태다.
서비스에 없어서는 안될 &lsquo;로깅(Logging)&rsquo; 　형식을 막론하고 컴퓨터로 돌아가는 모든 &lsquo;프로그램&rsquo;은 상황에 따라 미리 만들어 놓은 로직에 따라 움직이는 로봇에 불과하다. 물론 요즘에는 머신러닝이나 AI 같은 기술들로 컴퓨터가 스스로 학습하는 경우도 있지만 그 또한 미리 코딩을 통해 만들어진 부분들. 그렇기 때문에 2년이 지난 지금 이제까지 서비스가 어떻게 돌아갔는지를 확인하기 위해서는 사전에 준비해야 할 것이 있다. 그것은 바로 &lsquo;로깅&rsquo;. 서비스 투입 전부터 프론트부터 백엔드까지 다양한 로깅을 해서인지 2년이 지난 지금, 기록된 로그로 다양한 서비스 지표를 확인해 볼 수 있음에 다행이라 생각한다.
각종 지표 　먼저 봐야 할 지표는 당연히 가입/해지 추이. 드라마틱 한 선형 그래프는 아니지만 당연히(?) 해지 보다 가입이 더 많고 시간이 지날수록 어느 정도 꾸준하게 가입자가 들어오는 것을 보면 어떻게 알고 가입을 하러 오는지 신기할 따름이다. 하지만 마냥 신기해하지만 말고 해지하는 원인을 분석해야 할 필요가 있어 보인다. 아마도 수집하는 블로그들 중 간혹 개발과 관련되지 않는 글들이 종종 수집되어서 그런 것 같기도 하다.
가입/해지 트랜드" 가입/해지 트랜드 　다음으로는 클릭수. 눈치가 빠른 분들은 이미 알고 있겠지만 이메일에서 클릭 시 서버에서 각종 로깅을 하고 넘어가게 된다. 그러다 보니 클릭 성향(?)에 대해 집계도 가능한데 아래 지표를 보면 오전 일과를 시작하면서 메일로 종합된 기술 블로그 들을 읽기 시작하고 그중에서 특히 월요일 - 10시가 가장 많은 클릭수가 집계되었다.
클릭수 트랜드 | 시간+요일 별 클릭수 트랜드 | 시간+요일 별 클릭수 히트맵" 클릭수 트랜드 | 시간+요일 별 클릭수 트랜드 | 시간+요일 별 클릭수 히트맵 　이 포스팅을 작성하고 있는 지금까지 약 19,000여 개의 포스팅을 수집하고 발행하였는데 그중에서 가장 인기 있었던 포스팅 TOP 30 은 다음과 같다. 아무래도 단체 블로그의 포스팅을 메일 상단에 위치하고 노란색으로 테두리를 표시해서인지 대부분의 글들이 단체 블로그의 포스팅인 것을 알 수 있다.
이 회사, 이 세상 쿨함이 아니다 대놓고 자랑하는 글 LINE 신입 SW 개발자 코딩 테스트, 이렇게 만들어졌습니다 우테코에서 찾은 나만의 효과적인 공부법 LINE 서버 개발자가 되기까지 내가 준비한 것들 연봉을 높이는 가장 쉬운 방법은? 학교에서 알려주지 않는 17가지 실무 개발 기술 리뷰 간단하게 만드는 이상한 알람 팀 문화의 탄생 LINE에서 전 직원이 재택 근무하면서 생산성을 유지하는 방법 Flutter, 왜 선택하지 못했나 주석 달 시간에 프로그래밍을 제대로 하기 우아한테크코스 : 새로운 시작 기획자는 필요없다. 간단하게 구축해 보는 JavaScript 개발 환경 우아한테크코스 : 나만의 항로 찾기 코드리뷰 모음 서비스를 소개합니다.</div><div class=post-footer><a href=/2020/07/12/toy-projects-second-year-review/>Read More</a><div class=post-tags><i class="fas fa-tags fa-fw"></i>&nbsp;<a href=/tags/archives-2020/>archives-2020</a></div></div></article><article class="single summary" itemscope itemtype=http://schema.org/Article><div class=featured-image-preview><a href=/2020/06/28/a-good-developer-in-terms-of-self-development/><img class=lazyload src=/svg/loading.min.svg data-src=/images/a-good-developer-in-terms-of-self-development/self-development-logo.jpg data-srcset="/images/a-good-developer-in-terms-of-self-development/self-development-logo.jpg, /images/a-good-developer-in-terms-of-self-development/self-development-logo.jpg 1.5x, /images/a-good-developer-in-terms-of-self-development/self-development-logo.jpg 2x" data-sizes=auto alt=/images/a-good-developer-in-terms-of-self-development/self-development-logo.jpg title=/images/a-good-developer-in-terms-of-self-development/self-development-logo.jpg></a></div><h1 class=single-title itemprop="name headline"><a href=/2020/06/28/a-good-developer-in-terms-of-self-development/>그런 개발자로 괜찮은가 - '자기계발' 편</a></h1><div class=post-meta><span class=post-author><a href=https://taetaetae.github.io/resume title=Author target=_blank rel="noopener noreffer author" class=author><i class="fas fa-user-circle fa-fw"></i>태태태</a></span>&nbsp;<span class=post-publish>published on <time datetime=2020-06-28>2020-06-28</time></span>&nbsp;<span class=post-category>included in <a href=/categories/essay/><i class="far fa-folder fa-fw"></i>essay</a></span></div><div class=content>학창 시절엔 &lsquo;선생님&rsquo;께서 정해놓으신 커리큘럼에 따라가기만 하면 큰 문제 없이 지식을 학습할 수 있었다. 거기에 주기적으로 치르는 시험을 통해 &lsquo;점수&rsquo;라는 평가 기준으로 얼마나 잘 성장했나를 검사하기도 한다. 졸업 후 어렵게 어렵게 취업에 성공을 하여 &lsquo;신입 개발자&rsquo;라는 배지를 달고 회사에 첫 출근. 그렇게 n 년이 지난 지금과 라떼 시절(?)을 비교해 보며 과연 &lsquo;학습&rsquo;에 대한 열정 그래프가 아직도 우상향 중인가? 하는 질문엔 일단 단전부터 올라오는 깊은 한숨과 함게 이상하게도 앞이 캄캄해진다.
우리는 모두 라떼 시절을 가지고 있다. 출처 : https://www.dogdrip.net/212294087" 우리는 모두 라떼 시절을 가지고 있다. 출처 : https://www.dogdrip.net/212294087 　배워야 할게 너무 많다. 아니 그보다 배운 것을 이제 활용해야지 싶으면 또 새로운 기술이 등장한다. 그렇게 매너리즘에 빠지고. 거기다 회사일이 바쁘다는 핑계로 자기계발을 멈추다 보면 남들보다 뒤처진다는 생각에 괜히 자괴감이 들어 우울해 지곤 한다. (코로나 블루 때문만은 아니겠지&mldr;) 그 가운데 회사에는 정말 좋은 선배님들도 많고 멘토-멘티 관계를 잘 활용하면 충분히, 잘, 올바른 길로 성장할 수 있을 것이라 생각한다. 하지만 그렇게 누군가에게 &lsquo;의존&rsquo;만 하다 그 대상이 없어진다든지 심지어 그런 대상조차 없을 경우에는 어떻게 해야 할까? 점점 기술은 발전하고 배워야 할 것들은 홍수처럼 넘쳐흐르고 있는 가운데 &lsquo;회사원&rsquo;에서 나아가 &lsquo;개발자&rsquo;로써 성장을 하기 위해서는 어떠한 방법이 있을까?
　이번 포스팅에서는 개발자로 살아가면서 성장하기 위한즉, 자기계발의 &lsquo;방법&rsquo;에 대해 이야기해보려 한다. 이것이 정답이다 하는 은 탄환을 소개하려는 것은 아니다. 특히 개발자로서의 생을 마감(?) 할 때까지는 계속 배워야 하는 숙명과도 같은 직업이기에 첫 단추를 잘 끼워서 갑작스러운 기술의 변화에 일희일비 하지 않고 스펀지처럼 무엇이든 흡수하는. 말랑말랑한 정신을 갖기 위함이라고나 할까.
블로그 　개발자가 글도 써야 하나?라는 질문에는 필자가 예전에 정리해둔 개발하기 바쁜데 글까지 쓰라고? (글쓰는 개발자가 되자.)라는 글을 참고해봐도 좋을 것 같다. 해당 포스팅에서 수차례 강조하였지만 그만큼 개발자에게는 특히나 글쓰기가 중요하고 필요하다. 글을 꼭 &lsquo;잘&rsquo;써야 한다는 부담을 가질 필요는 없다. (필자도 그렇게 잘 쓰는 편은 아니다&mldr;) 다만 무언가를 기록하고 정리하고 자신만의 기준에 맞추어 재 정리하는 습관을 기르다 보면 이러한 생각들이 개발을 할 때에도 도움이 상당히 되었기 때문이다.
개발을 하다보면 꼼꼼하게 체크해야할 예외가 너무 많다. 출처 : https://gfycat.com/ko/menacingeducatedatlasmoth" 개발을 하다보면 꼼꼼하게 체크해야할 예외가 너무 많다. 출처 : https://gfycat.com/ko/menacingeducatedatlasmoth 　복잡한 구조가 필요로 하는 개발을 해야 한다고 가정해보자. 연동하는 시스템도 많고 정말 다양한 요구 사항을 하나의 시스템에서 구현을 해야 할 경우 보통 개발을 하기에 앞서 &lsquo;설계&rsquo;라는 단계를 거치기 마련이다. 그때 글쓰기를 했을 때의 습관(스킬?)을 적용해 보면 요구 사항들 중에 중요한 feature 기준으로 정리를 하게 되고, 각 이해관계자들에게 정리한 부분을 공유하며 예외 상황을 보다 빠르게 확인할 수도 있다. 심지어 코드 레벨에서도 지난밤에 야식으로 먹은 라면 면발처럼 꼬여있는 부분들을 보다 개발하기 편하고 유지 보수가 용이하게 구조를 변경하는 &lsquo;정리&rsquo;의 습관 또한 글쓰기를 통해서 수련을 할 수 있다. 이러한 &lsquo;꼼꼼함&rsquo;을 기르는 데에는 글쓰기만 한 게 없다고 생각한다.
　우리는 다양한 개발 언어로 코딩을 하곤 한다. 왜 읽기좋은 코드가 좋은 코드라는 책이 있듯이 결국 코딩 또한 커뮤니케이션이 일종이라 생각한다. 내가 생각하는 로직을 개발 언어로 코딩을 해야 하는 상황이면, 결국 내가 생각하는 로직이 명료하고 정리가 잘 된 상태에서야 코드 또한 소위 &lsquo;읽기 좋은 코드&rsquo;가 되지 않을까 싶다.
　블로그를 시작할 때 어디서부터 시작해야 하나 막막하다면, 오늘의 배운 내용 (개발자들 사이에서 유행처럼 번지고 있는 TIL에 대해서 정리해 보는 것부터 추천한다. 경력이 1년 차여도 10년 차여도 개발을 하다 보면 새로운 것을 발견하기 마련이다. 그렇게 조금씩 적절한 블로그 플랫폼에 정리를 해 나가다 보면 어느새 자신만의 개발 히스토리가 만들어지고, 나아가 글쓰기가 전해주는 긍정적인 효과를 만끽하리라 자부한다.</div><div class=post-footer><a href=/2020/06/28/a-good-developer-in-terms-of-self-development/>Read More</a><div class=post-tags><i class="fas fa-tags fa-fw"></i>&nbsp;<a href=/tags/self-development/>self-development</a>,&nbsp;<a href=/tags/a-good-developer/>a-good-developer</a>,&nbsp;<a href=/tags/archives-2020/>archives-2020</a></div></div></article><article class="single summary" itemscope itemtype=http://schema.org/Article><div class=featured-image-preview><a href=/2020/06/21/a-good-developer-in-terms-of-culture/><img class=lazyload src=/svg/loading.min.svg data-src=/images/a-good-developer-in-terms-of-culture/culture_logo.jpg data-srcset="/images/a-good-developer-in-terms-of-culture/culture_logo.jpg, /images/a-good-developer-in-terms-of-culture/culture_logo.jpg 1.5x, /images/a-good-developer-in-terms-of-culture/culture_logo.jpg 2x" data-sizes=auto alt=/images/a-good-developer-in-terms-of-culture/culture_logo.jpg title=/images/a-good-developer-in-terms-of-culture/culture_logo.jpg></a></div><h1 class=single-title itemprop="name headline"><a href=/2020/06/21/a-good-developer-in-terms-of-culture/>그런 개발자로 괜찮은가 - '문화' 편</a></h1><div class=post-meta><span class=post-author><a href=https://taetaetae.github.io/resume title=Author target=_blank rel="noopener noreffer author" class=author><i class="fas fa-user-circle fa-fw"></i>태태태</a></span>&nbsp;<span class=post-publish>published on <time datetime=2020-06-21>2020-06-21</time></span>&nbsp;<span class=post-category>included in <a href=/categories/essay/><i class="far fa-folder fa-fw"></i>essay</a></span></div><div class=content>한동안 글을 쓰지 않았다. 글을 쓰지 않은 것일까 쓰지 못한 것일까. 이런저런 이유로 번아웃 늪에 빠져버려 아무것도 하기 싫어서라는 핑계가 어울릴 수도 있겠다만. 요즘 들어 더욱더 무기력함이 극도로 뿜뿜대는 가운데 문득, 개발자로써 얼마나 잘 지내왔는가 뒤를 돌아보고 싶었다. 앞만 보고 달리는 것보다 내 생각과 내 호흡을 점검하는 것 또한 중요하다고 생각했기에 당분간은 더 나은 개발자가 되기 위한 여러 가지 주제로 글을 써보려 한다. 이름하여 그런 개발자로 괜찮은가 XX 편
어디까지나 필자의 생각에 대해 적는 것일 뿐 내용이 잘못되었을 수도 있다. 즉, 정답이 아니라는 이야기. 필자의 이러한 포스팅으로 이 글을 읽는 여러분들도 자신만의 가치관을 정립해보는 기회가 되고 나아가 모두가 더 나은 개발자로 한걸음 올라서는 아름다운 세상을 꿈꾸는 마음으로 작은 날갯짓을 해본다.
　개발자로 살아가는 데 있어 가장 중요한 게 무엇일까? 물론 개발할 수 있는 기술이 가장 중요하겠지만 몇 년 전부터 기술의 발전이 급변하는 세상 속에서 과연 기술만이 중요할까? 기술만 잘 알고 있으면 복잡하게 꼬인 스파게티 면 같은 문제 많은 코드를 술술 풀어헤치고, 언제 어디서든 개발자로써 행복한 삶을 영유할 수 있을까?
　여러 가지 중요한 요소들 중 가장 첫 번째로 떠오르는 키워드는 바로 문화(Culture)가 아닐까 싶다. 그럼 왜 문화가 개발자에게 중요하고 어떤 식으로 문화를 만들어 가는 게 좋을지에 대해 정리해보고자 한다.
각 팀에 맞는 문화는 모두를 성장시킬 수 있다. 출처 : https://steemkr.com/kr-dev/@dreamisnowhere/5squ7b" 각 팀에 맞는 문화는 모두를 성장시킬 수 있다. 출처 : https://steemkr.com/kr-dev/@dreamisnowhere/5squ7b 　개발자라는 직업을 가지고 있는 분들 중에 프리랜서나 1인 스타트업을 운영하는 분들은 제외하고. 대부분의 사람들은 여러 명과 함께 공동의 목표를 달성하기 위한 &ldquo;팀"이라는 단위에 소속되어 개발을 하고 있다. 야근을 매일 밥 먹듯이 하는 조직도 있을 테고 이른바 워라벨을 잘 지키며 듣기만 해도 반가운 소리인 &ldquo;칼퇴"를 밥 먹듯이 하는 조직도 있을 테고. 여기서 말하고자 함은 이러한 야근 vs 칼퇴처럼 &ldquo;근무 시간의 양"에 대해 이야기하려는 건 아니다. 회사, 더 깊게는 팀 내에서 어떤 문화 안에서 개발자로 살아가고 있는지에 대해 이야기하려 한다.
코드리뷰 　팀에 속해서 개발을 하다 보면 같은 코드를 동시에 작업하곤 한다. 그래서 형상관리 도구 (요즘 git 을 안 쓰는 곳이 없을 정도&mldr;)를 사용해서 동시에 개발을 진행해도 전혀 무리가 없을 정도인데 결국 작업한 결과물을 한 곳으로 병합 (merge) 해야 하는 시점이 오기 마련이고 그때엔 (온라인/오프라인) 코드 리뷰를 하게 된다. 어떠한 사연으로 코드 리뷰 없이 빨리 merge 해야 하는 건 이해되지만 가급적 한 명 이상의 리뷰어가 승인을 한 뒤에 merge 가 돼야 한다고 생각한다. (pullRequest를 단순 merge 용으로 사용하는 건 정말 잘못된 방법 중 하나) 중복된 코드를 만들었거나 작업자가 예상하지 못한 부분들을 릴리스 전에 서로 이야기해보면서 버그를 수정하거나 팀 컨벤션, 설계/구조를 더 효율적으로 가져갈 수 있는 절호의 찬스.
　여기서 중요한 포인트는 리뷰를 받는 &lsquo;리뷰이&rsquo; 와 리뷰를 해주는 &lsquo;리뷰어&rsquo;들의 문화적인 측면에서 생각을 해볼 필요가 있다.
리뷰이(Reviewee) 리뷰어의 소중한 시간을 할애해서 자신의 코드가 이상이 없는지에 대한 &lsquo;도움&rsquo;을 요청하는 것이기 때문에 최대한 설명을 잘 적어서 리뷰하는 데 도움을 줄 수 있어야 한다. 작업을 하다 보면 한 번에 몰아서 코드 리뷰를 받는 경우가 대부분이지만 개발 생산성 측면과 코드 리뷰 시간을 줄이는 측면에서는 최대한 작은 단위로 리뷰를 요청해야 한다. 리뷰가 진행이 되지 못하여 다음 작업 또한 진행을 못하는 경우가 생기는 것을 방지하기 위해 최대한 코드 리뷰 받는 부분과 의존성이 없도록 작업이 돼야 하며 그도 아니라면 정중하게 리뷰어에게 &lsquo;부탁&rsquo;을 해야 한다.</div><div class=post-footer><a href=/2020/06/21/a-good-developer-in-terms-of-culture/>Read More</a><div class=post-tags><i class="fas fa-tags fa-fw"></i>&nbsp;<a href=/tags/curtule/>curtule</a>,&nbsp;<a href=/tags/a-good-developer/>a-good-developer</a>,&nbsp;<a href=/tags/archives-2020/>archives-2020</a></div></div></article><article class="single summary" itemscope itemtype=http://schema.org/Article><div class=featured-image-preview><a href=/2020/04/06/spring-boot-filter/><img class=lazyload src=/svg/loading.min.svg data-src=/images/spring-boot-filter/spring-request-lifecycle.jpg data-srcset="/images/spring-boot-filter/spring-request-lifecycle.jpg, /images/spring-boot-filter/spring-request-lifecycle.jpg 1.5x, /images/spring-boot-filter/spring-request-lifecycle.jpg 2x" data-sizes=auto alt=/images/spring-boot-filter/spring-request-lifecycle.jpg title=/images/spring-boot-filter/spring-request-lifecycle.jpg></a></div><h1 class=single-title itemprop="name headline"><a href=/2020/04/06/spring-boot-filter/>스프링 부트에 필터를 '조심해서' 사용하는 두 가지 방법</a></h1><div class=post-meta><span class=post-author><a href=https://taetaetae.github.io/resume title=Author target=_blank rel="noopener noreffer author" class=author><i class="fas fa-user-circle fa-fw"></i>태태태</a></span>&nbsp;<span class=post-publish>published on <time datetime=2020-04-06>2020-04-06</time></span>&nbsp;<span class=post-category>included in <a href=/categories/tech/><i class="far fa-folder fa-fw"></i>Tech</a></span></div><div class=content>웹 어플리케이션에서 필터를 사용하면 중복으로 처리되는 내용을 한곳에서 처리할 수 있다거나 서비스의 다양한 니즈를 충족시키기에 안성맞춤인 장치인것 같다. 필터란 무엇인가 에 대한 내용은 워낙에 다른 블로그나 공식 도큐먼트에서 자세하게 그리고 다양하게 설명하고 있기에 기본 개념에 대해서는 설명하지 않도록 하려 한다. 이번 포스팅에서는 스프링 부트를 사용하면서 어노테이션이라는 간편함에 취해(?) &ldquo;돌격 앞으로, 닥공&rdquo; 의 자세로 개발을 하려했던 필자를 보고 &ldquo;반성"의 자세로 필터를 등록하는 방법에 대해 명확하게 정리를 하고자 한다. 마지막으로는 아주 간단하면서도 엄청나게 위험한 필터 설정 사례에 대해서도 짚고 넘어가보자. 그냥 넘어가면 아쉬우니, 한번이라도 &lsquo;spring&rsquo; 이라는 framework 를 접해본 사람이라면 봤을법한 그림을 첨부하는것으로 필터란 무엇인가 에 대한 설명을 대신하는게 좋겠다.
출처 : https://justforchangesake.wordpress.com/2014/05/07/spring-mvc-request-life-cycle/" 출처 : https://justforchangesake.wordpress.com/2014/05/07/spring-mvc-request-life-cycle/ 방법을 설명하기 전에 동일하게 사용될 필터와 컨트롤러 코드를 보면 다음과 같다.
필터 @Slf4j public class MyFilter implements Filter { @Override public void init(FilterConfig filterConfig) throws ServletException { log.info("init MyFilter"); } @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { log.info("doFilter MyFilter, uri : {}", ((HttpServletRequest)servletRequest).getRequestURI()); filterChain.doFilter(servletRequest, servletResponse); } @Override public void destroy() { log.info("destroy MyFilter"); } } 테스트 할 컨트롤러 @Slf4j @RestController public class SampleController { @GetMapping("/test") public String test() { return "test"; } @GetMapping("/filtered/test") public String filteredTest() { return "filtered"; } } 방법 1 : FilterRegistrationBean 아주 간단하게, 일반 url 하나와 필터에 적용할 url 두개를 만들고 설정하려 한다. FilterRegistrationBean 을 이용해서 위에서 만들었던 필터를 아래처럼 등록해보자.
@SpringBootApplication public class Method1Application { public static void main(String[] args) { SpringApplication.run(Method1Application.class, args); } @Bean public FilterRegistrationBean setFilterRegistration() { FilterRegistrationBean filterRegistrationBean = new FilterRegistrationBean(new MyFilter()); // filterRegistrationBean.setUrlPatterns(Collections.singletonList("/filtered/*")); // list 를 받는 메소드 filterRegistrationBean.addUrlPatterns("/filtered/*"); // string 여러개를 가변인자로 받는 메소드 return filterRegistrationBean; } } 위 주석에도 적었지만 filterRegistrationBean 의 &ldquo;setUrlPatterns&rdquo; 와 &ldquo;addUrlPatterns&rdquo; 의 차이는 별거 없다. list 자체를 받을건지 아니면 가변인자로 계속 추가 할것인지. 이렇게 되면 &ldquo;/filtered/&ldquo;으로 &ldquo;시작"하는 패턴의 url의 요청이 오게 되면 등록한 필터를 통과하게 된다.
실행 : 필터 생성 /\\ / ___'_ __ _ _(_)_ __ __ _ \ \ \ \ ( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \ \\/ ___)| |_)| | | | | || (_| | ) ) ) ) ' |____| .__|_| |_|_| |_\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v2.2.6.RELEASE) 2020-04-06 23:45:01.225 INFO 14672 --- [ main] c.t.s.method1.Method1Application : No active profile set, falling back to default profiles: default 2020-04-06 23:45:02.153 INFO 14672 --- [ main] o.s.b.w.embedded.tomcat.TomcatWebServer : Tomcat initialized with port(s): 8080 (http) 2020-04-06 23:45:02.168 INFO 14672 --- [ main] o.apache.catalina.core.StandardService : Starting service [Tomcat] 2020-04-06 23:45:02.168 INFO 14672 --- [ main] org.apache.catalina.core.StandardEngine : Starting Servlet engine: [Apache Tomcat/9.0.33] 2020-04-06 23:45:02.361 INFO 14672 --- [ main] o.a.c.c.C.[Tomcat].[localhost].[/] : Initializing Spring embedded WebApplicationContext 2020-04-06 23:45:02.362 DEBUG 14672 --- [ main] o.s.web.context.ContextLoader : Published root WebApplicationContext as ServletContext attribute with name [org.springframework.web.context.WebApplicationContext.ROOT] 2020-04-06 23:45:02.362 INFO 14672 --- [ main] o.s.web.context.ContextLoader : Root WebApplicationContext: initialization completed in 1082 ms 2020-04-06 23:45:02.391 DEBUG 14672 --- [ main] o.s.b.w.s.ServletContextInitializerBeans : Mapping filters: filterRegistrationBean urls=[/filtered/*] order=2147483647, characterEncodingFilter urls=[/*] order=-2147483648, formContentFilter urls=[/*] order=-9900, requestContextFilter urls=[/*] order=-105 2020-04-06 23:45:02.391 DEBUG 14672 --- [ main] o.</div><div class=post-footer><a href=/2020/04/06/spring-boot-filter/>Read More</a><div class=post-tags><i class="fas fa-tags fa-fw"></i>&nbsp;<a href=/tags/spring-boot/>spring boot</a>,&nbsp;<a href=/tags/filter/>Filter</a>,&nbsp;<a href=/tags/archives-2020/>archives-2020</a></div></div></article><article class="single summary" itemscope itemtype=http://schema.org/Article><div class=featured-image-preview><a href=/2020/03/29/better-rest-template-2-netflix-hystrix/><img class=lazyload src=/svg/loading.min.svg data-src=/images/better-rest-template-2-netflix-hystrix/netflix_hystrix.jpg data-srcset="/images/better-rest-template-2-netflix-hystrix/netflix_hystrix.jpg, /images/better-rest-template-2-netflix-hystrix/netflix_hystrix.jpg 1.5x, /images/better-rest-template-2-netflix-hystrix/netflix_hystrix.jpg 2x" data-sizes=auto alt=/images/better-rest-template-2-netflix-hystrix/netflix_hystrix.jpg title=/images/better-rest-template-2-netflix-hystrix/netflix_hystrix.jpg></a></div><h1 class=single-title itemprop="name headline"><a href=/2020/03/29/better-rest-template-2-netflix-hystrix/>조금 더 괜찮은 Rest Template 2부 - Circuit-breaker</a></h1><div class=post-meta><span class=post-author><a href=https://taetaetae.github.io/resume title=Author target=_blank rel="noopener noreffer author" class=author><i class="fas fa-user-circle fa-fw"></i>태태태</a></span>&nbsp;<span class=post-publish>published on <time datetime=2020-03-29>2020-03-29</time></span>&nbsp;<span class=post-category>included in <a href=/categories/tech/><i class="far fa-folder fa-fw"></i>Tech</a></span></div><div class=content>지난 포스팅에서는 Retryable 를 활용해서 간헐적인 네트워크 오류를 &ldquo;재시도"를 함으로써 아주 간단하면서도 강력하게 해결할 수 있는 방법에 대해 알아보았다. 실제로 필자가 운영하는 서비스 에서도 Retryable 를 이용하기 전과 후를 비교해보면 간헐적인 네트워크 오류의 빈도수가 확실히 줄어든것을 확인할 수 있었다. 이렇게 &ldquo;재시도"를 해서 요청했을때 성공 응답을 받을 경우엔 문제가 안되지만 네트워크 오류가 아닌 실제로 호출을 받는 해당 서버에서 문제가 발생했다면 어떨까? 예컨대, 해당 서버에서 DB를 조회하는 API를 호출한다고 가정했을때 DB 자체에서 어떠한 오류가 난다면. 이런 경우는 단순히 &ldquo;재시도"로 해결할 수 없는 문제다.
물론 Retryable 의 Recover 어노테이션을 활용했기 때문에 클라이언트 즉, 사용자에게는 오류응답이 발생을 안했겠지만 호출 받는 서버 자체에서의 에러가 발생하는데 이런식의 재시도를 계속 시도한다면 호출 받는 서버 입장에서는 이 &ldquo;재시도&rdquo; request 또한 &ldquo;부하&rdquo; 로 받게 되고 결국 2차, 3차 장애가 이어질 수 밖에 없다.
기존 한덩어리로 관리되던 Monolithic Architecture 에서는 자체적으로 관리하기 때문에 이러한 에러 컨트롤 또한 자체적으로 관리를 할 수 있지만, 모듈이 모듈을 호출하게 되는 Microservice Architecture 로 바뀌다보니 이런 &ldquo;연쇄 장애(?)&rdquo; 같은 현상이 발생하게 되는 경우가 있다. 호출을 받는 서버의 상태가 이상하면 (에러응답이 지정한 임계치를 벗어나는 수준으로 맞춰서 발생한다면) 적절하게 호출을 하지 않고 (2차 장애를 내지 않도록 호출 자체를 하지 않고) 어느정도 기다리다 클라이언트에게는 에러응답이 아닌 미리 정해둔 응답을 내려주고, 에러가 복구되면 다시 호출하도록 하는 &ldquo;무언가&rdquo; 가 필요하지 않을까?
연쇄 장애. 제발 멈춰&mldr; 출처 : http://dpg.danawa.com/mobile/community/view?boardSeq=175&listSeq=4066389" 연쇄 장애. 제발 멈춰&mldr; 출처 : http://dpg.danawa.com/mobile/community/view?boardSeq=175&listSeq=4066389 지난 포스팅에 이어 이번 포스팅 에서는 그 &ldquo;무언가&rdquo;. 즉, Circuit-breaker 에 대해 알아보고 직접 구현 및 테스트 하면서 돌아가는 원리에 대해 이해 해보고자 한다. 막상 개념은 머릿속에 있지만 직접 구현해보지 않으면 내것이 아니기에, 직접 구현하고 설정값들을 바꿔가면서 언젠가 필요한 순간에 꺼내서 사용할 수 있는 나만의 &ldquo;무기&rdquo; 를 만들어 보고자 한다.
Circuit breaker ? (한국 발음으로) 서킷브레이커를 검색해보면 주식시장 관련된 내용이 꽤 나온다. (앗, 잠깐 눈물좀&mldr;) 서킷 브레이커. 이 용어는 다양한 곳에서 사용되는데 &ldquo;회로 차단기&rdquo; 라고도 검색이 된다. 해당 내용을 발췌해보면 다음과 같다.
회로 차단기는 전기 회로에서 과부하가 걸리거나 단락으로 인한 피해를 막기 위해 자동으로 회로를 정지시키는 장치이다. 과부하 차단기와 누전 차단기로 나뉜다. 퓨즈와 다른 점은, 차단기는 어느 정도 시간이 지난 뒤, 원래의 기능이 동작하도록 복귀된다.
여기서 가장 중요한 문장은 &ldquo;피해를 막기 위해 자동으로 회로를 정지시키는&rdquo;, &ldquo;어느정도 시간이 지난뒤 원래의 기능이 동작하도록 복귀된다&rdquo; 이 부분이 가장 중요한 것 같다. 시스템 구성이 점점 Microservice Architecture 로 바뀌어 가는 시점에서 이러한 &ldquo;서킷브레이커"는 자동으로 모듈간의 호출 에러를 감지하고 위에서 말한 &ldquo;연쇄 장애"를 사전에 막을 수 있는 아주 중요한 기능이라 생각된다.
&ldquo;circuit breaker spring&rdquo; 이라는 키워드로 검색해보면 이러한 고민을 이미 Netflix 라는 회사에서 Hystrix 라는 이름으로 개발이 된것을 알 수 있다. 이 core 모듈을 Spring 에서 한번 더 감싸서 Spring Boot 에서 사용하기 좋게 spring-cloud-starter-netflix-hystrix 라는 이름으로 만들어 둔 것이 있는데 이것을 활용해 보기로 하자.
구현 늘 그랬듯이 SpringBoot 프로젝트를 만들고 테스트할 Controller 를 만들어 주자. 원래대로라면 호출을 하는 모듈과 호출을 받는 모듈, 2개의 모듈을 만들어서 테스트 해야 하지만 편의를 위해 하나의 모듈에서 두개의 Controller 을 만들고 테스트 해보는 것으로 하자.
@RestController public class MainController { private final MainService mainService; @GetMapping("index") public String index(String key){ return mainService.getResult(key); } public MainController(MainService mainService) { this.mainService = mainService; } } @Slf4j @Service public class MainService { private RestTemplate restTemplate; public String getResult(String key) { return restTemplate.</div><div class=post-footer><a href=/2020/03/29/better-rest-template-2-netflix-hystrix/>Read More</a><div class=post-tags><i class="fas fa-tags fa-fw"></i>&nbsp;<a href=/tags/spring-boot/>spring boot</a>,&nbsp;<a href=/tags/circuit-breaker/>circuit breaker</a>,&nbsp;<a href=/tags/netflix/>Netflix</a>,&nbsp;<a href=/tags/hystrix/>Hystrix</a>,&nbsp;<a href=/tags/archives-2020/>archives-2020</a></div></div></article><article class="single summary" itemscope itemtype=http://schema.org/Article><div class=featured-image-preview><a href=/2020/03/26/7-years-of-development-1st-day-of-manager/><img class=lazyload src=/svg/loading.min.svg data-src=/images/7-years-of-development-1st-day-of-manager/boss_leader.jpg data-srcset="/images/7-years-of-development-1st-day-of-manager/boss_leader.jpg, /images/7-years-of-development-1st-day-of-manager/boss_leader.jpg 1.5x, /images/7-years-of-development-1st-day-of-manager/boss_leader.jpg 2x" data-sizes=auto alt=/images/7-years-of-development-1st-day-of-manager/boss_leader.jpg title=/images/7-years-of-development-1st-day-of-manager/boss_leader.jpg></a></div><h1 class=single-title itemprop="name headline"><a href=/2020/03/26/7-years-of-development-1st-day-of-manager/>매니저는 정말 개발자의 무덤일까? (리뷰 - 개발자 7년차, 매니저 1일차)</a></h1><div class=post-meta><span class=post-author><a href=https://taetaetae.github.io/resume title=Author target=_blank rel="noopener noreffer author" class=author><i class="fas fa-user-circle fa-fw"></i>태태태</a></span>&nbsp;<span class=post-publish>published on <time datetime=2020-03-26>2020-03-26</time></span>&nbsp;<span class=post-category>included in <a href=/categories/review/><i class="far fa-folder fa-fw"></i>review</a></span></div><div class=content>개발자로서의 커리어는 정말 다양하지만 필자가 보고 들은 경험을 아주 일반화 시켜 정리해 보자면 다음과 같다.
처음엔 전공/비전공을 불문하고 신입으로 개발을 시작하여 다양한 개발 경험을 하게 된다. 사수에게 혼나기도 해보고 또는 혼내줄 사수가 없어 혼자 끙끙 밤도 새보고, 다크서클과 거북목을 겸비한 이른바 &ldquo;삽질"을 하며 고통의 시절을 보내고 나면 어느덧 승진(진급)을 하며 일정 규모의 &ldquo;팀장(혹은 관리자)&ldquo;이 된다. 그게 자의든 타의든. 개발자는 다소 &ldquo;기술"이라는 특수성을 가지고 있지만 어느 직군이든 간에 이러한 커리어 패스의 흐름은 매우 비슷하게 흘러가는 것 같다. 적어도 필자가 보고 들은 것만 보면 말이다. (예외 케이스는 항상 있지만&mldr;)
하루는 팀장님과의 면담 중에 &ldquo;이제는 마냥 눈앞에 있는 개발만 할 것이 아니다. 기술을 좀 더 깊게 들여다보는 자리와 사람을 관리하며 주어진 과제를 진행하는 자리, 둘 중 선택해야 하는 시기가 온 것 같다. 더 높고 더 멀리, 그리고 더 넓게 볼 줄 알아야 한다.&ldquo;라는 말씀을 듣게 된다. 어느덧 &ldquo;그 시점"이 다가온 것이다. 개인적으로 필자는 팀장님이 말씀하신 두 가지 중 전자에 좀 더 가깝게 다가가고 싶다. 그만큼 오래오래 &ldquo;실무 개발"을 하고 싶고, 또 그만큼 개발이 재밌기 때문이다. 아직도 눈앞의 문제를 해결하기 위해 개발하며 시간 가는 줄 모를 만큼 밤을 새우는 게 재미있는 걸 보면&mldr;
요리하는 걸 좋아하지만 이상하게 치킨집은 하고 싶지 않다. 출처 : https://catapult.tistory.com/entry/%EC%B9%98%ED%82%A8%EC%A7%91%EC%9D%B4%EB%82%98-%EC%B0%A8%EB%A0%A4%EC%95%BC%EC%A7%80" 요리하는 걸 좋아하지만 이상하게 치킨집은 하고 싶지 않다. 출처 : https://catapult.tistory.com/entry/%EC%B9%98%ED%82%A8%EC%A7%91%EC%9D%B4%EB%82%98-%EC%B0%A8%EB%A0%A4%EC%95%BC%EC%A7%80 어느 날 SNS 피드에 개발 관련된 소식들을 받아보다가 개발 7년차. 매니저 1일차라는 제목의 책을 보게 된다. 뭐야, 이거 내 이야기 아니야? 하며 귀신에 홀린 듯 사서 읽어보려는 찰나, 마침 한빛미디어 에서 주최하는 나는 리뷰어다 라는 이벤트를 발견하게 된다. 결국 리뷰어에 당첨이 되고 운 좋게 해당 책을 받아볼 수 있었다. (이 책을 읽게 해준 한빛미디어 측에게 이 글로나마 감사의 인사를 전하고 싶다.)
필자의 SNS를 장식했던 &lsquo;개발 7년차, 매니저 1일차&rsquo;" 필자의 SNS를 장식했던 &lsquo;개발 7년차, 매니저 1일차&rsquo; 이번 포스팅에서는 우선 책에 대한 리뷰를 간단히 적어보고 거기에 필자의 생각을 조금 더 얹어보고 싶다. 필자를 두고 만들어진 책 같아서 아직도 책 표지만 봐도 신기하고 설렌다. 일단 책 표지나 제목이 맘에 든 건 감출 수 없는 사실이다.
신입 혹은 주니어 개발자가 읽어봐도 좋을 책. 제목만 보면 이제 갓 팀장 혹은 매니저를 하게 되는 사람에게만 해당되는 책으로 보인다. 표지 상단에 &ldquo;개발만 해왔던 내가, 어느 날 갑자기 &lsquo;팀&rsquo;을 맡았다!&rdquo; 적혀있기도 했으니까. 하지만 책을 읽다 보면 꼭 그렇지마는 않다. 멘토링을 할 때엔 멘토와 멘티 각자의 위치에서 어떤 자세로 서로를 맞이해야 하는 방법에 대해서도 알려주기도 하고 무작정 눈앞에 있는 기능 개발만을 하며 안갯속을 걷는 주니어 개발자가 미리 미래를 경험해보는 좋은 사례를 들어 알려주고 있기 때문이다.
꼭 누군가 혹은 무언가를 &ldquo;관리"하는 입장이 아닌 &ldquo;팀"이라는 공동체 사회, 특히 개발 팀에서 팀원들과 협력하는 방법론을 살펴보고 있고, 경력이 낮으면 안 보이는 부분들까지 마치 멀리 있는 것을 대신 망원경으로 보여주는 느낌이 들었다. 앞부분에는 &ldquo;이 책을 읽는 방법"이라며 상황별로 읽는 챕터를 가이드 해주고 있지만 사실 어느 하나 중요하지 않을 내용이 없어서 처음부터 무언가에 홀린 듯 읽을 수밖에 없었고 선배님이 앞서 지나간 길을 올바르게 지나갈 수 있도록 가이드 해주는 느낌으로 중간중간 사례가 있어서 현업에 있어서 그런지 좀 더 쉽게 읽힐 수 있었다.
다 읽고서야 알아차린 번역서(?)라는 사실. 어떠한 XX 기술 서적에서는 Method를 &lsquo;방법&rsquo;, Overriding 을 &lsquo;과적&rsquo;이라고 번역한 책들이 있는가 반면, 이 책은 읽는 내내 국내 어떤 분이 쓰신 거라 생각하고 읽어내려 갔지만 다 읽고 보니 외국에 어느 CTO가 쓴 책을 옮겨서 다시 써진 책이었다.</div><div class=post-footer><a href=/2020/03/26/7-years-of-development-1st-day-of-manager/>Read More</a><div class=post-tags><i class="fas fa-tags fa-fw"></i>&nbsp;<a href=/tags/book/>book</a>,&nbsp;<a href=/tags/archives-2020/>archives-2020</a></div></div></article><ul class=pagination><li class=page-item><span class=page-link><a href=/>1</a></span></li><li class="page-item active"><span class=page-link><a href=/page/2/>2</a></span></li><li class=page-item><span class=page-link><a href=/page/3/>3</a></span></li><li class=page-item><span class=page-link><a href=/page/4/>4</a></span></li><li class=page-item><span class=page-link aria-hidden=true>&mldr;</span></li><li class=page-item><span class=page-link><a href=/page/10/>10</a></span></li></ul></div></div></main><footer class=footer><div class=footer-container><div class=footer-line>Powered by <a href=https://gohugo.io/ target=_blank rel="noopener noreffer" title="Hugo 0.74.3">Hugo</a> | Theme - <a href=https://github.com/dillonzq/LoveIt target=_blank rel="noopener noreffer" title="LoveIt 0.2.10"><i class="far fa-kiss-wink-heart fa-fw"></i>LoveIt</a></div><div class=footer-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2016 - 2021</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=https://taetaetae.github.io/resume target=_blank>태태태</a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title="Back to Top"><i class="fas fa-arrow-up fa-fw"></i></a><a href=# id=view-comments class=fixed-button title="View Comments"><i class="fas fa-comment fa-fw"></i></a></div><link rel=stylesheet href=/lib/lightgallery/lightgallery.min.css><script type=text/javascript src=/lib/smooth-scroll/smooth-scroll.min.js></script><script type=text/javascript src=/lib/lazysizes/lazysizes.min.js></script><script type=text/javascript src=/lib/lightgallery/lightgallery.min.js></script><script type=text/javascript src=/lib/lightgallery/lg-thumbnail.min.js></script><script type=text/javascript src=/lib/lightgallery/lg-zoom.min.js></script><script type=text/javascript src=/lib/clipboard/clipboard.min.js></script><script type=text/javascript src=/lib/sharer/sharer.min.js></script><script type=text/javascript src=/lib/typeit/typeit.min.js></script><script type=text/javascript>window.config={"code":{"copyTitle":"Copy to clipboard","maxShownLines":500},"data":{"id-1":"Programmer rather than coder."},"lightGallery":{"actualSize":false,"exThumbImage":"data-thumbnail","hideBarsDelay":2000,"selector":".lightgallery","speed":400,"thumbContHeight":80,"thumbWidth":80,"thumbnail":true},"typeit":{"cursorChar":"|","cursorSpeed":500,"data":{"id-1":["id-1"]},"duration":-1,"speed":100}};</script><script type=text/javascript src=/js/theme.min.js></script><script type=text/javascript>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}gtag('js',new Date());gtag('config','UA-86432198-1',{'anonymize_ip':true});</script><script type=text/javascript src="https://www.googletagmanager.com/gtag/js?id=UA-86432198-1" async></script></body></html>