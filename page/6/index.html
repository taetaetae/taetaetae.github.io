<!doctype html><html lang=en><head><meta name=generator content="Hugo 0.74.3"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><meta http-equiv=x-ua-compatible content="IE=edge, chrome=1"><title>👨‍💻꿈꾸는 태태태의 공간</title><meta name=Description content><meta property="og:title" content="👨‍💻꿈꾸는 태태태의 공간"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="https://taetaetae.github.io/"><meta property="og:updated_time" content="2021-10-24T16:07:11+09:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="👨‍💻꿈꾸는 태태태의 공간"><meta name=twitter:description content><meta name=application-name content="👨‍💻꿈꾸는 태태태의 공간"><meta name=apple-mobile-web-app-title content="👨‍💻꿈꾸는 태태태의 공간"><meta name=naver-site-verification content="2d1cdbb963ba178aa7cbf58500afc668cae1e645"><meta name=google-site-verification content="vvFCdv0-GuQhEWG8vtNJfA7YSY2HYQ1hpHh9P-a6Pv8"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://taetaetae.github.io/><link rel=alternate href=/index.xml type=application/rss+xml title="👨‍💻꿈꾸는 태태태의 공간"><link rel=feed href=/index.xml type=application/rss+xml title="👨‍💻꿈꾸는 태태태의 공간"><link rel=stylesheet href=/lib/normalize/normalize.min.css><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=/lib/fontawesome-free/all.min.css><link rel=stylesheet href=/lib/animate/animate.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"WebSite","url":"https:\/\/taetaetae.github.io\/","inLanguage":"en","author":{"@type":"Person","name":"태태태"},"name":"👨‍💻꿈꾸는 태태태의 공간"}</script></head><body header-desktop=auto header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem('theme')?localStorage.getItem('theme')==='dark':('auto'==='auto'?window.matchMedia('(prefers-color-scheme: dark)').matches:'auto'==='dark'))&&document.body.setAttribute('theme','dark');</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title="👨‍💻꿈꾸는 태태태의 공간">👨‍💻꿈꾸는 태태태의 공간</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/>Posts </a><a class=menu-item href=/tags/>Tags </a><a class=menu-item href=/categories/>Categories </a><span class="menu-item delimiter"></span><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme"><i class="fas fa-adjust fa-fw"></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title="👨‍💻꿈꾸는 태태태의 공간">👨‍💻꿈꾸는 태태태의 공간</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><a class=menu-item href=/posts/>Posts</a><a class=menu-item href=/tags/>Tags</a><a class=menu-item href=/categories/>Categories</a><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme">
<i class="fas fa-adjust fa-fw"></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class="page home" posts><div class=home-profile><div class=home-avatar><a href=https://taetaetae.github.io/resume title=resume target=_blank><img class=lazyload src=/svg/loading.min.svg data-src=/images/profile.png data-srcset="/images/profile.png, /images/profile.png 1.5x, /images/profile.png 2x" data-sizes=auto alt=/images/profile.png title=/images/profile.png></a></div><h2 class=home-subtitle><div id=id-1 class=typeit></div></h2><div class=links><a href=https://github.com/taetaetae title=GitHub target=_blank rel="noopener noreffer me"><i class="fab fa-github-alt fa-fw"></i></a><a href=https://linkedin.com/in/taetaetae title=LinkedIn target=_blank rel="noopener noreffer me"><i class="fab fa-linkedin fa-fw"></i></a><a href=https://www.instagram.com/_taetaetae title=Instagram target=_blank rel="noopener noreffer me"><i class="fab fa-instagram fa-fw"></i></a><a href=https://facebook.com/taetaetae0 title=facebook target=_blank rel="noopener noreffer me"><i class="fab fa-facebook fa-fw"></i></a><a href=mailto:taetaetae_@naver.com title=Email rel=me><i class="far fa-envelope fa-fw"></i></a><a href=/index.xml title=RSS target=_blank rel="noopener noreffer me"><i class="fas fa-rss fa-fw"></i></a></div></div><article class="single summary" itemscope itemtype=http://schema.org/Article><div class=featured-image-preview><a href=/2018/10/14/deview-2018/><img class=lazyload src=/svg/loading.min.svg data-src=/images/deview-2018/deview.png data-srcset="/images/deview-2018/deview.png, /images/deview-2018/deview.png 1.5x, /images/deview-2018/deview.png 2x" data-sizes=auto alt=/images/deview-2018/deview.png title=/images/deview-2018/deview.png></a></div><h1 class=single-title itemprop="name headline"><a href=/2018/10/14/deview-2018/>Deview 2018 리뷰 (Day 1, Day2)</a></h1><div class=post-meta><span class=post-author><a href=https://taetaetae.github.io/resume title=Author target=_blank rel="noopener noreffer author" class=author><i class="fas fa-user-circle fa-fw"></i>태태태</a></span>&nbsp;<span class=post-publish>published on <time datetime=2018-10-14>2018-10-14</time></span>&nbsp;<span class=post-category>included in <a href=/categories/review/><i class="far fa-folder fa-fw"></i>review</a></span></div><div class=content>회사 내에서도 대학시절 수강신청마냥 1분도 안되서 마감될 정도로 관심이 많았던 DEVIEW 2018. 다행히 클릭신공으로 운좋게 신청에 성공하였고 팀에서도 바쁜 시기였지만 감사하게도 보내주셔서 올해는 이틀 모두 다녀올수 있게 되었다.예전에는 연차가 올라가면 DEVIEW행사는 참여 안하겠지~라는 생각이 있었는데 그때는 단순 호기심에 참석을 하고 싶었다면 이번에는 뭐라도 배워오자라는 마음으로 신입 시절보다 조금더 성숙한 마음가짐과 자세를 가지고 참석을 하게 되었다.
다시 생각해보면 호기심만으로 세션들을 듣고 부스에서 나눠주는 굿즈를 조금이라도 더 받아와야지 하고 생각했던 신입시절의 생각이 틀린건 아니였지만, 말 그대로 기술행사이니만큼 가급적이면 세션에서 발표하는 내용을 내것으로 만들고 실무에서 또는 다른곳에서 활용할수는 없을까 하는 생각을 갖는게 보다 성장하려는 개발자로서의 자세가 아닐까 생각이 든다. (라고 멋드러지게 말하지만 세션내용의 절반이라도 이해하면 다행이겠지&mldr;)
행사 시작 그리고 키노트 10초만에 마감되었다는 소리가 있을정도로 올해도 여전히 관심이 많았던 DEVIEW 2018. 코엑스에 도착하고 등록을 한뒤 이곳저곳 부스들을 구경하기 바빴다. 이번에는 지난번과 달리 거의 네이버 서비스가 60~70%를 자리잡고 있었고(파파고, 지도, 클로바, 글로벌 광고 등등) 일반 기업에서는 얼마 오지 않았다.(내 기억으로 5~6개?) 개인적으로 여러 다양한 회사들이 함께하는 기술행사가 되었으면 하는 바램이 있었지만 회사를 선정하는데, 그리고 기타 사정들이 있을꺼라는 아쉬움을 뒤로하고 CTO님이 발표하시는 키노트를 들으러 메인강의장에 들어갔다. (자칫&mldr; 이것도 네이버 독과점(?) 이러면 할말이 없는데&mldr;ㅠㅠ)
송창현 네이버 CTO님의 keynote" 송창현 네이버 CTO님의 keynote 작년에는 거의 로봇잔치로 느껴졌는데 올해는 그 기술들의 융합(?)잔치 로 받아들여졌다. Ambient Intelligence 를 강조하시며 기술의 진정한 가치는 기술이 생활속으로 사라졌을 때 나온다라는 명언같은 말씀도 해주셨다.
연결 : 사물, 상황, 위치인식, 이해 발견 : 적시에 답, 추천, 액션제공 그리고 그와 관련된 네이버 서비스를 공개 하셨는데, 네이버 지도 Map API를 무제한/무료로 사용할수 있게 된다고 한다. (박수 유도하심 ㅎㅎ) 또한 이번에 가장 크게 바뀌는 네이버 모바일 홈 페이지인 그린닷, 지도 기술들의 종합 플랫폼인 xDM Platform(측위, 지도, 내비), 그리고 자율주행과 로봇에 대해 연구결과 그리고 앞으로의 방향성에 대해 정리해주셨다. 집에 돌아와서 검색좀 하다보니 테크수다에서 벌써(?) 영상을 하나 올린게 있어 공유해본다.
키노트를 다 듣고 작년에는 그런가보다 하고 별생각이 안들었는데 올해는 저런 기술들이 서비스 레벨까지 가는데 이렇다할 허들없이 사용자들에게 보여질수만 있다면 개발자로서 보다 더 큰 자부심을 가지고 기술개발에 정진할텐데&mldr; 하는 씁슬한 생각을 해보게 되었다. (물론 이런 부분들도 다 사정이 있을꺼라 생각이 들지만 안타까운건 감출수가 없을것 같다.)
이틀에 걸쳐 이런저런 다양한 세션들을 들을수 있어 좋았는데 몇몇 세션들은 기본지식이 없어 (AI, 머신러닝 등&mldr;ㅠ) 이해하기 힘들었다. 내년엔 이해할수 있도록 준비를 해서 오자며 또다짐을 하고&mldr; 그나마 조금이라도 이해할수 있었던 세션들 몇개만 정리해본다.
React Native: 웹 개발자가 한 달 만에 앱 출시하기 React Native: 웹 개발자가 한 달 만에 앱 출시하기" React Native: 웹 개발자가 한 달 만에 앱 출시하기 지난팀에서 아주 잠깐 React를 경험해보긴 했지만 거의 hello world 수준이였기 때문에 이 세션 역시 이해가 잘 되지 못했다. 하지만 필자처럼 이해를 잘 못하는 사람도 발표자가 전달하려는 목적이 무엇인지 알수 있을 정도로 전체적인 흐름은 조금이나마 이해를 할수 있었고 특히 개발하면서 좋았던 것이나 경험담을 알려주며 삽질공유를 해주는게 듣기 좋았다. React Native 는 빠른개발을 할수있고 코드공유가 쉬우며 개선이 쉽다는 장점이 있다고 한다. 또한 단기간에 크로스 플랫폼을 만들어야 할때 사용한다고 하니 나중에 참고해봐도 좋을듯 싶다.
발표자료 : https://www.slideshare.net/deview/121react-native LINE x NAVER 개발 보안 취약점 이야기 LINE x NAVER 개발 보안 취약점 이야기" LINE x NAVER 개발 보안 취약점 이야기 버그바운티라는 신기한(?)프로그램에 대한 소개와 운영에 대한 내용을 발표해 주셨다. 가끔 사내에서도 버그를 잡으면 포상을 드려요 라는 글이 올라왔었는데 그때마다 손안데고 코풀려나 하는 비뚤어진(?</div><div class=post-footer><a href=/2018/10/14/deview-2018/>Read More</a><div class=post-tags><i class="fas fa-tags fa-fw"></i>&nbsp;<a href=/tags/deview/>deview</a>,&nbsp;<a href=/tags/archives-2018/>archives-2018</a></div></div></article><article class="single summary" itemscope itemtype=http://schema.org/Article><div class=featured-image-preview><a href=/2018/08/28/pycon-2018/><img class=lazyload src=/svg/loading.min.svg data-src=/images/pycon-2018/presentation.jpg data-srcset="/images/pycon-2018/presentation.jpg, /images/pycon-2018/presentation.jpg 1.5x, /images/pycon-2018/presentation.jpg 2x" data-sizes=auto alt=/images/pycon-2018/presentation.jpg title=/images/pycon-2018/presentation.jpg></a></div><h1 class=single-title itemprop="name headline"><a href=/2018/08/28/pycon-2018/>2018 Pycon. 그리고 첫 발표를 하다.</a></h1><div class=post-meta><span class=post-author><a href=https://taetaetae.github.io/resume title=Author target=_blank rel="noopener noreffer author" class=author><i class="fas fa-user-circle fa-fw"></i>태태태</a></span>&nbsp;<span class=post-publish>published on <time datetime=2018-08-28>2018-08-28</time></span>&nbsp;<span class=post-category>included in <a href=/categories/tech/><i class="far fa-folder fa-fw"></i>Tech</a></span></div><div class=content>IT관련 행사에 참여하면 여러가지 정보를 얻을수 있다. 개인적으로는 사실 정보를 얻기 위함보다 그곳의 분위기를 현장에서 몸소 느끼고 참여한 사람들의 눈빛을 보며 해이해진 마음가짐을 다시 다잡을수 있음이 가장 큰 목적이다. 그에 올해 Pycon도 하나의 전환점이 되길 바라는 마음으로 신청을 하게 되었다.
등록 https://www.pycon.kr 얼리버드 등록을 한다고 Facebook에서 홍보를 하길래 그런가보다 했는데 잠깐 회사일에 집중하고 다시 보니 이미 매진이 되어있었다. 사실 Pycon 은 올해가 처음 가보는거라 인기를 실감할수 없었는데 이정도일줄은 상상도 못했다. (나중에 알게 된 사실이지만 올해가 가장 인원이 많았다고&mldr;) 그래서 나중에 진행되었던 일반표 등록은 휴대폰 알람까지 걸어두며 늦지않게 등록할수 있었다. 세부 일정들이 업데이트가 되고 어떤 세션을 들을까 고민하면서 간략 소개를 하나둘씩 보게 되었는데 Python을 만지며 평소에 궁금했던거나 재밌어 보이는 세션들이 너무많아 고민을 많이 했다. 한가지 아쉬운건 로그인 기반이 아니다 보니 (임시 로그인기반?) 내 시간표 설정하는게 없었다. 나는 별도로 적어서 갔지만 나중엔 그런 기능이 생겼으면 좋겠다.
2019년 Pycon엔 크롬 익스텐션으로 기능을 만들어 로그인 여부와 상관없이 몇시에 내가 어떤 세션을 들을건지에 대한 설정을 하고 이를 이미지로 캡쳐해서 출력/다운 받을수 있는 걸 만들어 보고 싶다. (그전에 미뤄뒀던 크롬 익스텐션 개발하는 방법부터 공부하자&mldr;)
첫째날 개인적으로 아침잠이 너무 많은데 알림이 울리기도 전에 눈이 떠졌고 행사장에 도착해보니 후원사 부스는 아직 텅텅 비어있었고, 밤새가면서 준비를 하셨는지 자원봉사자 분들은 여기저기 빈백에 누워(쓰러져) 자고 있었다. 그만큼 Pycon에 대한 기대가 컸나보다. 시간이 지나니 하나둘씩 사람들이 등록을 하며 오기 시작하였고 역시나 행사에 꽃중에 꽃인 후원사 부스에서 나눠주는 이벤트 상품들을 받기 바빴다.
DIVE INTO DIVERSITY !!" DIVE INTO DIVERSITY !! 키노트를 시작으로 사람들은 각자 듣고싶은 세션에 참가하며 행사는 시작이 되었다. 전체적으로 기술의 난이도는 초급 수준의 발표였던걸로 느껴졌다. (물론 나는 초초초급도 안되는 꼬꼬마 수준이지만&mldr;) 대부분 Python으로 어떤걸 해봤고, 어떤 어려움이 있었고, 이러저러한 상황들을 만났으며, 요런 경우에서는 어떻게 하며 해결을 하였다는 등 기술을 활용한 &ldquo;경험기"에 대한 내용들을 들을수 있었다. Pycon의 슬로건인 DIVE INTO DIVERSITY에 걸맞게 아주 다양한 주제로 흥미있는 발표내용들이였다. 기억나는 것들중에 인상깊었던 부분들을 정리해본다.
파이썬 문화(?)중의 하나는 몰라서 물어보는 사람에게 구글링을 하라기보다 직접 알려주라는 것이다. 배우고 싶다면 다른사람들을 가르치는것부터(알려주는것부터) 시작하라. 여성 개발자, 여성 발표자들도 점점 늘어나고 있다. 파이썬을 개발 현장(?)이 아닌 다른곳에서 사용한다면 작업 속도도 빠르고 얻어내는 가치또한 훨씬 더 방대하다. 엑셀로 할수 있는 작업을 파이썬으로 할수 있다. 파이썬의 다양한 라이브러리는 일상의 도움을 준다. 행사를 들으며 꼭 질문을 해야지 하는 마음을 갖고 있었는데 (그래야 오래 기억에 남으니) 마침 어떤 세션에서 궁금한게 있어 질문을 할수 있었다. (질문을 하니 파이썬 관련 책 선물도 받았다.^^) 그리고 마지막 라이트닝 톡이라는 세션이 있었는데 여러 발표자들이 짤막하게 5분동안 하고싶은 이야기를 하는 세션이였다. 5분이라는 제한이 있기에 다들 쉽고 편하게 발표하는듯 보였으나 발표 자료나 발표내용을 보면 꼭 그렇게 간단하게 발표하는건 아니였다. 본 세션에서 말하기엔 다소 분량이 작은 알차고 깨알같은 발표도 있었고, 매년 Pycon 라이트닝톡에 발표하는게 목표이신 분도 있었다. 발표를 들으면서 난 언제 저런자리에 가서 발표를 할수 있을까 하는 마음이 스쳐 지나갈때 쯤. &ldquo;왜못하지? 나 파이썬으로 만든거 있잖아?&rdquo; 라고 혼잣말로 궁시렁거리며 둘째날에 있는 라이트닝톡에서 발표하기로 마음을 먹고 서둘러서 참가 신청을 보냈다. 그러고서는 저녁을 먹고 집에 늦게 돌아와 새벽 3시넘어서야 발표자료를 완성하였지만 &ldquo;발표&rdquo; 라는 부담감때문에 어렵게 잠에 들었다.
둘째날 어제와는 달리 오늘은 잠을 많이 못자서 인지 늦게 일어나 첫 세션이 시작하고서 거의 끝날 즈음에 행사장에 도착하게 되었다. &ldquo;괜히 발표 한다고 한걸까&rdquo; 라는 생각이 들며 진행위 본부에 가서 발표 순서를 확인해보니 첫번째&mldr; 슬슬 머리가 아파오기 시작했다.</div><div class=post-footer><a href=/2018/08/28/pycon-2018/>Read More</a><div class=post-tags><i class="fas fa-tags fa-fw"></i>&nbsp;<a href=/tags/python/>python</a>,&nbsp;<a href=/tags/pycon/>pycon</a>,&nbsp;<a href=/tags/archives-2018/>archives-2018</a></div></div></article><article class="single summary" itemscope itemtype=http://schema.org/Article><div class=featured-image-preview><a href=/2018/08/21/how-to-use-cloneutils/><img class=lazyload src=/svg/loading.min.svg data-src=/images/how-to-use-cloneUtils/clone_java.jpg data-srcset="/images/how-to-use-cloneUtils/clone_java.jpg, /images/how-to-use-cloneUtils/clone_java.jpg 1.5x, /images/how-to-use-cloneUtils/clone_java.jpg 2x" data-sizes=auto alt=/images/how-to-use-cloneUtils/clone_java.jpg title=/images/how-to-use-cloneUtils/clone_java.jpg></a></div><h1 class=single-title itemprop="name headline"><a href=/2018/08/21/how-to-use-cloneutils/>자바 객체 복사하기 ( feat. how to use CloneUtils? )</a></h1><div class=post-meta><span class=post-author><a href=https://taetaetae.github.io/resume title=Author target=_blank rel="noopener noreffer author" class=author><i class="fas fa-user-circle fa-fw"></i>태태태</a></span>&nbsp;<span class=post-publish>published on <time datetime=2018-08-21>2018-08-21</time></span>&nbsp;<span class=post-category>included in <a href=/categories/tech/><i class="far fa-folder fa-fw"></i>Tech</a></span></div><div class=content>자바(Java)로 개발을 하다보면 한번쯤 객체를 복사하는 로직을 작성할때가 있다. 그때마다 나오는 이야기인 Shalldow Copy 와 Deep Copy. 한국어로 표현하면 얕은 복사와 깊은 복사라고 이야기를 하는데 이 두 개념의 차이는 아주 간단하다. 객체의 주소값을 복사하는지, 아니면 객체의 실제 값(value)를 복사하는지. 이 둘의 차이점을 소개하는 글들은 워낙 많으니 패스하도록 하고 이번 포스팅에서는 Deep Copy를 할때 org.apache.http.client.utils 하위에 있는 CloneUtils 사용법에 대해 정리 하고자 한다.
그냥 쓰면 되는거 아닌가? 라고 생각했지만 (별거 아니라고 생각했지만) 해보고 안해보고의 차이는 엄청컸고 사용할때 주의점이 몇가지 있어 정리 하려고 한다.
예제에 앞서 본 포스팅에서 사용할 객체를 간단히 정리하면 다음과 같다. (학교에서 학생 신상정보를 관리한다고 가정해보자.)
public class Student { String name; // 이름 int age; // 나이 Family family; // 가족 } public class Family { String name; // 이름 int age; // 나이 boolean isOfficeWorkers; // 직장인 여부 } public class PhysicalInformation { int height; // 키 int weight; // 몸무게 } 객체는 Cloneable interface 를 implement 해야하고 clone 메소드를 public 으로 override 해야한다. 당연한 이야기가 될수도 있으나 CloneUtils를 사용하기 위해서는 해당 객체는 Cloneable interface 를 implement 해야한다. 그리고 나서 clone 메소드를 override 해야되는데 여기서 가장 중요한점은 외부에서도 호출이 가능해야하기 때문에 public 으로 override를 해야한다. (기본은 protected 로 되어있다.) 우선 간단히 객체를 생성하고 출력부터 해보자. (출력을 이쁘게 하기 위해 ToStringBuilder.reflectionToString을 사용하였다.)
PhysicalInformation physicalInformation = new PhysicalInformation(); physicalInformation.height = 180; physicalInformation.weight = 70; System.out.println(ToStringBuilder.reflectionToString(physicalInformation, ToStringStyle.DEFAULT_STYLE)); 결과는 당연히
PhysicalInformation@5d6f64b1[height=180,weight=70] 이제 Cloneable interface 를 implement 하고 clone 메소드를 public 으로 override 한뒤, CloneUtils를 사용해서 객체를 복사해보자. 테스트를 하면서 Shalldow Copy도 해보자.
// class setting public class PhysicalInformation implements Cloneable{ int height; int weight; @Override public Object clone() throws CloneNotSupportedException { // public 으로 바꿔주자. return super.clone(); } } // test code PhysicalInformation physicalInformation = new PhysicalInformation(); physicalInformation.height = 180; physicalInformation.weight = 70; PhysicalInformation physicalInformationShalldowCopy = physicalInformation; PhysicalInformation physicalInformationDeepCopy = null; try { physicalInformationDeepCopy = (PhysicalInformation)CloneUtils.clone(physicalInformation); } catch (CloneNotSupportedException e) { e.printStackTrace(); } // 원본 System.out.println(ToStringBuilder.reflectionToString(physicalInformation, ToStringStyle.DEFAULT_STYLE)); // 얕은 복사 System.out.println(ToStringBuilder.reflectionToString(physicalInformationShalldowCopy, ToStringStyle.DEFAULT_STYLE)); // 깊은 복사 System.out.println(ToStringBuilder.reflectionToString(physicalInformationDeepCopy, ToStringStyle.DEFAULT_STYLE)); // 값 변경 physicalInformation.weight = 80; physicalInformation.height = 170; // 원본 System.out.println(ToStringBuilder.reflectionToString(physicalInformation, ToStringStyle.DEFAULT_STYLE)); // 얕은 복사 System.out.println(ToStringBuilder.reflectionToString(physicalInformationShalldowCopy, ToStringStyle.DEFAULT_STYLE)); // 깊은 복사 System.out.println(ToStringBuilder.reflectionToString(physicalInformationDeepCopy, ToStringStyle.DEFAULT_STYLE)); 결과는 원본과 얕은 복사를 한것은 메모리 주소(?)가 같으나 깊은 복사를 한것은 데이터는 같지만 주소가 다르고 값을 변경해도 영향을 주지 않는다. (완전히 서로다른 객체인것을 증명)
PhysicalInformation@1376c05c[height=180,weight=70] PhysicalInformation@1376c05c[height=180,weight=70] PhysicalInformation@1b4fb997[height=180,weight=70] PhysicalInformation@1376c05c[height=170,weight=80] PhysicalInformation@1376c05c[height=170,weight=80] PhysicalInformation@1b4fb997[height=180,weight=70] 만약 위에서 clone을 기본값인 protected로 override를 하게 되면 어떤 결과를 가져올까?
Exception in thread "main" java.lang.NoSuchMethodError: com.PhysicalInformation.clone() at org.apache.http.client.utils.CloneUtils.cloneObject(CloneUtils.java:55) at org.apache.http.client.utils.CloneUtils.clone(CloneUtils.java:77) at com.Test.main(Test.java:16) 접근제한자에서 눈치를 챌수도 있었겠지만 접근을 할수없어 CloneUtils 이 리플렉션을 하는 과정에서 Exception을 발생한다. 꼭! public 으로 override를 해주자.
객체 내에 clone이 안되는 변수는 별도 처리가 필요하다. 객체 내에 있는 멤버 변수는 원시 변수(int, char, float 등) , Immutable Class (String, Boolean, Integer 등) 또는 Enum 형식일 때는 원본의 값을 바로 대입해도 되지만, 그렇지 않을 때는 멤버변수의 clone을 호출하여 복사해야 한다. 말로만 보면 무슨이야기 인지 모르니 예제를 보자.
public class Student implements Cloneable { String name; int age; Family family; @Override public Object clone() throws CloneNotSupportedException { return super.clone(); } } Student 클래스에서 Cloneable 를 implements 하고 clone 메소드를 override 하였다. (여기서 구멍이 있다!</div><div class=post-footer><a href=/2018/08/21/how-to-use-cloneutils/>Read More</a><div class=post-tags><i class="fas fa-tags fa-fw"></i>&nbsp;<a href=/tags/cloneutils/>cloneUtils</a>,&nbsp;<a href=/tags/java-deep-copy/>java deep copy</a>,&nbsp;<a href=/tags/archives-2018/>archives-2018</a></div></div></article><article class="single summary" itemscope itemtype=http://schema.org/Article><div class=featured-image-preview><a href=/2018/08/09/daily-dev-blog-2/><img class=lazyload src=/svg/loading.min.svg data-src=/images/daily-dev-blog-2/ddb-thumnail.png data-srcset="/images/daily-dev-blog-2/ddb-thumnail.png, /images/daily-dev-blog-2/ddb-thumnail.png 1.5x, /images/daily-dev-blog-2/ddb-thumnail.png 2x" data-sizes=auto alt=/images/daily-dev-blog-2/ddb-thumnail.png title=/images/daily-dev-blog-2/ddb-thumnail.png></a></div><h1 class=single-title itemprop="name headline"><a href=/2018/08/09/daily-dev-blog-2/>기술블로그 구독서비스 개발 후기 - 2부</a></h1><div class=post-meta><span class=post-author><a href=https://taetaetae.github.io/resume title=Author target=_blank rel="noopener noreffer author" class=author><i class="fas fa-user-circle fa-fw"></i>태태태</a></span>&nbsp;<span class=post-publish>published on <time datetime=2018-08-09>2018-08-09</time></span>&nbsp;<span class=post-category>included in <a href=/categories/tech/><i class="far fa-folder fa-fw"></i>Tech</a></span></div><div class=content>1부에서는 기술블로그 구독서비스(이하 서비스)를 왜 만들게 되었고 어떤구조로 만들가에 대해 이야기를 해보았다면, 이번 포스팅에서는 만들면서 만나게 된 각종 트러블슈팅 종합세트(?)를 하나씩 풀어보고자 한다. 물론 개발을 하면서 아무 문제 없이 잘 되면 당연히 좋겠으나 잘되도 이상한게 개발이라는 세계가 아니던가.
잘 안되면 문제, 잘 되도 문제 ㅠㅠ 출처 : https://www.clien.net/service/board/park/9111495" 잘 안되면 문제, 잘 되도 문제 ㅠㅠ 출처 : https://www.clien.net/service/board/park/9111495 1부 : 왜 만들게 되었는가 그리고 어떤 구조로 만들었는가 2부 : 문제발생 및 Trouble Shooting 3부 : 앞으로의 계획과 방향성 지난 1부에서 이야기 했던것처럼 문제 - 해결, 문제 - 해결 식으로 나열해보고자 한다. 다소 글의 전개가 뒤죽박죽일수도 있겠지만 말 그대로 트러블슈팅 종합세트이니 독자들의 양해를 미리 구한다.
트러블 슈팅 리스트 10시에 로직이 실행되었지만 메일을 11시 넘어서 받게 된다. 제목없는 글? 블로그 RSS파싱 오류? 간헐적으로 오류가 생긴다. 메일 내에 class를 적용하여 CSS 처리가 불가능하다. 메일을 보냈으나 스팸으로 처리된다. Elastic Stack을 사용할수 없다. 메일 보내는 발송속도가 너무 느리다. 구독해제가 아닌 자체 수신거부는 어찌 처리할까? 10시에 로직이 실행되었지만 메일을 11시 넘어서 받게 된다. 👉 해결방안 : Divide and Conquer
본 서비스의 요구사항중 하나는 매일 오전 10시, 구독자들에게 어제 등록된 글을 수집하여 메일로 보내주는게 있다. 우선 로직은 다음과 같은 순서로 진행되게 개발하였고, jenkins 등 별도의 스케쥴러 관리 어플리케이션에 의해 할수도 있었으나 이 또한 심플하게 crontab 에 등록하여 매일 오전 10시에 실행되도록 하였다.
1. awesome-devblog 에서 블로거들의 RSS 피드를 조회한다. 2. 어제 등록된 글이 있다면 리스트에 담는다. 3. 조회가 끝나면 메일형식에 맞추어 html 문자열을 만든다. 4. 만들어진 문자열을 가지고 등록된 구독자들에게 메일을 보낸다. 로직은 아주 간단했다. 데이터를 파싱하는 방법이나 메일형식에 맞추어 html문자열을 만드는 등 별도의 라이브러리를 사용하는 다소 복잡한 부분만 빼면 단순히 for문과 if문을 조합해서 로직을 구성할수 있었다. 헌데, 10시에 해당로직이 실행되었지만 최대 1시간이 지나고서야 메일을 받는 경우도 있었다. 이게 무슨일일까!? 눈치를 챘을수도 있지만 RSS 피드를 조회하는 곳에서 오래걸린 것이다. 티스토리나 네이버등 다른 블로그들은 RSS를 읽고 파싱하는 속도가 그렇게 오래 걸리지 않았는데 (1초 이내) 유독 이글루스 블로그의 RSS파싱이 오래걸리는건 1분까지도 걸리던 것이였다. ( 참고로 RSS 파싱모듈, yaml 파싱모듈 을 사용했다. ) 아마 RSS의 형식이 약간 달라서 그런것 같긴 한데 그렇다고 이글루스 일 경우에 파싱을 다르게 하는건 좀 그렇고&mldr; 추후 이글루스가 아닌 또다른 파싱속도가 느린 블로그의 RSS를 만날수도 있기에 RSS 타입별로 예외처리를 하는건 좀 아닌것 같았다. 이런저런 고민끝에 아주 간단하게도 임무(?)를 나누는식으로 해결 하였다. 즉, RSS를 읽고 메일에 보낼 데이터를 만드는 job 하나와 만들어진 데이터를 가지고 이메일을 보내는 job 으로 나눈뒤 RSS를 분석하는 job은 9시에, 메일보내는 job은 10시에 보내도록 해서 생각보다 아주 심플하게 문제를 해결할수 있었다. 복잡하고 어려운 문제를 꼭 복잡하고 어렵게만 해결해야하는 법은 없는것 같다. 모로 가도 서울만 가면 된다라는 속담이 있지 않는가.
제목없는 글? 블로그 RSS파싱 오류? 간헐적으로 오류가 생긴다. 👉 해결방안 : 언제나 신경써야 하는 예외처리(try-catch)
내가 만든 코드는 언제나 내 생각대로만 돌아갔으면 하는건 모든 개발자의 마음과 같다.
흔한 IT 종사자들.deploy 출처 : https://9gag.com/gag/a0Yxw4B/operations-team-before-leaving-for-holidays" 흔한 IT 종사자들.deploy 출처 : https://9gag.com/gag/a0Yxw4B/operations-team-before-leaving-for-holidays 하지만 그생각도 잠시 언제나 예외는 발생하기 마련. ( 물론 전혀 예외가 발생 안할수도 있으나 만약 발생하지 않았다 할지라도 발생할수 있는 가능성은 염두해둬야 한다. ) 파싱하는 과정에서 제목이 없는글로 온다거나, 가끔 RSS url 응답이 404 또는 503 인 경우가 있었다.
참고로 필자는 출근이 늦은편이라 아침마다 늦잠을 자곤 했는데 이 서비스를 만들면서 덕분에(?</div><div class=post-footer><a href=/2018/08/09/daily-dev-blog-2/>Read More</a><div class=post-tags><i class="fas fa-tags fa-fw"></i>&nbsp;<a href=/tags/archives-2018/>archives-2018</a></div></div></article><article class="single summary" itemscope itemtype=http://schema.org/Article><div class=featured-image-preview><a href=/2018/08/05/daily-dev-blog-1/><img class=lazyload src=/svg/loading.min.svg data-src=/images/daily-dev-blog-1/ddb-thumnail.png data-srcset="/images/daily-dev-blog-1/ddb-thumnail.png, /images/daily-dev-blog-1/ddb-thumnail.png 1.5x, /images/daily-dev-blog-1/ddb-thumnail.png 2x" data-sizes=auto alt=/images/daily-dev-blog-1/ddb-thumnail.png title=/images/daily-dev-blog-1/ddb-thumnail.png></a></div><h1 class=single-title itemprop="name headline"><a href=/2018/08/05/daily-dev-blog-1/>기술블로그 구독서비스 개발 후기 - 1부</a></h1><div class=post-meta><span class=post-author><a href=https://taetaetae.github.io/resume title=Author target=_blank rel="noopener noreffer author" class=author><i class="fas fa-user-circle fa-fw"></i>태태태</a></span>&nbsp;<span class=post-publish>published on <time datetime=2018-08-05>2018-08-05</time></span>&nbsp;<span class=post-category>included in <a href=/categories/tech/><i class="far fa-folder fa-fw"></i>Tech</a></span></div><div class=content>이번 포스팅은 약간의 자투리 시간을 활용하여 이것저것 만져보다 만들게 된 Daily DevBlog(기술블로그 구독서비스)에 대해 이야기 하려고 한다. 하나의 글에 관련 내용을 모두 담기에는 양이 많아서 읽는사람도 지루하고, 글을 쓰는 필자 또한 어불성설 할것같아 크게 3개의 시리즈로 나눠서 최대한 자세하고 현장감(?)있게 글을 써보려고 노력했다.
1부 : 왜 만들게 되었는가 그리고 어떤 구조로 만들었는가 2부 : 문제발생 및 Trouble Shooting 3부 : 앞으로의 계획과 방향성 글에 들어가기 앞서 최종 결과는 http://daily-devblog.com 에서 확인할수 있다.
무엇이 나를 움직이게 했는가 얼마전까지 오픈소스는 정말 실력있는 개발자나 유명한 사람들 말고는 금기의 영역(?)이라고 생각했었지만 최근 오픈소스 개발자 이야기 세미나를 다녀온뒤 마음속에 있었던 벽이 사라지는듯 했다. 세미나를 들으면서 &lsquo;나도 무언가를 만들어 볼수는 없을까?&rsquo;, &lsquo;회사라는 명찰을 떼면 난 어느 수준에서 개발을 하고 있는 것일까?&rsquo; 등 여러 생각들이 머리를 멤돌다 개발자를 위한 글쓰기라는 글에서 기술블로그들을 모아놓은 awesome-devblog를 소개하는 글을 보게 되었고 내 머릿속에 정리안되던 그 생각들은 &ldquo;이 데이터를 활용해서 무언가를 만들어보자!&ldquo;로 귀결되었다.
다른 이야기 이지만, awesome-devblog 을 보고 당장 내 블로그도 등록해야지 했었는데 이미 등록이 되어 있었다;; 등록해주신 분께 감사하다는 생각이 들기전에 내 블로그가 누군가에게 보여지고 있구나 하며 새삼 놀라움이 더 컸다.
요구사항과 도구 그리고 설계 만들려고 생각해봤던 요구사항은 다음과 같다. 마치 회사에서 개발전 스펙을 정리하듯&mldr;
웹페이지를 활용해서 구독하고자 하는 사람들의 이메일을 수집할수 있어야 한다. 매일 전날 작성된 글을 수집하고 조합하여 구독하고자 하는 사람들에게 메일을 보낼수 있어야 한다. 위 두가지만 보면 너무 간단했다. 또한 기존에 사용하지 않았던 기술들을 사용해보면서 최대한 심플하게 개발하는것을 첫 개인 프로젝트의 목표로 하고 싶었다. 하여 생각한 아키텍처는 다음과 같다.
최대한 심플하게 설계해보자." 최대한 심플하게 설계해보자. 데이터는 해당 github에 있길래 그냥 가져다 쓰려고 했으나 그래도 데이터를 관리하시는 분께 허락을 받고 사용하는게 상도덕(?)인것 같아 수소문끝에 연락을 해서 허락받는데 성공하였다.
데이터 사용을 허락해주신 천사같으신분&mldr;" 데이터 사용을 허락해주신 천사같으신분&mldr; 이 자리를 빌어 데이터를 사용할수 있도록 허락해주신분 께 감사인사를 표합니다.
홈페이지를 만들기 위해서는 이제껏 삼겹살에 소주처럼(응?) Java에 Spring을 사용해 왔었지만 이번엔 좀 다른 방식을 사용하고 싶었다.
물론 삼겹살에 맥주, 치킨에 소주를 먹어도 되긴 하지만&mldr;" 물론 삼겹살에 맥주, 치킨에 소주를 먹어도 되긴 하지만&mldr; 최근에 Flask라는 python기반 웹 프레임워크를 만져본 경험이 있어서 이렇다할 고민없이 빠른 결정을 할수 있었다. 또한 DB는 mysql 이나 기타 memory DB를 사용할까 했지만 이또한 심플하게 파일을 활용하는 sqlite3 을 사용하고자 하였다.
웹서버_최종_수정_파이널_진짜_확정 Flask를 활용하기 위해서는 당연히 웹서버가 필요했다. 처음엔 awesome-devblog에서도 사용하고 있던 https://www.heroku.com/ 를 이용해서 해보려 했으나 매일 구독자들에게 메일을 보내는 등 스케쥴러 기능같은건 구현하기 힘들었고 인스턴트 어플리케이션을 등록하는 형태라 사용자의 메일을 입력받고 저장하는 로직을 만들기는 어려워 보였다. (필자가 heroku를 너무 수박 겉핥기식으로 봐서 일수도 있다&mldr;) 좀더 찾아보니 https://www.pythonanywhere.com/ 라는 제한적이지만 무료 서비스가 있었는데 웹콘솔도 지원하고 상당히 매력있어 보여서 이거다! 하며 개발을 시작을 했으나 (나름 도메인까지 그럴싸하게 만들었지만&mldr; http://dailydevblog.pythonanywhere.com/ ) 세상에 공짜는 없다는 말을 실감하며 앞서 말했던 요구사항을 완벽하게 구현할 수 없는 상황이였다.(request 제한, 스케쥴러 등록 개수 제한 등 보다 여러기능을 사용하기 위해서는 돈을 내고 써야&mldr;) 마지막 희망으로 언제샀는지 서랍속 깊이 자고있던 라즈베리 파이를 꺼내서 공유기 DDNS설정을 하고 라즈베리안을 설치하며 웹서버를 위한 셋팅을 시도해보았으나 언제나 그렇듯 (시험공부 하기전에 책상 정리하고 괜히 방청소까지 하다가 피곤해서 자버리는듯한 느낌) 배보다 배꼽이 클것같아 이또한 진행하다가 중단하게 된다. 결국 AWS에서 1년동안은 무료로 사용할수 있는 Free Tier 라는걸 발견하고 이참에 나도한번 사용해보자라는 마음을 가지고 과금되지 않게 조심조심 셋팅을 할수 있었다.</div><div class=post-footer><a href=/2018/08/05/daily-dev-blog-1/>Read More</a><div class=post-tags><i class="fas fa-tags fa-fw"></i>&nbsp;<a href=/tags/aws/>aws</a>,&nbsp;<a href=/tags/python/>python</a>,&nbsp;<a href=/tags/flask/>flask</a>,&nbsp;<a href=/tags/archives-2018/>archives-2018</a></div></div></article><article class="single summary" itemscope itemtype=http://schema.org/Article><div class=featured-image-preview><a href=/2018/07/01/open-source-software-develpoer-story-review/><img class=lazyload src=/svg/loading.min.svg data-src=/images/open-source-software-develpoer-story-review/oss.png data-srcset="/images/open-source-software-develpoer-story-review/oss.png, /images/open-source-software-develpoer-story-review/oss.png 1.5x, /images/open-source-software-develpoer-story-review/oss.png 2x" data-sizes=auto alt=/images/open-source-software-develpoer-story-review/oss.png title=/images/open-source-software-develpoer-story-review/oss.png></a></div><h1 class=single-title itemprop="name headline"><a href=/2018/07/01/open-source-software-develpoer-story-review/>2018 오픈소스개발자이야기 후기</a></h1><div class=post-meta><span class=post-author><a href=https://taetaetae.github.io/resume title=Author target=_blank rel="noopener noreffer author" class=author><i class="fas fa-user-circle fa-fw"></i>태태태</a></span>&nbsp;<span class=post-publish>published on <time datetime=2018-07-01>2018-07-01</time></span>&nbsp;<span class=post-category>included in <a href=/categories/review/><i class="far fa-folder fa-fw"></i>review</a></span></div><div class=content>Facebook그룹들을 눈팅하다(?) OSS개발자 포럼에서 오픈소스 개발자이야기라는 주제로 세미나를 주최한다는 공지를 보게되었다. 언제부턴가 트랜드에 뒤쳐지지 않으려는 몸부림중 세미나같은 외부 개발 행사에 참여해보자는 마음으로 공지를 보자마자 홀린듯이 신청을 하게 되었고세미나를 듣고 감흥이 가시기 전에 후기를 적고자 한다.(시간이 지나면 잊어버릴것만같은, 보고 들은 생생한 그 무언가를 얻었기에&mldr;)
비가오는 주말이였지만 많이 배우고 오자는 설레임을 갖고 서울 광화문 근처에 있는 한국마이크로소프트로 가게되었다. 말로만 듣던 MS사 로고를 보고 사람들이 하나둘씩 모이는걸 보니 뭔가 배울수 있겠구나 하는 기대감이 생겼다. 사실 오픈소스를 사용만 해본 입장이라 실제 오픈소스에 기여하시는 분들은 어떤 생각들을 갖고 계시는지가 가장 궁금했고 개발자인 나도 언젠간 오픈소스에 기여할수있지 않을까 하는 생각을 하며 발표를 들었다.
# 회색지대 : 이상과 현실 - 오픈소스 저작권 / 신정규 님 오픈소스는 아무리 말그대로 Open이지만 오픈소스마다 다양한 저작권을 갖고있고 서로 쟁취하려는 싸움이 많이 발생한다고 한다. 그러다보니 어떠한 프로그램을 만들고 오픈소스화 시킬때도 라이센스의 종류를 잘 결정해야 추후 불이익을 당하는 상황을 모면할수 있다고 한다. 특허와 라이센스는 같은 말이면서도 다른데 아래 표처럼 각 상황에 따라 다른 부분을 확인할수 있었다.
특허 라이센스 권리발생 출원, 심사, 등록 창작과 동시 발생 권리내용 독점배타적 실시권 인격권/재산권 효력범위 아이디어의 동일성 표현의 실질적 유사성 첫 시간이기도 하였고 아무래도 주제가 끝장토론을 해도 안끝날 주제였던지라 정해진 시간을 넘길정도로 이야기를 많이 해주셨다. 특히 오픈소스 관련된 이야기는 사례를 이야기 해야 재밌다고 하셨는데 시간관계상 몇가지만 말씀해주셨다.
링크가 맞는지는 모르겠으나 첨부해본다. 엘림넷 vs 하이온넷 사건 EFM Networks 오라클 VS 구글 오픈소스 개발에 대해 단순하게 누구나 수정할수 있는 환경 이라고만 생각을 하고있다가 이런 복잡한 라이센스 문제가 나오니 약간 어려웠지만, 오픈소스의 생태계를 알고 발을 들이기 위해서는 어느정도의 히스토리는 알아야 겠다고 느끼게 되었다.
Elastic 에서 Remote 로 일하기 / 김종민 님 그전부터 Elastic 제품들을 실무에서도 사용해 왔었기에 개인적으로 오늘 발표중에 가장 궁금했었고, 관심이 있던 시간이였다. 발표에 앞서 어떻게 Elastic에 들어가게 되셨고 회사 소개를 간단히 해주셨는데 생각보다 어마어마한 회사다고 느낄수 있었다.(800여명중 한국엔 9명 / 네덜란드 출신 스타트업 인데 본사는 캘리포니아 마운틴뷰에 있고 등등) 원격근무는 편하고 비용이 절약되는 장점이 있으나 동료들간의 유대감형성이 힘들거나 회의시 집중이 힘든 단점도 있다는 점을 말씀해 주셨다. 시간관계상 몇가지 링크들을 소개해주셨는데 나중에 봐볼 생각이다.
침대에서 회사까지 1분 [마소 392호] 리모트 워크의 중심에 서보다 원격 툴로는 다음과 같이 사용한다고 한다.
github : 슬랙연동, 개발뿐 아니라 운영/기획/이벤트 공유시 활용 Google Apps Slack : 봇 활용 (다양한 종류의 봇, 상황마다 특정 알림을 준다.) salesforce : CRM 툴 zoom : 화상회의 200명 동시콜 가능, 회의가 끝나면 녹음/녹화/스크립팅까지 가능하다고 한다 (wow) pinboard : 근태/인사 관리용 앱 jira는 사용 잘 안함 나중에 팀 내 Slack 봇으로 여러가지 다양한 자동화를 구성할수 있을것 같다는 생각이 들었다.
오픈소스 생태계 일원으로서의 개발자 / 변정훈 님 사회자분이 &ldquo;아웃사이더님"이라고 하시길래 설마 했다. 뭐가 잘 안되면 구글링을 하게되는데 내가 자주 보던 블로그를 운영하셨던 분이 내눈앞에 ㄷㄷ&mldr; 언제부터 해야지~가 아니고 개발하다보니 어느새 오픈소스에 참여하고 있었다고 한다. 또한 참여하는게 아니고 이미 오픈소스 생태계속에서 살고있는 우리들이라 말씀하시고, 오픈소스 Contribution 방법으로는 사용/홍보/번역/리포팅/문서화/코드제출 등 다양하게 있으니 어렵게 생각하지 말자 라고 하셨다. 오픈소스에서 배울수 있는점은 커뮤니케이션의 방법, 협업의 방법과 중요성, 테스트코드의 중요성, 지속적 통합/지속적 배포, 코드의 품질관리 라고 한다. 점점 발표를 들으면서 오픈소스에 대한 생각이 바뀌고 있는 내 자신을 느낄수 있었다.</div><div class=post-footer><a href=/2018/07/01/open-source-software-develpoer-story-review/>Read More</a><div class=post-tags><i class="fas fa-tags fa-fw"></i>&nbsp;<a href=/tags/oss/>oss</a>,&nbsp;<a href=/tags/open-source-software/>open source software</a>,&nbsp;<a href=/tags/review/>review</a>,&nbsp;<a href=/tags/archives-2018/>archives-2018</a></div></div></article><article class="single summary" itemscope itemtype=http://schema.org/Article><div class=featured-image-preview><a href=/2018/07/01/simple-web-server-flask-nginx/><img class=lazyload src=/svg/loading.min.svg data-src=/images/simple-web-server-flask-nginx/flask-apache-nginx.png data-srcset="/images/simple-web-server-flask-nginx/flask-apache-nginx.png, /images/simple-web-server-flask-nginx/flask-apache-nginx.png 1.5x, /images/simple-web-server-flask-nginx/flask-apache-nginx.png 2x" data-sizes=auto alt=/images/simple-web-server-flask-nginx/flask-apache-nginx.png title=/images/simple-web-server-flask-nginx/flask-apache-nginx.png></a></div><h1 class=single-title itemprop="name headline"><a href=/2018/07/01/simple-web-server-flask-nginx/>초간단 API서버 만들기 - 2부 (Python + Flask + Nginx)</a></h1><div class=post-meta><span class=post-author><a href=https://taetaetae.github.io/resume title=Author target=_blank rel="noopener noreffer author" class=author><i class="fas fa-user-circle fa-fw"></i>태태태</a></span>&nbsp;<span class=post-publish>published on <time datetime=2018-07-01>2018-07-01</time></span>&nbsp;<span class=post-category>included in <a href=/categories/tech/><i class="far fa-folder fa-fw"></i>Tech</a></span></div><div class=content>지난포스팅에 이어 이번엔 Flask와 Nginx를 연동하는 방법을 정리해보고자 한다. Apache로 연동했는데 왜 또 Nginx로 연동하는걸 정리하지(?)하며 의문이 들수 있는데 다른 포스팅을 봐도 Apache + Flask 조합보다 Nginx + Flask 조합이 더 많고 지난 포스팅에서도 알수있었듯이 (Apache VS Nginx) 둘중 어느것이 좋다고 할수도 없고 각 상황에서 연동하는 방법을 알고 있다면 이 또한 나만의 무기가 될것같아 Nginx를 연동하는 방법을 정리해보려 한다.
1부에서 왜 Flask인가, Flask의 장점에 대해 정리를 했으니 이번 포스팅에서는 별도로 작성하진 않는다.
Nginx 설치 ( https://nginx.org/en/ ) 역시 소스설치를 한다.
- 다운을 받고 $ https://nginx.org/download/nginx-1.14.0.tar.gz - 압축을 푼 다음 $ tar -zxvf nginx-1.14.0.tar.gz - 폴더로 이동해서 $ cd nginx-1.14.0 - 설치할 디렉토리를 설정하고 $ ./configure --prefix=/~~~/apps/nginx - make 파일을 만들고 $ make - 설치를 진행한다. $ make install 이렇게 하면 일단 Nginx는 설치가 되었다.
uWSGI 설치 ( https://uwsgi-docs.readthedocs.io/ ) 앞서 Apache와 연동할때는 별도의 모듈을 Apache에게 등록하는 형태였다면 Nginx는 WSGI프로토콜을 활용하는 WSGI 어플리케이션을 실행하는 어플리케이션 서버를 활용해야 한다.
- 다운을 받고 $ wget https://projects.unbit.it/downloads/uwsgi-latest.tar.gz - 압축을 풀고 $ tar zxvf uwsgi-latest.tar.gz - 폴더로 이동하여 $ cd uwsgi-2.0.17 - make 명령어를 호출하면 'uwsgi'이라는 실행파일이 생성된다. $ make Nginx 설정 Apache와 비슷하게 uWSGI 관련 설정을 해준다.
server { listen 80; server_name localhost; location / { # ( / ) 경로로 들어올 경우 include uwsgi_params; # GET/POST 등 기본적으로 필요한 환경변수를 include 해준다. uwsgi_pass 127.0.0.1:3031; # 요청을 IP:PORT로 전달한다. } } 별도의 모듈을 사용하지 않기때문에 전달해주는 (proxy느낌) 설정을 해준다.
uWSGI 실행 및 Nginx 재시작 앞서 설치한 uwsgi를 아래처럼 IP:port 를 명시적으로 적어주고 (위에서 전달받은 IP:PORT와 동일하게) Apache 연동시 활용했던 wsgi파일을 이번에도 동일하게 사용하도록 해서 실행한다.
$ ./uwsgi -s 127.0.0.1:3031 --wsgi-file /~~~/python_app/hello_world.wsgi 이렇게 하면 background로 실행되는게 아닌 foreground로 실행되기 때문에 &을 사용한다던지 해서 background로 실행되도록 해준다. 그후 Nginx를 재시작 해주면 원하는 그토록 원했던 Hello World!를 만날수가 있게 된다.
Apache연동과 조금 다른점은 모듈을 사용하지않고 별도의 전달 어플리케이션(?)이 필요하다는점이다. 간단히 Apache처럼 모듈만 넣으면 되는게 아니라서 불편할수도 있을것 같지만 한편으로는 관리할수있는 포인트가 더 늘어난 셈이라 어떤 측면에서는 활용할수 있는 방법이 하나 늘어난것으로 볼수도 있다.
마치며 막상 정리하고 나면 아무것도 아닌데 알기 위해서 몸부림을 쳐가며 책이며 구글링을 하는 과정을 통해 점점 성장을 하는것 같다. (성장통이라고나 할까) 이렇게 단순히 Flask를 할수있다 가 아닌 웹서버를 연동할수있다. 그것도 Apache와 Nginx 두개나. 이것도 언젠간 나만의 무기가 되지 않을까?</div><div class=post-footer><a href=/2018/07/01/simple-web-server-flask-nginx/>Read More</a><div class=post-tags><i class="fas fa-tags fa-fw"></i>&nbsp;<a href=/tags/apache/>apache</a>,&nbsp;<a href=/tags/flask/>flask</a>,&nbsp;<a href=/tags/nginx/>nginx</a>,&nbsp;<a href=/tags/web-server/>web server</a>,&nbsp;<a href=/tags/archives-2018/>archives-2018</a></div></div></article><article class="single summary" itemscope itemtype=http://schema.org/Article><div class=featured-image-preview><a href=/2018/06/29/simple-web-server-flask-apache/><img class=lazyload src=/svg/loading.min.svg data-src=/images/simple-web-server-flask-apache/flask-apache-python.png data-srcset="/images/simple-web-server-flask-apache/flask-apache-python.png, /images/simple-web-server-flask-apache/flask-apache-python.png 1.5x, /images/simple-web-server-flask-apache/flask-apache-python.png 2x" data-sizes=auto alt=/images/simple-web-server-flask-apache/flask-apache-python.png title=/images/simple-web-server-flask-apache/flask-apache-python.png></a></div><h1 class=single-title itemprop="name headline"><a href=/2018/06/29/simple-web-server-flask-apache/>초간단 API서버 만들기 - 1부 (Python + Flask + Apache)</a></h1><div class=post-meta><span class=post-author><a href=https://taetaetae.github.io/resume title=Author target=_blank rel="noopener noreffer author" class=author><i class="fas fa-user-circle fa-fw"></i>태태태</a></span>&nbsp;<span class=post-publish>published on <time datetime=2018-06-29>2018-06-29</time></span>&nbsp;<span class=post-category>included in <a href=/categories/tech/><i class="far fa-folder fa-fw"></i>Tech</a></span></div><div class=content>Static한 HTML이 아닌 로직이 필요한 API서버를 구성한다고 가정해보자. (이제까지 지식으로)처음 머릿속에 떠오르는건 Java를 사용하고 스프링으로 어플리케이션을 만들고 apache에 tomcat을 연동한 다음 &mldr;이러한 방법으로 API서버를 구성할수 있겠지만 프로토타이핑 또는 테스트 목적으로 만들기 위해서는 설정하는 시간이 은근 많이 소요된다. (물론 Java Config, Spring Boot 등 간소해졌지만&mldr;) 얼마전부터 Python에 대한 매력을 뼈저리게 느끼고 있다보니 Python으로 API서버를 구성할순 없을까 알아봤고 (모바일 게임 듀랑고 서버가 python이라고 하기도 하고&mldr;) Flask와 Django가 있어서 둘다 써본 결과 필자는 Flask가 맞겠다고 생각해서 정리를 해볼까 한다.
&lsquo;장고&rsquo;라고도 불리는 Django에는 모든것들이 다 들어가 있어서 사용하기 너무 편리하다. (DB, 어드민 등 ) 하지만 Flask는 내가 사용할 것들만 import해서 사용하는 방식이라 어떤 측면에서는 아무것도 없다 할수 있겠으나 커스터마이징에 용이하다고 볼수 있었기에 Flask를 선택하게 되었다. (Django가 Flask보다 안좋다는 말은 아니니 오해는 하지 마시길&mldr;)
글쓰기에 앞서 본 포스팅은 2개의 포스팅에 걸쳐 시리즈(?)형식으로 작성할 예정이다. 1부에서는 Flask가 무엇이고 이를 어떻게 사용하며 Apache와 연동하는 방법을 소개하고, 2부에서는 Nginx와 연동하는 방법을 소개한다. 환경은 다음과 같다.
CentOS 7.4 Python 3.6 (기본은 2.7이였으나 추가로 설치) Flask ( http://flask.pocoo.org/ ) 공식 홈페이지에서도 보면 알수 있듯이 너~무 간단하다. 단지 아래 코드 몇줄만 작성하면 우리가 모든 프로그램 초기 작성시 항상 만나는 &ldquo;Hello World"를 볼수 있다.
#hello_world.py from flask import Flask app = Flask(__name__) @app.route("/") def hello(): return "Hello World!" 위와같이 작성하고 python hello.py로 실행해두고 브라우저에서 http://127.0.0.1:5000 을 요청하면 반가운 Hello World를 만날수 있다. (너무 간단;;) 자세한 문법은 도큐먼트를 참조하면 될듯하고 이 Flask를 잘만 활용한다면 보다 빠르고 간단하게 API서버를 구성할수 있을거라 생각한다.
Hello World를 찍었으면 된거 아닌가 라고 질문할수도 있겠으나 실제 서비스에서 사용하기 위해서는 앞단에 웹서버를 두는게 여러 측면에서 효율적이다. 주로 사용하는 웹서버는 Apache 와 Nginx가 있는데 여기서는 Apache와 연동하는 방법을 정리 해보고자 한다.
Apache 설치 ( http://archive.apache.org/ ) 우선 필자는 yum 이나 apt-get처럼 패키지 관리자로 설치하는것을 그렇게 좋아하지 않는다. 이유는 커스터마이징을 할 경우 시스템 어느곳에 설치되어있는지를 한눈에 파악하기 어렵고 윈도우경우 Program Files처럼 내가 추가로 설치하고 관리하는 프로그램들을 한곳에서 관리하고 싶기에 왠만하면 소스를 직접 컴파일하여 설치하곤 한다. 이번 역시 아파치도 소스로 설치하려고 한다. 현재 아파치는 2.4버전이 Stable버전으로 되어있지만 보다 레퍼런스가 많은 2.2버전으로 설치하기 위해 어렵게 아카이빙된 경로를 통해 다운을 받고 설치를 한다.
- 다운을 받고 $ wget http://archive.apache.org/dist/httpd/httpd-2.2.29.tar.gz - 압축을 푼 다음 $ tar xvzf httpd-2.2.29.tar.gz - 해당 폴더로 들어가 $ cd httpd-2.2.29 - 컴파일 후 설치 경로를 정해주고 $ ./configure --prefix=/~~~/apps/apache - make 파일을 만든다음 $ make - 설치를 해준다. $ make install 이렇게 되면 /~~~/apps/apache/ 하위에 필요한 파일들이 설치가 되는데 root계정이 아닌 일반계정으로 실행하기 위해서는 /bin하위에 있는 httpd에 대한 실행/소유권한을 변경해줘야 한다. (아니면 그냥 root권한으로 시작/종료. 왜? Apache는 80port를 사용하는데 일반적으로 리눅스에서는 1024 아래 port를 컨트롤 하기 위해서는 root권한이 있어야 사용이 가능, 그게 아니라면 이처럼 별도의 설정이 필요하다.)
$ sudo chown root:계정명 httpd $ sudo chmod +s httpd mod_wsgi 설치 ( https://code.google.com/archive/p/modwsgi/ ) 웹 서버 게이트웨이 인터페이스(WSGI, Web Server Gateway Interface)는 웹서버와 웹 애플리케이션의 인터페이스를 위한 파이선 프레임워크다. 라고 정의되어있다. 즉, 웹서버(Apache)와 위에서 만든 Flask 어플리케이션을 연동해주기 위한 프레임워크이다. 이또한 소스로 설치해보자. (위와 같은 이유로~)
- 다운을 받고 $ wget https://github.com/GrahamDumpleton/mod_wsgi/archive/3.5.tar.gz - 압축을 푼 다음 $ tar -zxvf 3.5.tar.gz - 폴더에 들어가서 $ cd mod_wsgi-3.5 - 아파치의 빌드툴인 apxs의 경로를 설정해주고 - 필자와 같이 기본 python 버전을 사용하지 않을꺼라면 꼭 python경로를 설정해줘야 한다!</div><div class=post-footer><a href=/2018/06/29/simple-web-server-flask-apache/>Read More</a><div class=post-tags><i class="fas fa-tags fa-fw"></i>&nbsp;<a href=/tags/apache/>apache</a>,&nbsp;<a href=/tags/flask/>flask</a>,&nbsp;<a href=/tags/python/>python</a>,&nbsp;<a href=/tags/web-server/>web server</a>,&nbsp;<a href=/tags/archives-2018/>archives-2018</a></div></div></article><article class="single summary" itemscope itemtype=http://schema.org/Article><div class=featured-image-preview><a href=/2018/06/27/apache-vs-nginx/><img class=lazyload src=/svg/loading.min.svg data-src=/images/apache-vs-nginx/want_to_know_that_apache_vs_nginx.png data-srcset="/images/apache-vs-nginx/want_to_know_that_apache_vs_nginx.png, /images/apache-vs-nginx/want_to_know_that_apache_vs_nginx.png 1.5x, /images/apache-vs-nginx/want_to_know_that_apache_vs_nginx.png 2x" data-sizes=auto alt=/images/apache-vs-nginx/want_to_know_that_apache_vs_nginx.png title=/images/apache-vs-nginx/want_to_know_that_apache_vs_nginx.png></a></div><h1 class=single-title itemprop="name headline"><a href=/2018/06/27/apache-vs-nginx/>Apache냐 Nginx냐, 그것이 알고싶다.</a></h1><div class=post-meta><span class=post-author><a href=https://taetaetae.github.io/resume title=Author target=_blank rel="noopener noreffer author" class=author><i class="fas fa-user-circle fa-fw"></i>태태태</a></span>&nbsp;<span class=post-publish>published on <time datetime=2018-06-27>2018-06-27</time></span>&nbsp;<span class=post-category>included in <a href=/categories/tech/><i class="far fa-folder fa-fw"></i>Tech</a></span></div><div class=content>웹서버는 HTTP 프로토콜을 통해 읽힐수 있는 문서를 처리를 하며 일반적으로 웹 어플리케이션의 앞단에 배치되곤 한다. 동적인 리소스는 WAS에게 처리하도록 하고 정적인 리소스를 보다 효율적으로 처리하기 위한 방법일수도 있다. 크게 Apache와 Nginx가 사용되곤 하는데 이 둘의 차이는 무엇일까?사실 필자는 사내에서 주로 Apache만 사용하다보니 Nginx는 그저 Apache와는 다른 방식의 웹서버다 또는 보다 경량화 되었다 정도로만 알고있었는데 이번기회를 통해 제대로 알고 비교를 해보면서 결국 어떤게 좋은지 알아보고자 한다.
구글링을 조금만 해보면 Apache와 Nginx를 비교하는 포스팅이 많이 나온다. 이번 포스팅의 목적 이러한 정보들을 단순히 요약/종합 하려는게 아니고, 최대한 실무 서비스를 운영하는 시각으로 정리하고자 함을 밝힌다.
Apache ( https://httpd.apache.org/ ) 우리나라에서 웹어플리케이션을 개발하는 사람들은 한번쯤은 들어봤을 Apache. 국내 일반적인 기업에서 웹서버의 표준으로 자리잡았다고 해도 과언이 아닐것 같다. Client에서 요청을 받으면 MPM (Multi Processing Module : 다중처리모듈) 이라는 방식으로 처리를 하는데 대표적으로는 Prefork와 Worker방식이 있다. 간단하게 어떤식으로 처리하는지 알고 넘어가자.
Prefork MPM Prefork MPM, http://old.zope.org/Members/ike/Apache2/osx/configure_html" Prefork MPM, http://old.zope.org/Members/ike/Apache2/osx/configure_html 실행중인 프로세스를 복제되어 처리가 된다. 각 프로세스는 한번에 한 연결만 처리하고 요청량이 많아질수록 프로세스는 증가하지만 복제시 메모리영역까지 복제되어 동작하므로 프로세스간 메모리 공유가 없어 안정적이라 볼수 있다.
Worker MPM Worker MPM, http://old.zope.org/Members/ike/Apache2/osx/configure_html" Worker MPM, http://old.zope.org/Members/ike/Apache2/osx/configure_html Prefork 동작방식이 1개의 프로세스가 1개의 스레드로 처리가 되었다면 Worker 동작방식은 1개의 프로세스가 각각 여러 쓰레드를 사용하게 된다. 쓰레드간의 메모리를 공유하며 PreFork방식보다 메모리를 덜 사용하는 장점이 있다.
참고로 WAS로 tomcat을 연동하는 경우라면 mod_jk, mod_proxy, mod_proxy_ajp 방식을 Apache 자체적으로 지원해주기 때문에 다양하고 효율적으로 tomcat을 연동할수 있다. 참고링크
Nginx ( https://nginx.org/en/ ) Nginx에 대해 살펴보기 전에 구글 트랜드를 활용하여 Nginx에 대한 관심이 어느정도인지를 보고 넘어가자.
최근 5년간 구글트랜드, 파란색이 Apache이고 빨간색이 Nginx" 최근 5년간 구글트랜드, 파란색이 Apache이고 빨간색이 Nginx 전세계는 Nginx보다는 Apache에 대한 관심이 많은것으로 보이는데 국내는 아주 조금씩 Nginx에 대한 관심이 오르는것을 볼수있었다. (그래도 아직은 Apache가 월등히 우세한 편이다.) 그럼 Nginx는 어떤식으로 돌아가는 것일까? 가장 유명한(?) 특징이라면 Event Driven 방식을 꼽을수 있을것 같다. Event Driven 방식에 대해 잠깐 언급을 하고 넘어가면 요청이 들어오면 어떤 동작을 해야하는지만 알려주고 다른요청을 처리하는 방식이다. (Producer Consumer Pattern과 유사하다.) 그러다보니 프로세스를 fork하거나 쓰레드를 사용하는 아파치와는 달리 CPU와 관계없이 모든 IO들을 전부 Event Listener로 미루기 때문에 흐름이 끊기지 않고 응답이 빠르게 진행이 되어 1개의 프로세스로 더 빠른 작업이 가능하게 될수 있다. 이때문에 메모리적인 측면에서 Nginx가 System Resource를 적게 처리한다는 장점이 있다고 한다.
Nginx Process Model (https://www.nginx.com/blog/inside-nginx-how-we-designed-for-performance-scale)" Nginx Process Model (https://www.nginx.com/blog/inside-nginx-how-we-designed-for-performance-scale) 그래서 뭐가 좋은가? 이 포스팅을 적으면서 마지막엔 Apache가 더좋다 또는 Nginx가 더좋다로 마무리를 짓고 싶었는데 어느 시사/교양 프로그램처럼 어쩔수 없는 열린결말로 마무리를 지을수밖에 없을것 같다. (어찌보면 이게 정답일수도?)
기술의 선택에 있어서 정답은 없는것 같다.(물론 Spring 을 사용하느냐 서블릿을 직접 구현하는냐 와는 좀 다른 성격의 이야기;;) 운영하고 있는 서비스의 상황을 잘 알고 튜닝을 해가면서 가장 효율적인것을 선택하는게 정답이라고 말할수 밖에&mldr; 커뮤니티 파워를 무시 못하기 때문에 Apache를 선택할수도 있을테고, 점점 관심도가 올라간다는건 그만큼의 장점이 있고 또한 메모리 측면에서 동접자 처리시 효율적인 Nginx를 사용할수 있을것 같다.
정리하면. 내가 사용하기에 어려움이 없는 도구를 잘 활용하는것, 그렇다고 오래된 기술이 편한다고 집착해서는 안되며, 새로운 기술을 두려워 하지말고 경험을 해본 뒤에 결정을 할것 이라고 내릴수 있을것 같다. (어렵다&mldr;ㅠㅠ)
참고 포스팅 http://www.mukgee.com/?p=293 http://knot.tistory.com/88 http://tmondev.blog.me/220737182315 http://tmondev.blog.me/220731906490 http://urin79.com/blog/20654191 http://jaweb.tistory.com/entry/apache-%EC%99%80-Nginx-%EB%AD%90%EA%B0%80-%EC%A2%8B%EC%9D%80%EA%B1%B0%EC%95%BC</div><div class=post-footer><a href=/2018/06/27/apache-vs-nginx/>Read More</a><div class=post-tags><i class="fas fa-tags fa-fw"></i>&nbsp;<a href=/tags/apache/>apache</a>,&nbsp;<a href=/tags/nginx/>nginx</a>,&nbsp;<a href=/tags/web-server/>web server</a>,&nbsp;<a href=/tags/event-driven/>Event Driven</a>,&nbsp;<a href=/tags/prefork-mpm/>Prefork MPM</a>,&nbsp;<a href=/tags/worker-mpm/>Worker MPM</a>,&nbsp;<a href=/tags/archives-2018/>archives-2018</a></div></div></article><article class="single summary" itemscope itemtype=http://schema.org/Article><div class=featured-image-preview><a href=/2018/05/31/anomaly-detection/><img class=lazyload src=/svg/loading.min.svg data-src=/images/anomaly-detection/kiyoung_chart.png data-srcset="/images/anomaly-detection/kiyoung_chart.png, /images/anomaly-detection/kiyoung_chart.png 1.5x, /images/anomaly-detection/kiyoung_chart.png 2x" data-sizes=auto alt=/images/anomaly-detection/kiyoung_chart.png title=/images/anomaly-detection/kiyoung_chart.png></a></div><h1 class=single-title itemprop="name headline"><a href=/2018/05/31/anomaly-detection/>시계열 데이터를 분석하여 미래 예측 하기(Anomaly Detection)</a></h1><div class=post-meta><span class=post-author><a href=https://taetaetae.github.io/resume title=Author target=_blank rel="noopener noreffer author" class=author><i class="fas fa-user-circle fa-fw"></i>태태태</a></span>&nbsp;<span class=post-publish>published on <time datetime=2018-05-31>2018-05-31</time></span>&nbsp;<span class=post-category>included in <a href=/categories/tech/><i class="far fa-folder fa-fw"></i>Tech</a></span></div><div class=content>급변하는 날씨를 예측하려면 어떠한 정보가 있어야 할까? 또는 마트를 운영하는 담당자인 경우 매장 운영시간을 정해야 한다면 어떠한 기준으로? 뜨거운 감자인 비트코인 시장에서 수익을 얻으려면 어떤 정보들이 있어야 물리지(?) 않을수 있을까?
위 질문에 공통된 정답은 예전 기록들인것 같다. 날씨예측은 기상청에서 과거 기록들을 보고 비가 올지 말지를 결정하고 ( 과거 날씨 서비스를 담당해봤지만 단순히 과거 기록들로 예측한다는건 불가능에 가깝긴 하다. ) 매장 운영시간은 예전에 손님들이 언제왔는지에 대한 데이터를 보고. 비트코인이나 주식은 차트를 보고 어느정도는 상승장일지 하락장일지 추측이 가능하다고 한다. ( 물론 호재/악재에 따라 흔들리지만..ㅠㅠ..?? ) 이처럼 시간의 흐름에 따라 만들어진 데이터를 분석하는것을 시계열 데이터 분석이라 부르고 있다. 필자가 운영하는 서비스에서 시계열 데이터 분석을 통해 장애를 사전에 방지하는 사례를 공유 해보고자 한다.
상황파악부터 손자병법에는 지피지기 백전불태 라는 말이 있다. 그만큼 현 상황을 잘 알아야 대응을 잘할수 있다는것. 필자가 운영하는 서비스는 PG(Payment Gateway) 서비스로 쇼핑몰같은 온/오프라인 사업자와 실제 카드사와의 중간 역활을 해주고 있다. 이를테면 사용자가 생수를 10,000원에 XX카드로 구매해줘 라고 요청이 오면 그 정보를 다시 형식에 맞춰 카드사로 전달하여 사용자가 물건을 구매할수 있도록 해준다.
PG서비스 : 쇼핑몰과 카드사의 중간에서 릴레이 해주는 역활이라 보면된다." PG서비스 : 쇼핑몰과 카드사의 중간에서 릴레이 해주는 역활이라 보면된다. 요구사항 및 과거 데이터 분석 서비스를 운영해보니 감지하기 어려운 상황들이 있었다.
연동하는 쇼핑몰에서 문제가 발생하거나 네트워크 문제가 발생할경우 즉, 트래픽이 평소보다 적게 들어올 경우 정상적인 에러(e.g. 잔액부족) 가 갑자기 많이 발생할 경우 이를 분석하기위해 기존의 트래픽/데이터를 분석해봐야 했다.
결제건수 Kibana Visualize, 기영이 패턴" 결제건수 Kibana Visualize, 기영이 패턴 위 그래프는 결제데이터 카운트 인데 어느정도 패턴을 찾을수 있다.
에러건수 Kibana Visualize, 악어 패턴..(무리수..)" 에러건수 Kibana Visualize, 악어 패턴..(무리수..) 위 그래프는 에러카운트 인데 일정한 패턴 속에서 어느 지점에서는 튀는것을 확인할수 있다. (빨간색 영역) 그렇다면 어떤 방법으로 장애상황보다 앞서서 감지를 할수 있을까? ( 장애 : 어떠한 내/외부 요인으로 인해 정상적인 서비스가 되지 않는 상태 )
장애발생 전에 먼저 찾아보자! 가장 간단하게는 기존 데이터를 보고 수동으로 설정하는 방법이 있을수 있다. 예로들어 자정 즈음에는 결제량이 가장 많기때문에 약 xx건으로 설정해두고, 새벽에는 결제량이 가장 적기 때문에 약 yy건으로 설정해둔 후 에러 건수나 결제건수에 대해 실시간으로 검사를 해가면서 설정한 값보다 벗어날 경우 알림을 주는 방법이다. 하지만 아무리 과거 데이터를 완벽하게 분석했다 할지라도 24시간 모든 시점에서 예측은 벗어날 수밖에 없다. (예로들어 쇼핑 이벤트를 갑작스럽게 하게되면 결제량은 예측하지 못할정도로 늘어날테고&mldr;) 또한 설정한 예측값을 벗어날 경우 수동으로 다시 예측값을 조정해줘야 하는데, 이럴꺼면 24시간 종합 상황실에서 사람이 직접 눈으로 보는것 보다 못할것 같다. (인력 리소스가 충분하다면 뭐&mldr; 그렇게 해도 된다.)
지난 데이터와 비교하기 일주일 기준으로 지난 일주일과의 데이터를 비교해보는 방법또한 있다. 간단하게 설명하면 이번주 월요일 10시의 데이터와 지난주 월요일 10시의 데이터의 차이를 비교해보는 방법이다. 키바나에서 클릭 몇번만으로 시각화를 도와주는 Visualize 기능을 통해 지난 일주일과 이번주를 비교해보면 아래 그래프처럼 표현이 가능하다.
일주일 전 데이터와 단순 비교" 일주일 전 데이터와 단순 비교 이 경우도 지난주 상황과 이번주 상황이 다른 경우에는 원하는 비교 항목 외에 다른 요인이 추가되기 때문에 원하는 비교를 할수가 없고 위에서 수동으로 설정하는 방법과 별반 다를바 없을것으로 생각된다.
조금더 우아하게! (언제부턴가 우아하단 말을 좋아하는것 같다..) 개발자는 문제에 대해서 언제나 분석을 토대로 접근을 하는것을 목표로 해야한다. 언제부턴가 Hot한 머신러닝을 도입해 보고 싶었으나 아직 그런 실력이 되질 못하고&mldr; 폭풍 구글링을 통해 알게된 Facebook에서 만든 Prophet이라는 모듈을 활용해보고자 한다. https://opensource.fb.com/#artificial 이곳에 가보면 여러 Artificial Intelligence 관련된 오픈소스들중에 Prophet 모듈을 찾을수 있다.</div><div class=post-footer><a href=/2018/05/31/anomaly-detection/>Read More</a><div class=post-tags><i class="fas fa-tags fa-fw"></i>&nbsp;<a href=/tags/python/>python</a>,&nbsp;<a href=/tags/anomaly-detection/>anomaly detection</a>,&nbsp;<a href=/tags/elasticsearch/>elasticsearch</a>,&nbsp;<a href=/tags/prophet/>prophet</a>,&nbsp;<a href=/tags/facebook/>facebook</a>,&nbsp;<a href=/tags/archives-2018/>archives-2018</a></div></div></article><ul class=pagination><li class=page-item><span class=page-link><a href=/>1</a></span></li><li class=page-item><span class=page-link aria-hidden=true>&mldr;</span></li><li class=page-item><span class=page-link><a href=/page/4/>4</a></span></li><li class=page-item><span class=page-link><a href=/page/5/>5</a></span></li><li class="page-item active"><span class=page-link><a href=/page/6/>6</a></span></li><li class=page-item><span class=page-link><a href=/page/7/>7</a></span></li><li class=page-item><span class=page-link><a href=/page/8/>8</a></span></li><li class=page-item><span class=page-link aria-hidden=true>&mldr;</span></li><li class=page-item><span class=page-link><a href=/page/10/>10</a></span></li></ul></div></div></main><footer class=footer><div class=footer-container><div class=footer-line>Powered by <a href=https://gohugo.io/ target=_blank rel="noopener noreffer" title="Hugo 0.74.3">Hugo</a> | Theme - <a href=https://github.com/dillonzq/LoveIt target=_blank rel="noopener noreffer" title="LoveIt 0.2.10"><i class="far fa-kiss-wink-heart fa-fw"></i>LoveIt</a></div><div class=footer-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2016 - 2021</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=https://taetaetae.github.io/resume target=_blank>태태태</a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title="Back to Top"><i class="fas fa-arrow-up fa-fw"></i></a><a href=# id=view-comments class=fixed-button title="View Comments"><i class="fas fa-comment fa-fw"></i></a></div><link rel=stylesheet href=/lib/lightgallery/lightgallery.min.css><script type=text/javascript src=/lib/smooth-scroll/smooth-scroll.min.js></script><script type=text/javascript src=/lib/lazysizes/lazysizes.min.js></script><script type=text/javascript src=/lib/lightgallery/lightgallery.min.js></script><script type=text/javascript src=/lib/lightgallery/lg-thumbnail.min.js></script><script type=text/javascript src=/lib/lightgallery/lg-zoom.min.js></script><script type=text/javascript src=/lib/clipboard/clipboard.min.js></script><script type=text/javascript src=/lib/sharer/sharer.min.js></script><script type=text/javascript src=/lib/typeit/typeit.min.js></script><script type=text/javascript>window.config={"code":{"copyTitle":"Copy to clipboard","maxShownLines":500},"data":{"id-1":"Programmer rather than coder."},"lightGallery":{"actualSize":false,"exThumbImage":"data-thumbnail","hideBarsDelay":2000,"selector":".lightgallery","speed":400,"thumbContHeight":80,"thumbWidth":80,"thumbnail":true},"typeit":{"cursorChar":"|","cursorSpeed":500,"data":{"id-1":["id-1"]},"duration":-1,"speed":100}};</script><script type=text/javascript src=/js/theme.min.js></script><script type=text/javascript>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}gtag('js',new Date());gtag('config','UA-86432198-1',{'anonymize_ip':true});</script><script type=text/javascript src="https://www.googletagmanager.com/gtag/js?id=UA-86432198-1" async></script></body></html>