<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><meta http-equiv=x-ua-compatible content="IE=edge, chrome=1"><title>소나큐브 이용 코드 정적분석 자동화 - 👨‍💻꿈꾸는 태태태의 공간</title><meta name=Description content><meta property="og:title" content="소나큐브 이용 코드 정적분석 자동화"><meta property="og:description" content="코드 정적분석이라 함은 실제 프로그램을 실행하지 않고 코드만의 형태에 대한 분석을 말한다. 이를테면 냄새나는 코드(?)라던지, 위험성이 있는 코드, 미리 정의된 규칙이나 코딩 표준을 준수하는지에 대한 분석을 말하는데 java 기준으로는 아래 다양한 (잘 알려진) 정적분석 도구들이 있다. PMD  미사용 변수, 비어있는 코드 블락, 불필요한 오브젝트 생성과 같은 Defect을 유발할 수 있는 코드를 검사 https://pmd.github.io   FindBugs  정해진 규칙에 의해 잠재적인 에러 타입을 찾아줌 http://findbugs.sourceforge.net   CheckStyle  정해진 코딩 룰을 잘 따르고 있는지에 대한 분석 http://checkstyle.sourceforge.net    이외에 SonarQube 라는 툴이 있는데 개인적으로 위 알려진 다른 툴들의 종합판(?)이라고 생각이 들었고, 그중 가장 인상깊었던 기능이 github과 연동이 되고 적절한 구성을 하게 되면 코드를 수정하는과 동시에 자동으로 분석을 하고 리포팅까지 해준다는 부분이였다. ( 더 좋은 방법이 있는지는 모르겠으나 다른 도구들은 수동으로 돌려줘야 하고 리포팅 또한 Active하지 못한(?) 아쉬운 점이 있었다. )
지금부터 Jenkins + github web-hook + SonarQube 를 구성하여 코드를 수정하고 PullRequest를 올리게 되면 수정한 파일에 대해 자동으로 정적분석이 이뤄지고, 그에대한 리포팅이 해당 PullRequest에 댓글로 달리도록 설정을 해보겠다. (코드리뷰를 봇(?)이 자동으로 해주는게 얼마나 편한 일인가&mldr;)
기본 컨셉 전체적인 컨셉은 다음 그림과 같다.
전체 컨셉&#34; 전체 컨셉   IDE에서 코드수정을 하고 remote 저장소에 commit & push를 한다. 그 다음 github에서 master(혹은 stable한 branch)에 대해 작업 branch를 PullRequest 올린다. 미리 등록한 github의 web-hook에 의해 PullRequest 정보들을 jenkins에 전송한다. 전달받은 정보를 재 가공하여 SonarQube로 정적분석을 요청한다. SonarQube에서 분석한 정보를 다시 jenkins로 return 해준다. SonarQube으로부터 return 받은 정보를 해당 PullRequest의 댓글에 리포팅을 해준다.  간단히 보면 (뭐 간단하니 쉽네~) 라고 볼수도 있겠지만 나는 이런 전체 흐름을 설정하는데 있어 어려웠다.
 사실 셋팅하는 과정에서 적지않은 삽질을 했었기에, 이 포스팅을 적는 이유일수도 있겠다. 더불어 검색을 해봐도 이렇게 전체흐름이 정리된 글이 잘 안보여서 + 내가 한 삽질을 다른 누군가도 할것같아서(?)
 Maven 설치 기본적으로 Maven의 H2DB를 사용하므로 SonarQube를 설치하기전에 Maven부터 설치해줘야 한다.
$ wget http://apache.mirror.cdnetworks.com/maven/maven-3/3.5.2/binaries/apache-maven-3.5.2-bin.tar.gz $ tar -zxvf apache-maven-3.5.2-bin.tar.gz (환경변수 셋팅후 ) $ mvn -version Apache Maven 3.5.2 (138edd61fd100ec658bfa2d307c43b76940a5d7d; 2017-10-18T16:58:13+09:00) ... SonarQube 설치 정적분석을 도와주는 SonarQube를 설치해보자.
$ wget https://sonarsource.bintray.com/Distribution/sonarqube/sonarqube-6.7.1.zip $ unzip sonarqube-6.7.1.zip $ cd sonarqube-6.7.1/bin/linux-x86-64 $ ./sonar.sh start Starting SonarQube... Started SonarQube. 기본적으로 9000포트를 사용하고 있으니 다른포트를 사용하고자 한다면 /sonarqube-6.7.1/conf/sonar.properties 내 sonar.web.port=9000 을 수정해주면 된다. (SonarQube도 Elasticsearch를 사용하구나&mldr;) 설치후 실행을 한뒤 서버IP:9000을 접속해보면 아래 화면처럼 나온다. (혹시 접속이 안된다거나 서버가 실행이 안된다면 ./sonar.sh console로 로그를 보면 문제해결에 도움이 될수도 있다. )
SonarQube 메인화면&#34; SonarQube 메인화면  SonarQube Scanner 설치 소스를 연동시켜 정적분석을 하기 위해서는 SonarQube Scanner 라는게 필요하다고 한다. 아래 url에서 다운받아 적절한 곳에 압축을 풀어두자. https://docs.sonarqube.org/display/SCAN/Analyzing+with+SonarQube+Scanner
$ wget https://sonarsource.bintray.com/Distribution/sonar-scanner-cli/sonar-scanner-cli-3.0.3.778-linux.zip $ unzip sonar-scanner-cli-3.0.3.778-linux.zip # jenkins 설치 및 SonarQube 연동 jenkins 설치는 간단하니 별도 언급은 안하고 넘어가&mldr;려고 했으나, 하나부터 열까지 정리한다는 마음으로~ https://jenkins.io/download/ 에서 최신버전을 tomcat/webapps/ 아래에 다운받고 server.xml 을 적절하게 수정해준다.
$ wget http://mirrors.jenkins.io/war-stable/latest/jenkins.war $ vi tomcat/conf/server.xml <Connector port=&#34;19001&#34; protocol=&#34;HTTP/1.1&#34; # 포트 변경 <Context path=&#34;/jenkins&#34; debug=&#34;0&#34; privileged=&#34;true&#34; docBase=&#34;jenkins.war&#34; /> #추가 # tomcat/bin/startup.sh jenkins 설치를 완료 한 후 필요한 플러그인을 추가로 설치해준다.
 Python Plugin GitHub Pull Request Builder GitHub plugin  접속 : 서버IP:19001 (참고로 한 서버에서 다 설치하다보니 port 충돌을 신경쓰게되었다. ) 처음 jenkins를 실행하면 이런저런 설정을 하는데 특별한 설정 변경없이 next버튼을 연신 눌러면 설치가 완료 되고, SonarQube를 사용하기 위해 SonarQube Scanner for Jenkins라는 플러그인을 설치해주자."><meta property="og:type" content="article"><meta property="og:url" content="https://taetaetae.github.io/2018/02/08/jenkins-sonar-github-integration/"><meta property="og:image" content="https://taetaetae.github.io/images/jenkins-sonar-github-integration/concept.png"><meta property="article:published_time" content="2018-02-08T20:10:54+00:00"><meta property="article:modified_time" content="2018-02-08T20:10:54+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://taetaetae.github.io/images/jenkins-sonar-github-integration/concept.png"><meta name=twitter:title content="소나큐브 이용 코드 정적분석 자동화"><meta name=twitter:description content="코드 정적분석이라 함은 실제 프로그램을 실행하지 않고 코드만의 형태에 대한 분석을 말한다. 이를테면 냄새나는 코드(?)라던지, 위험성이 있는 코드, 미리 정의된 규칙이나 코딩 표준을 준수하는지에 대한 분석을 말하는데 java 기준으로는 아래 다양한 (잘 알려진) 정적분석 도구들이 있다. PMD  미사용 변수, 비어있는 코드 블락, 불필요한 오브젝트 생성과 같은 Defect을 유발할 수 있는 코드를 검사 https://pmd.github.io   FindBugs  정해진 규칙에 의해 잠재적인 에러 타입을 찾아줌 http://findbugs.sourceforge.net   CheckStyle  정해진 코딩 룰을 잘 따르고 있는지에 대한 분석 http://checkstyle.sourceforge.net    이외에 SonarQube 라는 툴이 있는데 개인적으로 위 알려진 다른 툴들의 종합판(?)이라고 생각이 들었고, 그중 가장 인상깊었던 기능이 github과 연동이 되고 적절한 구성을 하게 되면 코드를 수정하는과 동시에 자동으로 분석을 하고 리포팅까지 해준다는 부분이였다. ( 더 좋은 방법이 있는지는 모르겠으나 다른 도구들은 수동으로 돌려줘야 하고 리포팅 또한 Active하지 못한(?) 아쉬운 점이 있었다. )
지금부터 Jenkins + github web-hook + SonarQube 를 구성하여 코드를 수정하고 PullRequest를 올리게 되면 수정한 파일에 대해 자동으로 정적분석이 이뤄지고, 그에대한 리포팅이 해당 PullRequest에 댓글로 달리도록 설정을 해보겠다. (코드리뷰를 봇(?)이 자동으로 해주는게 얼마나 편한 일인가&mldr;)
기본 컨셉 전체적인 컨셉은 다음 그림과 같다.
전체 컨셉&#34; 전체 컨셉   IDE에서 코드수정을 하고 remote 저장소에 commit & push를 한다. 그 다음 github에서 master(혹은 stable한 branch)에 대해 작업 branch를 PullRequest 올린다. 미리 등록한 github의 web-hook에 의해 PullRequest 정보들을 jenkins에 전송한다. 전달받은 정보를 재 가공하여 SonarQube로 정적분석을 요청한다. SonarQube에서 분석한 정보를 다시 jenkins로 return 해준다. SonarQube으로부터 return 받은 정보를 해당 PullRequest의 댓글에 리포팅을 해준다.  간단히 보면 (뭐 간단하니 쉽네~) 라고 볼수도 있겠지만 나는 이런 전체 흐름을 설정하는데 있어 어려웠다.
 사실 셋팅하는 과정에서 적지않은 삽질을 했었기에, 이 포스팅을 적는 이유일수도 있겠다. 더불어 검색을 해봐도 이렇게 전체흐름이 정리된 글이 잘 안보여서 + 내가 한 삽질을 다른 누군가도 할것같아서(?)
 Maven 설치 기본적으로 Maven의 H2DB를 사용하므로 SonarQube를 설치하기전에 Maven부터 설치해줘야 한다.
$ wget http://apache.mirror.cdnetworks.com/maven/maven-3/3.5.2/binaries/apache-maven-3.5.2-bin.tar.gz $ tar -zxvf apache-maven-3.5.2-bin.tar.gz (환경변수 셋팅후 ) $ mvn -version Apache Maven 3.5.2 (138edd61fd100ec658bfa2d307c43b76940a5d7d; 2017-10-18T16:58:13+09:00) ... SonarQube 설치 정적분석을 도와주는 SonarQube를 설치해보자.
$ wget https://sonarsource.bintray.com/Distribution/sonarqube/sonarqube-6.7.1.zip $ unzip sonarqube-6.7.1.zip $ cd sonarqube-6.7.1/bin/linux-x86-64 $ ./sonar.sh start Starting SonarQube... Started SonarQube. 기본적으로 9000포트를 사용하고 있으니 다른포트를 사용하고자 한다면 /sonarqube-6.7.1/conf/sonar.properties 내 sonar.web.port=9000 을 수정해주면 된다. (SonarQube도 Elasticsearch를 사용하구나&mldr;) 설치후 실행을 한뒤 서버IP:9000을 접속해보면 아래 화면처럼 나온다. (혹시 접속이 안된다거나 서버가 실행이 안된다면 ./sonar.sh console로 로그를 보면 문제해결에 도움이 될수도 있다. )
SonarQube 메인화면&#34; SonarQube 메인화면  SonarQube Scanner 설치 소스를 연동시켜 정적분석을 하기 위해서는 SonarQube Scanner 라는게 필요하다고 한다. 아래 url에서 다운받아 적절한 곳에 압축을 풀어두자. https://docs.sonarqube.org/display/SCAN/Analyzing+with+SonarQube+Scanner
$ wget https://sonarsource.bintray.com/Distribution/sonar-scanner-cli/sonar-scanner-cli-3.0.3.778-linux.zip $ unzip sonar-scanner-cli-3.0.3.778-linux.zip # jenkins 설치 및 SonarQube 연동 jenkins 설치는 간단하니 별도 언급은 안하고 넘어가&mldr;려고 했으나, 하나부터 열까지 정리한다는 마음으로~ https://jenkins.io/download/ 에서 최신버전을 tomcat/webapps/ 아래에 다운받고 server.xml 을 적절하게 수정해준다.
$ wget http://mirrors.jenkins.io/war-stable/latest/jenkins.war $ vi tomcat/conf/server.xml <Connector port=&#34;19001&#34; protocol=&#34;HTTP/1.1&#34; # 포트 변경 <Context path=&#34;/jenkins&#34; debug=&#34;0&#34; privileged=&#34;true&#34; docBase=&#34;jenkins.war&#34; /> #추가 # tomcat/bin/startup.sh jenkins 설치를 완료 한 후 필요한 플러그인을 추가로 설치해준다.
 Python Plugin GitHub Pull Request Builder GitHub plugin  접속 : 서버IP:19001 (참고로 한 서버에서 다 설치하다보니 port 충돌을 신경쓰게되었다. ) 처음 jenkins를 실행하면 이런저런 설정을 하는데 특별한 설정 변경없이 next버튼을 연신 눌러면 설치가 완료 되고, SonarQube를 사용하기 위해 SonarQube Scanner for Jenkins라는 플러그인을 설치해주자."><meta name=application-name content="👨‍💻꿈꾸는 태태태의 공간"><meta name=apple-mobile-web-app-title content="👨‍💻꿈꾸는 태태태의 공간"><meta name=naver-site-verification content="2d1cdbb963ba178aa7cbf58500afc668cae1e645"><meta name=google-site-verification content="vvFCdv0-GuQhEWG8vtNJfA7YSY2HYQ1hpHh9P-a6Pv8"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://taetaetae.github.io/2018/02/08/jenkins-sonar-github-integration/><link rel=prev href=https://taetaetae.github.io/2018/02/08/github-web-hook-jenkins-job-excute/><link rel=next href=https://taetaetae.github.io/2018/03/17/rest-client-exception/><link rel=stylesheet href=/lib/normalize/normalize.min.css><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=/lib/fontawesome-free/all.min.css><link rel=stylesheet href=/lib/animate/animate.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"소나큐브 이용 코드 정적분석 자동화","inLanguage":"en","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/taetaetae.github.io\/2018\/02\/08\/jenkins-sonar-github-integration\/"},"genre":"posts","keywords":"SonarQube, jenkins, github, integration, archives-2018","wordcount":1167,"url":"https:\/\/taetaetae.github.io\/2018\/02\/08\/jenkins-sonar-github-integration\/","datePublished":"2018-02-08T20:10:54+00:00","dateModified":"2018-02-08T20:10:54+00:00","publisher":{"@type":"Organization","name":"태태태"},"author":{"@type":"Person","name":"태태태"},"description":""}</script></head><body header-desktop=auto header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem('theme')?localStorage.getItem('theme')==='dark':('auto'==='auto'?window.matchMedia('(prefers-color-scheme: dark)').matches:'auto'==='dark'))&&document.body.setAttribute('theme','dark');</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title="👨‍💻꿈꾸는 태태태의 공간">👨‍💻꿈꾸는 태태태의 공간</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/>Posts </a><a class=menu-item href=/tags/>Tags </a><a class=menu-item href=/categories/>Categories </a><span class="menu-item delimiter"></span><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme"><i class="fas fa-adjust fa-fw"></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title="👨‍💻꿈꾸는 태태태의 공간">👨‍💻꿈꾸는 태태태의 공간</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><a class=menu-item href=/posts/>Posts</a><a class=menu-item href=/tags/>Tags</a><a class=menu-item href=/categories/>Categories</a><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme">
<i class="fas fa-adjust fa-fw"></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>Contents</h2><div class=toc-content id=toc-content-auto></div><script async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script><ins class=adsbygoogle style=display:inline-block;width:260px;height:600px data-ad-client=ca-pub-5788330009690816 data-ad-slot=2248955907></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({});</script></div><article class="page single"><h1 class="single-title animated flipInX">소나큐브 이용 코드 정적분석 자동화</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=https://taetaetae.github.io/resume title=Author target=_blank rel="noopener noreffer author" class=author><i class="fas fa-user-circle fa-fw"></i>태태태</a></span>&nbsp;<span class=post-category>included in <a href=/categories/tech/><i class="far fa-folder fa-fw"></i>Tech</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime=2018-02-08>2018-02-08</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;1167 words&nbsp;
<i class="far fa-clock fa-fw"></i>&nbsp;6 minutes&nbsp;</div></div><div class="details toc" id=toc-static kept><div class="details-summary toc-title"><span>Contents</span>
<span><i class="details-icon fas fa-angle-right"></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#기본-컨셉>기본 컨셉</a></li><li><a href=#maven-설치>Maven 설치</a></li><li><a href=#sonarqube-설치>SonarQube 설치</a></li><li><a href=#sonarqube-scanner-설치>SonarQube Scanner 설치</a><ul><li><a href=#-jenkins-설치-및-sonarqube-연동># jenkins 설치 및 SonarQube 연동</a></li></ul></li><li><a href=#github과-jenkins-연동>Github과 Jenkins 연동</a></li><li><a href=#jenkins-job-등록>Jenkins job 등록</a><ul><li><a href=#1번-job>1번 job</a></li><li><a href=#2번-job>2번 job</a></li></ul></li><li><a href=#마치며>마치며</a></li></ul></nav></div></div><div class=content id=content><script src=https://ads-partners.coupang.com/g.js></script><script>new PartnersCoupang.G({"id":195296,"trackingCode":"AF5596407","subId":null,"template":"carousel","width":"680","height":"140"});</script><p><code>코드 정적분석</code>이라 함은 실제 프로그램을 실행하지 않고 코드만의 형태에 대한 분석을 말한다. 이를테면 냄새나는 코드(?)라던지, 위험성이 있는 코드, 미리 정의된 규칙이나 코딩 표준을 준수하는지에 대한 분석을 말하는데 java 기준으로는 아래 다양한 (잘 알려진) 정적분석 도구들이 있다.</p><ul><li>PMD<ul><li>미사용 변수, 비어있는 코드 블락, 불필요한 오브젝트 생성과 같은 Defect을 유발할 수 있는 코드를 검사</li><li><a href=https://pmd.github.io>https://pmd.github.io</a></li></ul></li><li>FindBugs<ul><li>정해진 규칙에 의해 잠재적인 에러 타입을 찾아줌</li><li><a href=http://findbugs.sourceforge.net>http://findbugs.sourceforge.net</a></li></ul></li><li>CheckStyle<ul><li>정해진 코딩 룰을 잘 따르고 있는지에 대한 분석</li><li><a href=http://checkstyle.sourceforge.net>http://checkstyle.sourceforge.net</a></li></ul></li></ul><p>이외에 <code>SonarQube</code> 라는 툴이 있는데 개인적으로 위 알려진 다른 툴들의 종합판(?)이라고 생각이 들었고, 그중 가장 인상깊었던 기능이 github과 연동이 되고 적절한 구성을 하게 되면 코드를 수정하는과 동시에 자동으로 분석을 하고 리포팅까지 해준다는 부분이였다. ( <del>더 좋은 방법이 있는지는 모르겠으나</del> 다른 도구들은 수동으로 돌려줘야 하고 리포팅 또한 Active하지 못한(?) 아쉬운 점이 있었다. )</p><p>지금부터 Jenkins + github web-hook + SonarQube 를 구성하여 코드를 수정하고 PullRequest를 올리게 되면 수정한 파일에 대해 자동으로 정적분석이 이뤄지고, 그에대한 리포팅이 해당 PullRequest에 댓글로 달리도록 설정을 해보겠다. (코드리뷰를 봇(?)이 자동으로 해주는게 얼마나 편한 일인가&mldr;)</p><h2 id=기본-컨셉>기본 컨셉</h2><p>전체적인 컨셉은 다음 그림과 같다.</p><figure><a class=lightgallery href=/images/jenkins-sonar-github-integration/concept.png title=/images/jenkins-sonar-github-integration/concept.png data-thumbnail=/images/jenkins-sonar-github-integration/concept.png data-sub-html="<h2>전체 컨셉</h2>"><img class=lazyload src=/svg/loading.min.svg data-src=/images/jenkins-sonar-github-integration/concept.png data-srcset="/images/jenkins-sonar-github-integration/concept.png, /images/jenkins-sonar-github-integration/concept.png 1.5x, /images/jenkins-sonar-github-integration/concept.png 2x" data-sizes=auto alt=/images/jenkins-sonar-github-integration/concept.png></a><figcaption class=image-caption>전체 컨셉</figcaption></figure><ol><li>IDE에서 코드수정을 하고 remote 저장소에 commit & push를 한다.
그 다음 github에서 master(혹은 stable한 branch)에 대해 작업 branch를 PullRequest 올린다.</li><li>미리 등록한 github의 web-hook에 의해 PullRequest 정보들을 jenkins에 전송한다.</li><li>전달받은 정보를 재 가공하여 SonarQube로 정적분석을 요청한다.</li><li>SonarQube에서 분석한 정보를 다시 jenkins로 return 해준다.</li><li>SonarQube으로부터 return 받은 정보를 해당 PullRequest의 댓글에 리포팅을 해준다.</li></ol><p>간단히 보면 (뭐 간단하니 쉽네~) 라고 볼수도 있겠지만 나는 이런 전체 흐름을 설정하는데 있어 어려웠다.</p><blockquote><p>사실 셋팅하는 과정에서 적지않은 삽질을 했었기에, 이 포스팅을 적는 이유일수도 있겠다.
더불어 검색을 해봐도 이렇게 전체흐름이 정리된 글이 잘 안보여서 + 내가 한 삽질을 다른 누군가도 할것같아서(?)</p></blockquote><h2 id=maven-설치>Maven 설치</h2><p>기본적으로 Maven의 H2DB를 사용하므로 SonarQube를 설치하기전에 Maven부터 설치해줘야 한다.</p><pre><code>$ wget http://apache.mirror.cdnetworks.com/maven/maven-3/3.5.2/binaries/apache-maven-3.5.2-bin.tar.gz
$ tar -zxvf apache-maven-3.5.2-bin.tar.gz
(환경변수 셋팅후 )
$  mvn -version
Apache Maven 3.5.2 (138edd61fd100ec658bfa2d307c43b76940a5d7d; 2017-10-18T16:58:13+09:00)
...
</code></pre><h2 id=sonarqube-설치>SonarQube 설치</h2><p>정적분석을 도와주는 SonarQube를 설치해보자.</p><pre><code>$ wget https://sonarsource.bintray.com/Distribution/sonarqube/sonarqube-6.7.1.zip
$ unzip sonarqube-6.7.1.zip
$ cd sonarqube-6.7.1/bin/linux-x86-64
$ ./sonar.sh start
Starting SonarQube...
Started SonarQube.
</code></pre><p>기본적으로 9000포트를 사용하고 있으니 다른포트를 사용하고자 한다면 /sonarqube-6.7.1/conf/sonar.properties 내 <code>sonar.web.port=9000</code> 을 수정해주면 된다. (SonarQube도 Elasticsearch를 사용하구나&mldr;)
설치후 실행을 한뒤 <code>서버IP:9000</code>을 접속해보면 아래 화면처럼 나온다. (혹시 접속이 안된다거나 서버가 실행이 안된다면 <code>./sonar.sh console</code>로 로그를 보면 문제해결에 도움이 될수도 있다. )</p><figure><a class=lightgallery href=/images/jenkins-sonar-github-integration/sonar_main.png title=/images/jenkins-sonar-github-integration/sonar_main.png data-thumbnail=/images/jenkins-sonar-github-integration/sonar_main.png data-sub-html="<h2>SonarQube 메인화면</h2>"><img class=lazyload src=/svg/loading.min.svg data-src=/images/jenkins-sonar-github-integration/sonar_main.png data-srcset="/images/jenkins-sonar-github-integration/sonar_main.png, /images/jenkins-sonar-github-integration/sonar_main.png 1.5x, /images/jenkins-sonar-github-integration/sonar_main.png 2x" data-sizes=auto alt=/images/jenkins-sonar-github-integration/sonar_main.png></a><figcaption class=image-caption>SonarQube 메인화면</figcaption></figure><h2 id=sonarqube-scanner-설치>SonarQube Scanner 설치</h2><p>소스를 연동시켜 정적분석을 하기 위해서는 SonarQube Scanner 라는게 필요하다고 한다. 아래 url에서 다운받아 적절한 곳에 압축을 풀어두자.
<a href=https://docs.sonarqube.org/display/SCAN/Analyzing+with+SonarQube+Scanner>https://docs.sonarqube.org/display/SCAN/Analyzing+with+SonarQube+Scanner</a></p><pre><code>$ wget https://sonarsource.bintray.com/Distribution/sonar-scanner-cli/sonar-scanner-cli-3.0.3.778-linux.zip
$ unzip sonar-scanner-cli-3.0.3.778-linux.zip
</code></pre><h3 id=-jenkins-설치-및-sonarqube-연동># jenkins 설치 및 SonarQube 연동</h3><p>jenkins 설치는 간단하니 별도 언급은 안하고 넘어가&mldr;려고 했으나, 하나부터 열까지 정리한다는 마음으로~
<a href=https://jenkins.io/download/>https://jenkins.io/download/</a> 에서 최신버전을 tomcat/webapps/ 아래에 다운받고 server.xml 을 적절하게 수정해준다.</p><pre><code>$ wget http://mirrors.jenkins.io/war-stable/latest/jenkins.war
$ vi tomcat/conf/server.xml
&lt;Connector port=&quot;19001&quot; protocol=&quot;HTTP/1.1&quot; # 포트 변경
&lt;Context path=&quot;/jenkins&quot; debug=&quot;0&quot; privileged=&quot;true&quot; docBase=&quot;jenkins.war&quot; /&gt; #추가
# tomcat/bin/startup.sh
</code></pre><p>jenkins 설치를 완료 한 후 필요한 플러그인을 추가로 설치해준다.</p><ul><li>Python Plugin</li><li>GitHub Pull Request Builder</li><li>GitHub plugin</li></ul><p>접속 : <code>서버IP:19001</code> (참고로 한 서버에서 다 설치하다보니 port 충돌을 신경쓰게되었다. )
처음 jenkins를 실행하면 이런저런 설정을 하는데 특별한 설정 변경없이 next버튼을 연신 눌러면 설치가 완료 되고, SonarQube를 사용하기 위해 <code>SonarQube Scanner for Jenkins</code>라는 플러그인을 설치해주자. (이건 각 버전마다 궁합(?)이 안맞을수도 있으니 확인이 필요할수도 있다. 내가 설치한 버전은 jenkins 2.89, SonarQube Plugin 2.6.1이다.)
설치를 하면 jenkins > configure 에서 <code>SonarQube servers</code>정보를 등록해준다.</p><figure><a class=lightgallery href=/images/jenkins-sonar-github-integration/jenkins_sonarqube_config.png title=/images/jenkins-sonar-github-integration/jenkins_sonarqube_config.png data-thumbnail=/images/jenkins-sonar-github-integration/jenkins_sonarqube_config.png data-sub-html="<h2>SonarQube 젠킨스 설정</h2>"><img class=lazyload src=/svg/loading.min.svg data-src=/images/jenkins-sonar-github-integration/jenkins_sonarqube_config.png data-srcset="/images/jenkins-sonar-github-integration/jenkins_sonarqube_config.png, /images/jenkins-sonar-github-integration/jenkins_sonarqube_config.png 1.5x, /images/jenkins-sonar-github-integration/jenkins_sonarqube_config.png 2x" data-sizes=auto alt=/images/jenkins-sonar-github-integration/jenkins_sonarqube_config.png></a><figcaption class=image-caption>SonarQube 젠킨스 설정</figcaption></figure><p>authentication token 은 SonarQube에 처음 접속했을때 아래화면을 볼수 있는데, 여기서 authentication token을 발급받을수 있다. 또한 language 와 build 방법을 선택하자. (이부분은 나중에 변경이 가능하니 개발상황에 맞춰서 설정하면 될듯하다.)</p><figure><a class=lightgallery href=/images/jenkins-sonar-github-integration/authentication.png title=/images/jenkins-sonar-github-integration/authentication.png data-thumbnail=/images/jenkins-sonar-github-integration/authentication.png data-sub-html="<h2>authentication token 발급</h2>"><img class=lazyload src=/svg/loading.min.svg data-src=/images/jenkins-sonar-github-integration/authentication.png data-srcset="/images/jenkins-sonar-github-integration/authentication.png, /images/jenkins-sonar-github-integration/authentication.png 1.5x, /images/jenkins-sonar-github-integration/authentication.png 2x" data-sizes=auto alt=/images/jenkins-sonar-github-integration/authentication.png></a><figcaption class=image-caption>authentication token 발급</figcaption></figure><p>그 다음 jenkins > configureTools 에서 SonarQube scanner 정보를 다음 화면과 같이 등록해준다.</p><figure><a class=lightgallery href=/images/jenkins-sonar-github-integration/jenkins_sonarqube_scanner.png title=/images/jenkins-sonar-github-integration/jenkins_sonarqube_scanner.png data-thumbnail=/images/jenkins-sonar-github-integration/jenkins_sonarqube_scanner.png data-sub-html="<h2>SonarQube scanner 젠킨스 설정</h2>"><img class=lazyload src=/svg/loading.min.svg data-src=/images/jenkins-sonar-github-integration/jenkins_sonarqube_scanner.png data-srcset="/images/jenkins-sonar-github-integration/jenkins_sonarqube_scanner.png, /images/jenkins-sonar-github-integration/jenkins_sonarqube_scanner.png 1.5x, /images/jenkins-sonar-github-integration/jenkins_sonarqube_scanner.png 2x" data-sizes=auto alt=/images/jenkins-sonar-github-integration/jenkins_sonarqube_scanner.png></a><figcaption class=image-caption>SonarQube scanner 젠킨스 설정</figcaption></figure><p>우선 여기까지 하면 jenkins 와 SonarQube 연동은 된걸로 보면 된다.</p><h2 id=github과-jenkins-연동>Github과 Jenkins 연동</h2><p>앞서 설명한 전체 컨셉 그림과 같이 github 에 pullRequest가 발생하면 web-hook을 이용하여 jenkins로 정보를 전달하는 방식인데, 이럴려면 우선 github과 jenkins가 연동이된 상태여야 한다. 관련 방법은 아래 링크에 정리를 해놨으니 참고해도 좋을듯 하다.</p><blockquote><p><a href=/2018/02/08/github-with-jenkins rel>Github과 Jenkins 연동하기</a></p></blockquote><h2 id=jenkins-job-등록>Jenkins job 등록</h2><p>Jenkins job은 두개를 만들어 줘야 한다.</p><ul><li>1번 job <code>pullrequest_receiver</code> : github으로부터 web-hook을 통해 pullRequest정보를 받는 job</li><li>2번 job <code>sonaqube-job</code> : 1번 job으로 부터 정보를 받아 SonarQube를 이용해 정적분석후 해당 pullRequest에 댓글로 리포팅 하는 Job</li></ul><h3 id=1번-job>1번 job</h3><p>편의상 job 이름은 <code>pullrequest_receiver</code>으로 정하였고, 매개변수로 <code>String Parameter</code>에 이름은 <code>payload</code>라 정하였다. 그리고 Build 에서 Execute Python 으로 아래 코드를 실행하도록 하였다.</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=kn>import</span>  <span class=nn>os</span><span class=o>,</span> <span class=nn>json</span><span class=o>,</span> <span class=nn>sys</span><span class=o>,</span> <span class=nn>requests</span>

<span class=n>url</span> <span class=o>=</span> <span class=s1>&#39;http://~~~/jenkins/job/sonaqube-job&#39;</span>
<span class=n>hookData</span> <span class=o>=</span> <span class=n>json</span><span class=o>.</span><span class=n>loads</span><span class=p>(</span><span class=n>os</span><span class=o>.</span><span class=n>environ</span><span class=p>[</span><span class=s1>&#39;payload&#39;</span><span class=p>])</span>
<span class=n>branch</span> <span class=o>=</span> <span class=n>hookData</span><span class=p>[</span><span class=s1>&#39;pull_request&#39;</span><span class=p>][</span><span class=s1>&#39;head&#39;</span><span class=p>][</span><span class=s1>&#39;ref&#39;</span><span class=p>];</span>
<span class=n>prId</span> <span class=o>=</span> <span class=n>hookData</span><span class=p>[</span><span class=s1>&#39;pull_request&#39;</span><span class=p>][</span><span class=s1>&#39;number&#39;</span><span class=p>];</span>
<span class=n>componentName</span> <span class=o>=</span> <span class=n>hookData</span><span class=p>[</span><span class=s1>&#39;repository&#39;</span><span class=p>][</span><span class=s1>&#39;name&#39;</span><span class=p>];</span>

<span class=k>if</span> <span class=n>action</span> <span class=o>==</span> <span class=s1>&#39;closed&#39;</span> <span class=ow>or</span> <span class=n>action</span> <span class=o>==</span> <span class=s1>&#39;synchronize&#39;</span> <span class=ow>or</span> <span class=n>action</span> <span class=o>==</span> <span class=s1>&#39;assigned&#39;</span> <span class=p>:</span> <span class=c1># 이 부분은 적절하게 수정이 필요하다.</span>
  <span class=n>sys</span><span class=o>.</span><span class=n>exit</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>

<span class=n>repository</span> <span class=o>=</span> <span class=n>hookData</span><span class=p>[</span><span class=s1>&#39;repository&#39;</span><span class=p>][</span><span class=s1>&#39;full_name&#39;</span><span class=p>]</span>

<span class=n>url</span> <span class=o>=</span> <span class=n>url</span> <span class=o>+</span> <span class=s1>&#39;/buildWithParameters?branch=&#39;</span> <span class=o>+</span> <span class=n>branch</span> <span class=o>+</span> <span class=s1>&#39;&amp;pr=&#39;</span> <span class=o>+</span> <span class=nb>str</span><span class=p>(</span><span class=n>prId</span><span class=p>)</span> <span class=o>+</span> <span class=s1>&#39;&amp;repository=&#39;</span> <span class=o>+</span> <span class=n>repository</span> <span class=o>+</span> <span class=s1>&#39;&amp;componentName=&#39;</span> <span class=o>+</span> <span class=n>componentName</span>

<span class=n>response</span> <span class=o>=</span> <span class=n>requests</span><span class=o>.</span><span class=n>post</span><span class=p>(</span><span class=n>url</span><span class=p>)</span>
</code></pre></div><p>WebHook을 이용해서 Jenkins Job을 실행시키는 과정은 아래 링크에 별도로 정리해놨으니 참고해도 좋을듯 하다.</p><blockquote><p><a href=/2018/02/08/github-web-hook-jenkins-job-excute rel>Github의 WebHook을 이용하여 자동 Jenkins Job 실행</a></p></blockquote><p>위와 같이 설정을 하고 pullRequest가 발생을 하면 해당 Job이 실행이 되면서 정보들을 적절하게 조합하여 2번 job으로 보내게 된다. 여기서 job을 하나로 나누지 않고 <code>github정보를 받는 job</code>, <code>SonarQube 분석 job</code> 이렇게 두개로 나눈 이유는 여러 Repository에 대해서 셋팅을 하고 싶은경우 Repository에서는 <code>1번 job</code>으로 쏘게 하고 <code>1번 job</code>내부에서 payload의 정보를 분석하여 Repository별 SonarQube 분석 job url로 보내면 되기 때문이다. 1번 job 은 하나, 2번 job은 Repository 별로 분기 되는 구조.</p><h3 id=2번-job>2번 job</h3><p>SonarQube job을 작성할 차례다. 1번 job에서 파라미터를 보내주기 때문에 역시 2번 job에서도 파라미터를 미리 받도록 설정해주자.</p><ul><li>파라미터 목록<ul><li>pr</li><li>branch</li><li>repository</li><li>componentName</li></ul></li></ul><p>이 job에서는 SonarQube 분석이 되는데, 해당 repo에 대한 접근권한이 있어야 하기 때문에 앞서 설정한 <code>Github과 Jenkins 연동</code> 방법으로 Repository 와 Credentials 을 지정해주고, 브랜치 경로 또한 파라미터로 받은 값으로 지정해 준다.</p><figure><a class=lightgallery href=/images/jenkins-sonar-github-integration/jenkins_config_source.png title=/images/jenkins-sonar-github-integration/jenkins_config_source.png data-thumbnail=/images/jenkins-sonar-github-integration/jenkins_config_source.png data-sub-html="<h2>소스코드 관리 설정</h2>"><img class=lazyload src=/svg/loading.min.svg data-src=/images/jenkins-sonar-github-integration/jenkins_config_source.png data-srcset="/images/jenkins-sonar-github-integration/jenkins_config_source.png, /images/jenkins-sonar-github-integration/jenkins_config_source.png 1.5x, /images/jenkins-sonar-github-integration/jenkins_config_source.png 2x" data-sizes=auto alt=/images/jenkins-sonar-github-integration/jenkins_config_source.png></a><figcaption class=image-caption>소스코드 관리 설정</figcaption></figure><p>마지막으로 최종 목적이였던 SonarQube 분석을 할 차례인데, 이번에 SonarQube가 버전업이 되면서 java 기분 .java 파일만 가지고 하는게 아니라 .java파일을 컴파일 하면 나오는 .class파일 경로를 필수로 지정해줘야 한다고 한다. (예전에는 .class 파일 경로를 지정하지 않아도 되었는데 홈페이지 설명에 의하면 바이너리 파일까지 같이 분석하게 되면 분석 신뢰도가 높아진다고 한다.)
<a href=https://docs.sonarqube.org/display/PLUG/Java+Plugin+and+Bytecode>https://docs.sonarqube.org/display/PLUG/Java+Plugin+and+Bytecode</a></p><blockquote><p>딴 이야기로, 난 여태까지 정적분석이라는건 코드만을 가지고 하는줄 알았다. 자바 기준에서는 .java . 하지만 이번에 SonarQube 설정을 하면서 알게된 부분으로, 정적분석이라는건 맨 위에 적어놨듯 <code>실제 프로그램을 실행하지 않고 코드만의 형태에 대한 분석</code> 이기 때문에 java 기준에서는 .class 파일또한 분석의 대상으로 볼수가 있다. (실제로 구버전 - .java만 분석 / 신버전 - .java + .class 분석 을 해봤더니 불필요한 분석결과(?)가 줄어든것을 알수 있었다. )</p></blockquote><p>그래서 결국 컴파일을 한 뒤에 SonarQube 분석을 하면 되겠다.</p><figure><a class=lightgallery href=/images/jenkins-sonar-github-integration/build_sonarqube_config.png title=/images/jenkins-sonar-github-integration/build_sonarqube_config.png data-thumbnail=/images/jenkins-sonar-github-integration/build_sonarqube_config.png data-sub-html="<h2>빌드 및 SonarQube 분석 설정</h2>"><img class=lazyload src=/svg/loading.min.svg data-src=/images/jenkins-sonar-github-integration/build_sonarqube_config.png data-srcset="/images/jenkins-sonar-github-integration/build_sonarqube_config.png, /images/jenkins-sonar-github-integration/build_sonarqube_config.png 1.5x, /images/jenkins-sonar-github-integration/build_sonarqube_config.png 2x" data-sizes=auto alt=/images/jenkins-sonar-github-integration/build_sonarqube_config.png></a><figcaption class=image-caption>빌드 및 SonarQube 분석 설정</figcaption></figure><p>SonarQube 설정파일은 다음과 같다.</p><pre><code>sonar.projectKey=${componentName} # 유니크한 프로젝트 키 네이밍 값
sonar.projectVersion=0.1
sonar.sourceEncoding=UTF-8 
sonar.analysis.mode=preview 
sonar.github.repository=${repository}
sonar.github.endpoint=https://api.github.co
sonar.github.login= # github login id
sonar.github.oauth= # github 개인키
sonar.login=admin
sonar.password=admin 
sonar.github.pullRequest=${pr}
sonar.host.url= # SonarQube url
sonar.issuesReport.console.enable=true 
sonar.github.disableInlineComments=true
sonar.sources=.
sonar.exclusions=
sonar.java.binaries=target/classes # 빌드 결과물 경로
</code></pre><p>이렇게 긴~~과정을 거치고 나면 pullRequest 를 올릴때마다 아래 그림처럼 수정한 파일에 대해서 자동으로 분석을 하여 알려준다.<figure><a class=lightgallery href=/images/jenkins-sonar-github-integration/sonar_result_report.png title=/images/jenkins-sonar-github-integration/sonar_result_report.png data-thumbnail=/images/jenkins-sonar-github-integration/sonar_result_report.png data-sub-html="<h2>SonarQube 분석결과</h2>"><img class=lazyload src=/svg/loading.min.svg data-src=/images/jenkins-sonar-github-integration/sonar_result_report.png data-srcset="/images/jenkins-sonar-github-integration/sonar_result_report.png, /images/jenkins-sonar-github-integration/sonar_result_report.png 1.5x, /images/jenkins-sonar-github-integration/sonar_result_report.png 2x" data-sizes=auto alt=/images/jenkins-sonar-github-integration/sonar_result_report.png></a><figcaption class=image-caption>SonarQube 분석결과</figcaption></figure></p><p>또한 분석결과에 따라 (이 부분은 SonarQube 설정으로 조정이 가능할것같다) merge 가 가능/불가능이 조정되어 진다.</p><figure><a class=lightgallery href=/images/jenkins-sonar-github-integration/sonar_result.png title=/images/jenkins-sonar-github-integration/sonar_result.png data-thumbnail=/images/jenkins-sonar-github-integration/sonar_result.png data-sub-html="<h2>SonarQube 분석 중 critical 항목이 없어서 merge 가능한 화면</h2>"><img class=lazyload src=/svg/loading.min.svg data-src=/images/jenkins-sonar-github-integration/sonar_result.png data-srcset="/images/jenkins-sonar-github-integration/sonar_result.png, /images/jenkins-sonar-github-integration/sonar_result.png 1.5x, /images/jenkins-sonar-github-integration/sonar_result.png 2x" data-sizes=auto alt=/images/jenkins-sonar-github-integration/sonar_result.png></a><figcaption class=image-caption>SonarQube 분석 중 critical 항목이 없어서 merge 가능한 화면</figcaption></figure><h2 id=마치며>마치며</h2><p>반복적인 일에 대해서 자동화 구성을 한다는것은 참 의미있는 일인것 같다. 팀내 이런 구성을 도입하구서 획기적으로 코드 품질이 나아지진 않았지만 자칫 잘못해서 merge가 되는 위험한 코드들은 어느정도 SonarQube가 잡아주는것 같다. 사족이지만, 이렇게 적고나니 간단한데 이런 구성에 대한 정보를 알기까지는 엄청난 시간이 들었기에&mldr; 오랜만의 포스팅에 대한 뿌듯함을 다시한번 느낀다.</p><script src=https://ads-partners.coupang.com/g.js></script><script>new PartnersCoupang.G({"id":195296,"trackingCode":"AF5596407","subId":null,"template":"carousel","width":"680","height":"140"});</script></div><center><style>.bmc-button img{width:27px!important;margin-bottom:1px!important;box-shadow:none!important;border:none!important;vertical-align:middle!important}.bmc-button{line-height:29px!important;height:30px!important;text-decoration:none!important;display:inline-flex!important;color:#000!important;background-color:#fd0!important;border-radius:3px!important;border:1px solid transparent!important;padding:1px 9px!important;font-size:22px!important;letter-spacing:.6px!important;box-shadow:0 1px 2px rgba(190,190,190,.5)!important;-webkit-box-shadow:0 1px 2px 2px rgba(190,190,190,.5)!important;margin:0 auto!important;font-family:cookie,cursive!important;-webkit-box-sizing:border-box!important;box-sizing:border-box!important;-o-transition:.3s all linear!important;-webkit-transition:.3s all linear!important;-moz-transition:.3s all linear!important;-ms-transition:.3s all linear!important;transition:.3s all linear!important}.bmc-button:hover,.bmc-button:active,.bmc-button:focus{-webkit-box-shadow:0 1px 2px 2px rgba(190,190,190,.5)!important;text-decoration:none!important;box-shadow:0 1px 2px 2px rgba(190,190,190,.5)!important;opacity:.85!important;color:#000!important}</style><link href="https://fonts.googleapis.com/css?family=Cookie" rel=stylesheet><center><br><a class=bmc-button target=_blank href=https://www.buymeacoffee.com/taetaetae><img src=https://www.buymeacoffee.com/assets/img/BMC-btn-logo.svg alt="Buy me a coffee"><span style=margin-left:5px>Buy me a coffee</span></a>
<a href=https://bit.ly/ddbSupport target=_blank><img src=https://i.imgur.com/peaYpjh.png style=height:28px></a></center><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>Updated on 2018-02-08</span></div><div class=post-info-license></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span><a href=javascript:void(0); title="Share on Twitter" data-sharer=twitter data-url=https://taetaetae.github.io/2018/02/08/jenkins-sonar-github-integration/ data-title="소나큐브 이용 코드 정적분석 자동화" data-hashtags=SonarQube,jenkins,github,integration,archives-2018><i class="fab fa-twitter fa-fw"></i></a><a href=javascript:void(0); title="Share on Facebook" data-sharer=facebook data-url=https://taetaetae.github.io/2018/02/08/jenkins-sonar-github-integration/ data-hashtag=SonarQube><i class="fab fa-facebook-square fa-fw"></i></a><a href=javascript:void(0); title="Share on Linkedin" data-sharer=linkedin data-url=https://taetaetae.github.io/2018/02/08/jenkins-sonar-github-integration/><i class="fab fa-linkedin fa-fw"></i></a><a href=javascript:void(0); title="Share on Blogger" data-sharer=blogger data-url=https://taetaetae.github.io/2018/02/08/jenkins-sonar-github-integration/ data-title="소나큐브 이용 코드 정적분석 자동화" data-description><i class="fab fa-blogger fa-fw"></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fas fa-tags fa-fw"></i>&nbsp;<a href=/tags/sonarqube/>SonarQube</a>,&nbsp;<a href=/tags/jenkins/>jenkins</a>,&nbsp;<a href=/tags/github/>github</a>,&nbsp;<a href=/tags/integration/>integration</a>,&nbsp;<a href=/tags/archives-2018/>archives-2018</a></section><section><span><a href=javascript:void(0); onclick=window.history.back();>Back</a></span>&nbsp;|&nbsp;<span><a href=/>Home</a></span></section></div><div class=post-nav><a href=/2018/02/08/github-web-hook-jenkins-job-excute/ class=prev rel=prev title="Github의 WebHook을 이용하여 자동 Jenkins Job 실행"><i class="fas fa-angle-left fa-fw"></i>Github의 WebHook을 이용하여 자동 Jenkins Job 실행</a>
<a href=/2018/03/17/rest-client-exception/ class=next rel=next title="RestClientException 처리">RestClientException 처리<i class="fas fa-angle-right fa-fw"></i></a></div></div><div id=comments><div id=utterances></div><noscript>Please enable JavaScript to view the comments powered by <a href=https://utteranc.es/>Utterances</a>.</noscript></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line>Powered by <a href=https://gohugo.io/ target=_blank rel="noopener noreffer" title="Hugo 0.74.3">Hugo</a> | Theme - <a href=https://github.com/dillonzq/LoveIt target=_blank rel="noopener noreffer" title="LoveIt 0.2.10"><i class="far fa-kiss-wink-heart fa-fw"></i>LoveIt</a></div><div class=footer-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2016 - 2021</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=https://taetaetae.github.io/resume target=_blank>태태태</a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title="Back to Top"><i class="fas fa-arrow-up fa-fw"></i></a><a href=# id=view-comments class=fixed-button title="View Comments"><i class="fas fa-comment fa-fw"></i></a></div><link rel=stylesheet href=/lib/lightgallery/lightgallery.min.css><script type=text/javascript src=/lib/smooth-scroll/smooth-scroll.min.js></script><script type=text/javascript src=/lib/lazysizes/lazysizes.min.js></script><script type=text/javascript src=/lib/lightgallery/lightgallery.min.js></script><script type=text/javascript src=/lib/lightgallery/lg-thumbnail.min.js></script><script type=text/javascript src=/lib/lightgallery/lg-zoom.min.js></script><script type=text/javascript src=/lib/clipboard/clipboard.min.js></script><script type=text/javascript src=/lib/sharer/sharer.min.js></script><script type=text/javascript>window.config={"code":{"copyTitle":"Copy to clipboard","maxShownLines":500},"comment":{"utterances":{"darkTheme":"github-dark","issueTerm":"pathname","label":"Comment","lightTheme":"github-light","repo":"taetaetae/blog-comment"}},"lightGallery":{"actualSize":false,"exThumbImage":"data-thumbnail","hideBarsDelay":2000,"selector":".lightgallery","speed":400,"thumbContHeight":80,"thumbWidth":80,"thumbnail":true}};</script><script type=text/javascript src=/js/theme.min.js></script><script type=text/javascript>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}gtag('js',new Date());gtag('config','UA-86432198-1',{'anonymize_ip':true});</script><script type=text/javascript src="https://www.googletagmanager.com/gtag/js?id=UA-86432198-1" async></script></body></html>