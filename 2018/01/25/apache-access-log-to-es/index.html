<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><meta http-equiv=x-ua-compatible content="IE=edge, chrome=1"><title>아파치 엑세스 로그를 엘라스틱서치에 인덱싱 해보자. - 👨‍💻꿈꾸는 태태태의 공간</title><meta name=Description content><meta property="og:title" content="아파치 엑세스 로그를 엘라스틱서치에 인덱싱 해보자."><meta property="og:description" content="apache access log 를 분석하고 싶은 상황이 생겼다. 아니 그보다 apache access에 대해서 실시간으로 보고싶었고, log를 검색 & 데이터를 가공하여 유의미한 분석결과를 만들어 보고 싶었다. 그에 생각한것이 (역시) ElasticStack.처음에 생각한 방안은 아래 그림처럼 단순했다. 처음 생각한 단순한 구조&#34; 처음 생각한 단순한 구조 
하지만, 내 단순한(?) 예상은 역시 빗나갔고 logstash에서는 다음과 같은 에러를 내뱉었다.
 retrying individual bulk actions that failed or were rejected by the previous bulk request
 request가 많아짐에 따라 elasticsearch가 버벅거리더니 logstash에서 대량작업은 거부하겠다며 인덱싱을 멈췄다. 고민고민하다 elasticsearch에 인덱싱할때 부하가 많이 걸리는 상황에서 중간에 버퍼를 둔 경험이 있어서 facebook그룹에 문의를 해봤다. https://www.facebook.com/groups/elasticsearch.kr/?multi_permalinks=1566735266745641 역시 나보다 한참을 앞서가시는 분들은 이미 에러가 뭔지 알고 있으셨고, 중간에 버퍼를 두고 하니 잘된다는 의견이 있어 나도 따라해봤다. 물론 답변중에 나온 redis가 아닌 기존에도 비슷한 구조에서 사용하고 있던 kafka를 적용. 아, 그전에 현재구성은 Elasticsearch 노드가 총 3대로 클러스터 구조로 되어있는데 노드를 추가로 늘리며 스케일 아웃을 해보기전에 할수있는 마지막 방법이다 생각하고 중간에 kafka를 둬서 부하를 줄여보고 싶었다. (언제부턴가 마치 여러개의 톱니바퀴가 맞물려 돌아가는듯한 시스템 설계를 하는게 재밌었다.) 아래 그림처럼 말이다.
그나마 좀더 생각한 구조&#34; 그나마 좀더 생각한 구조  그랬더니 거짓말 처럼 에러하나 없이 잘 인덱싱이 될수 있었다. logstash가 양쪽에 있는게 약간 걸리긴 하지만, 처음에 생각한 구조보다는 에러가 안나니 다행이라 생각한다.
이 구조를 적용하면서 얻은 Insight가 있기에, 각 항목별로 적어 보고자 한다. ( 이것만 적어놓기엔 너무 없어보여서.. )
access log 를 어떻게 분석하여 인덱싱 할것인가? apache 2.x를 사용하고 별도의 로그 포맷을 정하지 않으면 아래와 같은 access log가 찍힌다. 123.1.1.1 - - [25/Jan/2018:21:55:35 +0900] &#34;GET /api/test?param=12341234 HTTP/1.1&#34; 200 48 1144 &#34;http://www.naver.com/&#34; &#34;Mozilla/5.0 (iPhone; CPU iPhone OS 11_1_2 like Mac OS X) AppleWebKit/604.3.5 (KHTML, like Gecko) Mobile/15B202 NAVER(inapp; blog; 100; 4.0.44)&#34; 그럼 이 로그를 아무 포맷팅 없이 로깅을 하면 그냥 한줄의 텍스트가 인덱싱이 된다. 하지만 이렇게 되면 elasticsearch 데이터를 다시 재가공하거나 별도의 작업이 필요할수도 있으니 중간에 있는 logstash에게 일을 시켜 좀더 nice 한 방법으로 인덱싱을 해보자. 바로 logstash 의 filter 기능이다. 그중 Grok filter 라는게 있는데 패턴을 적용하여 row data 를 필터링하는 기능이다. 조금 찾아보니 너무 고맙게도 아파치 필터 예제가 있어 수정하여 적용할수 있었다. http://grokconstructor.appspot.com/do/match?example=2 그래서 적용한 필터설정은 다음과 같다.
filter { grok { match => { message => &#34;%{IP:clientIp} (?:-|) (?:-|) \[%{HTTPDATE:timestamp}\] \&#34;(?:%{WORD:httpMethod} %{URIPATH:uri}%{GREEDYDATA}(?: HTTP/%{NUMBER})?|-)\&#34; %{NUMBER:responseCode} (?:-|%{NUMBER})&#34; } } } 이렇게 하고 elasticsearch 에 인덱싱을 하면 키바나에서 다음과 같이 볼수 있다. 키바나에 내가 원하는 구조대로 이쁘게 들어가 있는 access log&#34; 키바나에 내가 원하는 구조대로 이쁘게 들어가 있는 access log 
각 필드가 아닌 한줄로 인덱싱이 되어버린다. Elasticsearch 에 인덱싱이 되긴 하는데 로그 한줄이 통째로 들어가 버린다. message라는 이름으로&mldr; 알고보니 현재 구조는 logstash가 kafka 앞 뒤에 있다보니 producer logstash 와 consumer logstash 의 codec이 맞아야 제대로 인덱싱이 될수 있었다. 먼저 access log에서 kafka 로 produce 하는 logstash 에서는 output 할때 codec 을 맞춰주고
output { kafka { bootstrap_servers => &#34;123.1.2.3:9092,123.1.2.4:9092&#34; topic_id => &#34;apache-log&#34; codec => json{} } } kafka 에서 consume 하는 logstash 에서는 input 에서 codec 을 맞춰준다.
input { kafka { bootstrap_servers => &#34;123.1.2.3:9092,123.1.2.4:9092&#34; topic_id => &#34;apache-log&#34; codec => json{} } } 그렇게 되면 codec이 맞아 각 필드로 이쁘게 인덱싱을 할수 있게 되었다.
필요없는 uri는 제외하고 인덱싱할수 있을까? /으로는 uri 라던지 /server-status같이 알고있지만 인덱싱은 하기 싫은 경우는 간단하게 아래처럼 if문으로 제외시킬수 있었다."><meta property="og:type" content="article"><meta property="og:url" content="https://taetaetae.github.io/2018/01/25/apache-access-log-to-es/"><meta property="og:image" content="https://taetaetae.github.io/images/apache-access-log-to-es/model_1.png"><meta property="article:published_time" content="2018-01-25T21:18:35+00:00"><meta property="article:modified_time" content="2018-01-25T21:18:35+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://taetaetae.github.io/images/apache-access-log-to-es/model_1.png"><meta name=twitter:title content="아파치 엑세스 로그를 엘라스틱서치에 인덱싱 해보자."><meta name=twitter:description content="apache access log 를 분석하고 싶은 상황이 생겼다. 아니 그보다 apache access에 대해서 실시간으로 보고싶었고, log를 검색 & 데이터를 가공하여 유의미한 분석결과를 만들어 보고 싶었다. 그에 생각한것이 (역시) ElasticStack.처음에 생각한 방안은 아래 그림처럼 단순했다. 처음 생각한 단순한 구조&#34; 처음 생각한 단순한 구조 
하지만, 내 단순한(?) 예상은 역시 빗나갔고 logstash에서는 다음과 같은 에러를 내뱉었다.
 retrying individual bulk actions that failed or were rejected by the previous bulk request
 request가 많아짐에 따라 elasticsearch가 버벅거리더니 logstash에서 대량작업은 거부하겠다며 인덱싱을 멈췄다. 고민고민하다 elasticsearch에 인덱싱할때 부하가 많이 걸리는 상황에서 중간에 버퍼를 둔 경험이 있어서 facebook그룹에 문의를 해봤다. https://www.facebook.com/groups/elasticsearch.kr/?multi_permalinks=1566735266745641 역시 나보다 한참을 앞서가시는 분들은 이미 에러가 뭔지 알고 있으셨고, 중간에 버퍼를 두고 하니 잘된다는 의견이 있어 나도 따라해봤다. 물론 답변중에 나온 redis가 아닌 기존에도 비슷한 구조에서 사용하고 있던 kafka를 적용. 아, 그전에 현재구성은 Elasticsearch 노드가 총 3대로 클러스터 구조로 되어있는데 노드를 추가로 늘리며 스케일 아웃을 해보기전에 할수있는 마지막 방법이다 생각하고 중간에 kafka를 둬서 부하를 줄여보고 싶었다. (언제부턴가 마치 여러개의 톱니바퀴가 맞물려 돌아가는듯한 시스템 설계를 하는게 재밌었다.) 아래 그림처럼 말이다.
그나마 좀더 생각한 구조&#34; 그나마 좀더 생각한 구조  그랬더니 거짓말 처럼 에러하나 없이 잘 인덱싱이 될수 있었다. logstash가 양쪽에 있는게 약간 걸리긴 하지만, 처음에 생각한 구조보다는 에러가 안나니 다행이라 생각한다.
이 구조를 적용하면서 얻은 Insight가 있기에, 각 항목별로 적어 보고자 한다. ( 이것만 적어놓기엔 너무 없어보여서.. )
access log 를 어떻게 분석하여 인덱싱 할것인가? apache 2.x를 사용하고 별도의 로그 포맷을 정하지 않으면 아래와 같은 access log가 찍힌다. 123.1.1.1 - - [25/Jan/2018:21:55:35 +0900] &#34;GET /api/test?param=12341234 HTTP/1.1&#34; 200 48 1144 &#34;http://www.naver.com/&#34; &#34;Mozilla/5.0 (iPhone; CPU iPhone OS 11_1_2 like Mac OS X) AppleWebKit/604.3.5 (KHTML, like Gecko) Mobile/15B202 NAVER(inapp; blog; 100; 4.0.44)&#34; 그럼 이 로그를 아무 포맷팅 없이 로깅을 하면 그냥 한줄의 텍스트가 인덱싱이 된다. 하지만 이렇게 되면 elasticsearch 데이터를 다시 재가공하거나 별도의 작업이 필요할수도 있으니 중간에 있는 logstash에게 일을 시켜 좀더 nice 한 방법으로 인덱싱을 해보자. 바로 logstash 의 filter 기능이다. 그중 Grok filter 라는게 있는데 패턴을 적용하여 row data 를 필터링하는 기능이다. 조금 찾아보니 너무 고맙게도 아파치 필터 예제가 있어 수정하여 적용할수 있었다. http://grokconstructor.appspot.com/do/match?example=2 그래서 적용한 필터설정은 다음과 같다.
filter { grok { match => { message => &#34;%{IP:clientIp} (?:-|) (?:-|) \[%{HTTPDATE:timestamp}\] \&#34;(?:%{WORD:httpMethod} %{URIPATH:uri}%{GREEDYDATA}(?: HTTP/%{NUMBER})?|-)\&#34; %{NUMBER:responseCode} (?:-|%{NUMBER})&#34; } } } 이렇게 하고 elasticsearch 에 인덱싱을 하면 키바나에서 다음과 같이 볼수 있다. 키바나에 내가 원하는 구조대로 이쁘게 들어가 있는 access log&#34; 키바나에 내가 원하는 구조대로 이쁘게 들어가 있는 access log 
각 필드가 아닌 한줄로 인덱싱이 되어버린다. Elasticsearch 에 인덱싱이 되긴 하는데 로그 한줄이 통째로 들어가 버린다. message라는 이름으로&mldr; 알고보니 현재 구조는 logstash가 kafka 앞 뒤에 있다보니 producer logstash 와 consumer logstash 의 codec이 맞아야 제대로 인덱싱이 될수 있었다. 먼저 access log에서 kafka 로 produce 하는 logstash 에서는 output 할때 codec 을 맞춰주고
output { kafka { bootstrap_servers => &#34;123.1.2.3:9092,123.1.2.4:9092&#34; topic_id => &#34;apache-log&#34; codec => json{} } } kafka 에서 consume 하는 logstash 에서는 input 에서 codec 을 맞춰준다.
input { kafka { bootstrap_servers => &#34;123.1.2.3:9092,123.1.2.4:9092&#34; topic_id => &#34;apache-log&#34; codec => json{} } } 그렇게 되면 codec이 맞아 각 필드로 이쁘게 인덱싱을 할수 있게 되었다.
필요없는 uri는 제외하고 인덱싱할수 있을까? /으로는 uri 라던지 /server-status같이 알고있지만 인덱싱은 하기 싫은 경우는 간단하게 아래처럼 if문으로 제외시킬수 있었다."><meta name=application-name content="👨‍💻꿈꾸는 태태태의 공간"><meta name=apple-mobile-web-app-title content="👨‍💻꿈꾸는 태태태의 공간"><meta name=naver-site-verification content="2d1cdbb963ba178aa7cbf58500afc668cae1e645"><meta name=google-site-verification content="vvFCdv0-GuQhEWG8vtNJfA7YSY2HYQ1hpHh9P-a6Pv8"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://taetaetae.github.io/2018/01/25/apache-access-log-to-es/><link rel=prev href=https://taetaetae.github.io/2018/01/08/python-2-to-3/><link rel=next href=https://taetaetae.github.io/2018/02/01/linux-selenium/><link rel=stylesheet href=/lib/normalize/normalize.min.css><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=/lib/fontawesome-free/all.min.css><link rel=stylesheet href=/lib/animate/animate.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"아파치 엑세스 로그를 엘라스틱서치에 인덱싱 해보자.","inLanguage":"en","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/taetaetae.github.io\/2018\/01\/25\/apache-access-log-to-es\/"},"genre":"posts","keywords":"elasticsearch, logstash, kafka, access log, archives-2018","wordcount":720,"url":"https:\/\/taetaetae.github.io\/2018\/01\/25\/apache-access-log-to-es\/","datePublished":"2018-01-25T21:18:35+00:00","dateModified":"2018-01-25T21:18:35+00:00","publisher":{"@type":"Organization","name":"태태태"},"author":{"@type":"Person","name":"태태태"},"description":""}</script></head><body header-desktop=auto header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem('theme')?localStorage.getItem('theme')==='dark':('auto'==='auto'?window.matchMedia('(prefers-color-scheme: dark)').matches:'auto'==='dark'))&&document.body.setAttribute('theme','dark');</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title="👨‍💻꿈꾸는 태태태의 공간">👨‍💻꿈꾸는 태태태의 공간</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/>Posts </a><a class=menu-item href=/tags/>Tags </a><a class=menu-item href=/categories/>Categories </a><span class="menu-item delimiter"></span><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme"><i class="fas fa-adjust fa-fw"></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title="👨‍💻꿈꾸는 태태태의 공간">👨‍💻꿈꾸는 태태태의 공간</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><a class=menu-item href=/posts/>Posts</a><a class=menu-item href=/tags/>Tags</a><a class=menu-item href=/categories/>Categories</a><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme">
<i class="fas fa-adjust fa-fw"></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>Contents</h2><div class=toc-content id=toc-content-auto></div><script async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script><ins class=adsbygoogle style=display:inline-block;width:260px;height:600px data-ad-client=ca-pub-5788330009690816 data-ad-slot=2248955907></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({});</script></div><article class="page single"><h1 class="single-title animated flipInX">아파치 엑세스 로그를 엘라스틱서치에 인덱싱 해보자.</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=https://taetaetae.github.io/resume title=Author target=_blank rel="noopener noreffer author" class=author><i class="fas fa-user-circle fa-fw"></i>태태태</a></span>&nbsp;<span class=post-category>included in <a href=/categories/tech/><i class="far fa-folder fa-fw"></i>Tech</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime=2018-01-25>2018-01-25</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;720 words&nbsp;
<i class="far fa-clock fa-fw"></i>&nbsp;4 minutes&nbsp;</div></div><div class="details toc" id=toc-static kept><div class="details-summary toc-title"><span>Contents</span>
<span><i class="details-icon fas fa-angle-right"></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#access-log-를-어떻게-분석하여-인덱싱-할것인가>access log 를 어떻게 분석하여 인덱싱 할것인가?</a></li><li><a href=#각-필드가-아닌-한줄로-인덱싱이-되어버린다>각 필드가 아닌 한줄로 인덱싱이 되어버린다.</a></li><li><a href=#필요없는-uri는-제외하고-인덱싱할수-있을까>필요없는 uri는 제외하고 인덱싱할수 있을까?</a></li><li><a href=#하나의-index로는-관리가-힘든데-나눌순-없을까>하나의 index로는 관리가 힘든데 나눌순 없을까?</a></li></ul></nav></div></div><div class=content id=content><p>apache access log 를 분석하고 싶은 상황이 생겼다. 아니 그보다 apache access에 대해서 실시간으로 보고싶었고, log를 검색 & 데이터를 가공하여 유의미한 분석결과를 만들어 보고 싶었다. 그에 생각한것이 (역시) <code>ElasticStack</code>.</p><p>처음에 생각한 방안은 아래 그림처럼 단순했다.<figure><a class=lightgallery href=/images/apache-access-log-to-es/model_1.png title=/images/apache-access-log-to-es/model_1.png data-thumbnail=/images/apache-access-log-to-es/model_1.png data-sub-html="<h2>처음 생각한 단순한 구조</h2>"><img class=lazyload src=/svg/loading.min.svg data-src=/images/apache-access-log-to-es/model_1.png data-srcset="/images/apache-access-log-to-es/model_1.png, /images/apache-access-log-to-es/model_1.png 1.5x, /images/apache-access-log-to-es/model_1.png 2x" data-sizes=auto alt=/images/apache-access-log-to-es/model_1.png></a><figcaption class=image-caption>처음 생각한 단순한 구조</figcaption></figure></p><p>하지만, 내 단순한(?) 예상은 역시 빗나갔고 logstash에서는 다음과 같은 에러를 내뱉었다.</p><blockquote><p>retrying individual bulk actions that failed or were rejected by the previous bulk request</p></blockquote><p>request가 많아짐에 따라 elasticsearch가 버벅거리더니 logstash에서 대량작업은 거부하겠다며 인덱싱을 멈췄다. 고민고민하다 elasticsearch에 인덱싱할때 부하가 많이 걸리는 상황에서 중간에 버퍼를 둔 경험이 있어서 facebook그룹에 문의를 해봤다.
<a href="https://www.facebook.com/groups/elasticsearch.kr/?multi_permalinks=1566735266745641">https://www.facebook.com/groups/elasticsearch.kr/?multi_permalinks=1566735266745641</a>
역시 나보다 한참을 앞서가시는 분들은 이미 에러가 뭔지 알고 있으셨고, 중간에 버퍼를 두고 하니 잘된다는 의견이 있어 나도 따라해봤다. 물론 답변중에 나온 redis가 아닌 기존에도 비슷한 구조에서 사용하고 있던 kafka를 적용.
아, 그전에 현재구성은 Elasticsearch 노드가 총 3대로 클러스터 구조로 되어있는데 노드를 추가로 늘리며 스케일 아웃을 해보기전에 할수있는 마지막 방법이다 생각하고 중간에 kafka를 둬서 부하를 줄여보고 싶었다. (언제부턴가 마치 여러개의 톱니바퀴가 맞물려 돌아가는듯한 시스템 설계를 하는게 재밌었다.) 아래 그림처럼 말이다.</p><figure><a class=lightgallery href=/images/apache-access-log-to-es/model_2.png title=/images/apache-access-log-to-es/model_2.png data-thumbnail=/images/apache-access-log-to-es/model_2.png data-sub-html="<h2>그나마 좀더 생각한 구조</h2>"><img class=lazyload src=/svg/loading.min.svg data-src=/images/apache-access-log-to-es/model_2.png data-srcset="/images/apache-access-log-to-es/model_2.png, /images/apache-access-log-to-es/model_2.png 1.5x, /images/apache-access-log-to-es/model_2.png 2x" data-sizes=auto alt=/images/apache-access-log-to-es/model_2.png></a><figcaption class=image-caption>그나마 좀더 생각한 구조</figcaption></figure><p>그랬더니 거짓말 처럼 에러하나 없이 잘 인덱싱이 될수 있었다. logstash가 양쪽에 있는게 약간 걸리긴 하지만, 처음에 생각한 구조보다는 에러가 안나니 다행이라 생각한다.</p><p>이 구조를 적용하면서 얻은 Insight가 있기에, 각 항목별로 적어 보고자 한다. ( <del>이것만 적어놓기엔 너무 없어보여서..</del> )</p><h2 id=access-log-를-어떻게-분석하여-인덱싱-할것인가>access log 를 어떻게 분석하여 인덱싱 할것인가?</h2><p>apache 2.x를 사용하고 별도의 로그 포맷을 정하지 않으면 아래와 같은 access log가 찍힌다.
<code>123.1.1.1 - - [25/Jan/2018:21:55:35 +0900] "GET /api/test?param=12341234 HTTP/1.1" 200 48 1144 "http://www.naver.com/" "Mozilla/5.0 (iPhone; CPU iPhone OS 11_1_2 like Mac OS X) AppleWebKit/604.3.5 (KHTML, like Gecko) Mobile/15B202 NAVER(inapp; blog; 100; 4.0.44)"</code>
그럼 이 로그를 아무 포맷팅 없이 로깅을 하면 그냥 한줄의 텍스트가 인덱싱이 된다. 하지만 이렇게 되면 elasticsearch 데이터를 다시 재가공하거나 별도의 작업이 필요할수도 있으니 중간에 있는 logstash에게 일을 시켜 좀더 nice 한 방법으로 인덱싱을 해보자. 바로 logstash 의 filter 기능이다. 그중 Grok filter 라는게 있는데 패턴을 적용하여 row data 를 필터링하는 기능이다. 조금 찾아보니 너무 고맙게도 아파치 필터 예제가 있어 수정하여 적용할수 있었다. <a href="http://grokconstructor.appspot.com/do/match?example=2">http://grokconstructor.appspot.com/do/match?example=2</a>
그래서 적용한 필터설정은 다음과 같다.</p><div class=highlight><pre class=chroma><code class=language-bash data-lang=bash>filter <span class=o>{</span>
        grok <span class=o>{</span>
                <span class=nv>match</span> <span class=o>=</span>&gt; <span class=o>{</span>
                        <span class=nv>message</span> <span class=o>=</span>&gt; <span class=s2>&#34;%{IP:clientIp} (?:-|) (?:-|) \[%{HTTPDATE:timestamp}\] \&#34;(?:%{WORD:httpMethod} %{URIPATH:uri}%{GREEDYDATA}(?: HTTP/%{NUMBER})?|-)\&#34; %{NUMBER:responseCode} (?:-|%{NUMBER})&#34;</span>
                <span class=o>}</span>
        <span class=o>}</span>
<span class=o>}</span>
</code></pre></div><p>이렇게 하고 elasticsearch 에 인덱싱을 하면 키바나에서 다음과 같이 볼수 있다.<figure><a class=lightgallery href=/images/apache-access-log-to-es/access_log_kibana.png title=/images/apache-access-log-to-es/access_log_kibana.png data-thumbnail=/images/apache-access-log-to-es/access_log_kibana.png data-sub-html="<h2>키바나에 내가 원하는 구조대로 이쁘게 들어가 있는 access log</h2>"><img class=lazyload src=/svg/loading.min.svg data-src=/images/apache-access-log-to-es/access_log_kibana.png data-srcset="/images/apache-access-log-to-es/access_log_kibana.png, /images/apache-access-log-to-es/access_log_kibana.png 1.5x, /images/apache-access-log-to-es/access_log_kibana.png 2x" data-sizes=auto alt=/images/apache-access-log-to-es/access_log_kibana.png></a><figcaption class=image-caption>키바나에 내가 원하는 구조대로 이쁘게 들어가 있는 access log</figcaption></figure></p><h2 id=각-필드가-아닌-한줄로-인덱싱이-되어버린다>각 필드가 아닌 한줄로 인덱싱이 되어버린다.</h2><p>Elasticsearch 에 인덱싱이 되긴 하는데 로그 한줄이 통째로 들어가 버린다. <code>message</code>라는 이름으로&mldr; 알고보니 현재 구조는 logstash가 kafka 앞 뒤에 있다보니 producer logstash 와 consumer logstash 의 <code>codec</code>이 맞아야 제대로 인덱싱이 될수 있었다.
먼저 access log에서 kafka 로 produce 하는 logstash 에서는 output 할때 codec 을 맞춰주고</p><div class=highlight><pre class=chroma><code class=language-bash data-lang=bash>output <span class=o>{</span>
        kafka <span class=o>{</span>
                <span class=nv>bootstrap_servers</span> <span class=o>=</span>&gt; <span class=s2>&#34;123.1.2.3:9092,123.1.2.4:9092&#34;</span>
                <span class=nv>topic_id</span> <span class=o>=</span>&gt; <span class=s2>&#34;apache-log&#34;</span>
                <span class=nv>codec</span> <span class=o>=</span>&gt; json<span class=o>{}</span>
        <span class=o>}</span>
<span class=o>}</span>
</code></pre></div><p>kafka 에서 consume 하는 logstash 에서는 input 에서 codec 을 맞춰준다.</p><div class=highlight><pre class=chroma><code class=language-bash data-lang=bash>input <span class=o>{</span>
        kafka <span class=o>{</span>
                <span class=nv>bootstrap_servers</span> <span class=o>=</span>&gt; <span class=s2>&#34;123.1.2.3:9092,123.1.2.4:9092&#34;</span>
                <span class=nv>topic_id</span> <span class=o>=</span>&gt; <span class=s2>&#34;apache-log&#34;</span>
                <span class=nv>codec</span> <span class=o>=</span>&gt; json<span class=o>{}</span>
        <span class=o>}</span>
<span class=o>}</span>
</code></pre></div><p>그렇게 되면 codec이 맞아 각 필드로 <code>이쁘게</code> 인덱싱을 할수 있게 되었다.</p><h2 id=필요없는-uri는-제외하고-인덱싱할수-있을까>필요없는 uri는 제외하고 인덱싱할수 있을까?</h2><p><code>/</code>으로는 uri 라던지 <code>/server-status</code>같이 알고있지만 인덱싱은 하기 싫은 경우는 간단하게 아래처럼 if문으로 제외시킬수 있었다.(당연하게 보일진 모르겟지만 내겐 너무 생각보다 편하게 이슈를 해결할수 있어서 좋았다.)</p><div class=highlight><pre class=chroma><code class=language-bash data-lang=bash>output <span class=o>{</span>
        <span class=k>if</span> <span class=o>[</span>uri<span class=o>]</span> <span class=o>=</span>~ /.+/ and <span class=o>[</span>uri<span class=o>]</span> !<span class=o>=</span> <span class=s2>&#34;/server-status&#34;</span> <span class=o>{</span>
                kafka <span class=o>{</span>
                        <span class=nv>bootstrap_servers</span> <span class=o>=</span>&gt; <span class=s2>&#34;123.1.2.3:9092,123.1.2.4:9092&#34;</span>
                        <span class=nv>topic_id</span> <span class=o>=</span>&gt; <span class=s2>&#34;apache-log&#34;</span>
                        <span class=nv>codec</span> <span class=o>=</span>&gt; json<span class=o>{}</span>
                <span class=o>}</span>
        <span class=o>}</span>
<span class=o>}</span>
</code></pre></div><h2 id=하나의-index로는-관리가-힘든데-나눌순-없을까>하나의 index로는 관리가 힘든데 나눌순 없을까?</h2><p>사실 이 항목은 logstash에 해당하는 옵션이긴 하지만. 겸사겸사 적어본다.
이미 지난 로그는 지워야 할 상황이 온다. 이를테면 1년이 지났거나. 그럴경우 마지막 elasticsearch 로 output 하는 logstash 설정에서 다음과 같이 설정할수 있다.</p><div class=highlight><pre class=chroma><code class=language-bash data-lang=bash>output<span class=o>{</span>
	elasticsearch <span class=o>{</span>
		<span class=nv>hosts</span> <span class=o>=</span>&gt; <span class=o>[</span><span class=s2>&#34;123.1.2.3:9200&#34;</span>, <span class=s2>&#34;123.1.2.4:9200&#34;</span><span class=o>]</span>
		<span class=nv>index</span> <span class=o>=</span>&gt; <span class=s2>&#34;apache-log-%{+YYYY.MM}&#34;</span>
		<span class=nv>document_type</span> <span class=o>=</span>&gt; <span class=s2>&#34;apache&#34;</span>
	<span class=o>}</span>
<span class=o>}</span>
</code></pre></div><p>이렇게 하고 apache 라는 템플릿을 지정해 놓으면 달이 바뀔때마다 자동으로 해당 템플릿에 맞추어 index가 만들어지게 되고, 원하는 달 전체의 데이터를 한번에 지울수 있는 장점이 있는것 같다.</p><p>이런 저런 삽질의 과정의 끝에는 달콤한 보상이 따르는것 같다.(항상 그러는건 아니지만..) 아래처럼 대시보드를 만들어 한눈에 apache 단에서의 request를 분석할수 있게 되었다. 물론 이보다 더 한것도 할수 있을것 같다.</p><figure><a class=lightgallery href=/images/apache-access-log-to-es/kibana.png title=/images/apache-access-log-to-es/kibana.png data-thumbnail=/images/apache-access-log-to-es/kibana.png data-sub-html="<h2>키바나 대시보드 모습</h2>"><img class=lazyload src=/svg/loading.min.svg data-src=/images/apache-access-log-to-es/kibana.png data-srcset="/images/apache-access-log-to-es/kibana.png, /images/apache-access-log-to-es/kibana.png 1.5x, /images/apache-access-log-to-es/kibana.png 2x" data-sizes=auto alt=/images/apache-access-log-to-es/kibana.png></a><figcaption class=image-caption>키바나 대시보드 모습</figcaption></figure><p>매번 새로운 기술을 습득할때마다 느끼는거지만, 고전 기술로 어렵게 어렵게 시간을 소비하며 구성하는 것보다 새로운 기술을 빨리 습득하고 삽질할 시간에 더 다양한 생각을 해보는게 좋은것 같다. 특히 이 Elasticsearch 는 설정 몇번만으로 이렇게 강력한(?) 구성을 만들수 있다는거에 너무 신기하면서도 감사하다.</p><p>자, 다음엔 또 어떤걸 해볼수 있을까!? 가즈아~</p><ul><li><code>2018. 01. 26 추가</code></li></ul><pre><code>각 버전은 다음과 같다. (es를 어서 업그레이드 해야하는데...)
elasticsearch : 2.4.0
logstash : logstash-5.4.3
kafka : 0.11.0.0
apache : 2.2.x
</code></pre></div><center><style>.bmc-button img{width:27px!important;margin-bottom:1px!important;box-shadow:none!important;border:none!important;vertical-align:middle!important}.bmc-button{line-height:29px!important;height:30px!important;text-decoration:none!important;display:inline-flex!important;color:#000!important;background-color:#fd0!important;border-radius:3px!important;border:1px solid transparent!important;padding:1px 9px!important;font-size:22px!important;letter-spacing:.6px!important;box-shadow:0 1px 2px rgba(190,190,190,.5)!important;-webkit-box-shadow:0 1px 2px 2px rgba(190,190,190,.5)!important;margin:0 auto!important;font-family:cookie,cursive!important;-webkit-box-sizing:border-box!important;box-sizing:border-box!important;-o-transition:.3s all linear!important;-webkit-transition:.3s all linear!important;-moz-transition:.3s all linear!important;-ms-transition:.3s all linear!important;transition:.3s all linear!important}.bmc-button:hover,.bmc-button:active,.bmc-button:focus{-webkit-box-shadow:0 1px 2px 2px rgba(190,190,190,.5)!important;text-decoration:none!important;box-shadow:0 1px 2px 2px rgba(190,190,190,.5)!important;opacity:.85!important;color:#000!important}</style><link href="https://fonts.googleapis.com/css?family=Cookie" rel=stylesheet><center><br><a class=bmc-button target=_blank href=https://www.buymeacoffee.com/taetaetae><img src=https://www.buymeacoffee.com/assets/img/BMC-btn-logo.svg alt="Buy me a coffee"><span style=margin-left:5px>Buy me a coffee</span></a>
<a href=https://bit.ly/ddbSupport target=_blank><img src=https://i.imgur.com/peaYpjh.png style=height:28px></a></center><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>Updated on 2018-01-25</span></div><div class=post-info-license></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span><a href=javascript:void(0); title="Share on Twitter" data-sharer=twitter data-url=https://taetaetae.github.io/2018/01/25/apache-access-log-to-es/ data-title="아파치 엑세스 로그를 엘라스틱서치에 인덱싱 해보자." data-hashtags="elasticsearch,logstash,kafka,access log,archives-2018"><i class="fab fa-twitter fa-fw"></i></a><a href=javascript:void(0); title="Share on Facebook" data-sharer=facebook data-url=https://taetaetae.github.io/2018/01/25/apache-access-log-to-es/ data-hashtag=elasticsearch><i class="fab fa-facebook-square fa-fw"></i></a><a href=javascript:void(0); title="Share on Linkedin" data-sharer=linkedin data-url=https://taetaetae.github.io/2018/01/25/apache-access-log-to-es/><i class="fab fa-linkedin fa-fw"></i></a><a href=javascript:void(0); title="Share on Blogger" data-sharer=blogger data-url=https://taetaetae.github.io/2018/01/25/apache-access-log-to-es/ data-title="아파치 엑세스 로그를 엘라스틱서치에 인덱싱 해보자." data-description><i class="fab fa-blogger fa-fw"></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fas fa-tags fa-fw"></i>&nbsp;<a href=/tags/elasticsearch/>elasticsearch</a>,&nbsp;<a href=/tags/logstash/>logstash</a>,&nbsp;<a href=/tags/kafka/>kafka</a>,&nbsp;<a href=/tags/access-log/>access log</a>,&nbsp;<a href=/tags/archives-2018/>archives-2018</a></section><section><span><a href=javascript:void(0); onclick=window.history.back();>Back</a></span>&nbsp;|&nbsp;<span><a href=/>Home</a></span></section></div><div class=post-nav><a href=/2018/01/08/python-2-to-3/ class=prev rel=prev title="파이썬 버전 업그레이드 (2.6 > 3.6)"><i class="fas fa-angle-left fa-fw"></i>파이썬 버전 업그레이드 (2.6 > 3.6)</a>
<a href=/2018/02/01/linux-selenium/ class=next rel=next title="linux(centOS)에서 selenium 설정하기 (feat. python)">linux(centOS)에서 selenium 설정하기 (feat. python)<i class="fas fa-angle-right fa-fw"></i></a></div></div><div id=comments><div id=utterances></div><noscript>Please enable JavaScript to view the comments powered by <a href=https://utteranc.es/>Utterances</a>.</noscript></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line>Powered by <a href=https://gohugo.io/ target=_blank rel="noopener noreffer" title="Hugo 0.74.3">Hugo</a> | Theme - <a href=https://github.com/dillonzq/LoveIt target=_blank rel="noopener noreffer" title="LoveIt 0.2.10"><i class="far fa-kiss-wink-heart fa-fw"></i>LoveIt</a></div><div class=footer-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2016 - 2022</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=https://taetaetae.github.io/resume target=_blank>태태태</a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title="Back to Top"><i class="fas fa-arrow-up fa-fw"></i></a><a href=# id=view-comments class=fixed-button title="View Comments"><i class="fas fa-comment fa-fw"></i></a></div><link rel=stylesheet href=/lib/lightgallery/lightgallery.min.css><script type=text/javascript src=/lib/smooth-scroll/smooth-scroll.min.js></script><script type=text/javascript src=/lib/lazysizes/lazysizes.min.js></script><script type=text/javascript src=/lib/lightgallery/lightgallery.min.js></script><script type=text/javascript src=/lib/lightgallery/lg-thumbnail.min.js></script><script type=text/javascript src=/lib/lightgallery/lg-zoom.min.js></script><script type=text/javascript src=/lib/clipboard/clipboard.min.js></script><script type=text/javascript src=/lib/sharer/sharer.min.js></script><script type=text/javascript>window.config={"code":{"copyTitle":"Copy to clipboard","maxShownLines":500},"comment":{"utterances":{"darkTheme":"github-dark","issueTerm":"pathname","label":"Comment","lightTheme":"github-light","repo":"taetaetae/blog-comment"}},"lightGallery":{"actualSize":false,"exThumbImage":"data-thumbnail","hideBarsDelay":2000,"selector":".lightgallery","speed":400,"thumbContHeight":80,"thumbWidth":80,"thumbnail":true}};</script><script type=text/javascript src=/js/theme.min.js></script><script type=text/javascript>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}gtag('js',new Date());gtag('config','UA-86432198-1',{'anonymize_ip':true});</script><script type=text/javascript src="https://www.googletagmanager.com/gtag/js?id=UA-86432198-1" async></script></body></html>