<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><meta http-equiv=x-ua-compatible content="IE=edge, chrome=1"><title>조금 더 괜찮은 Rest Template 1부 - Retryable - 👨‍💻꿈꾸는 태태태의 공간</title><meta name=Description content><meta property="og:title" content="조금 더 괜찮은 Rest Template 1부 - Retryable"><meta property="og:description" content="웹 어플리케이션을 만들면서 꼭 한번 쯤 만나게 되는 &ldquo;RestTemplate&rdquo;. 접근 가능한 외부 HTTP URL(보통 API)을 호출하는 방법중에 하나로 springframework 에서 제공해주는 모듈이다. 특히 큰 한덩어리로 관리되던 Monolithic Architecture 에서 요청을 하고(client) 응답을 주는(server) 즉, Endpoint가 작은 단위로 분리되는 Microservice Architecture 로 바뀌면서 각 서비스간 호출방식이 HTTP 일 경우 자주 사용되곤 하는 것 같다. (webClient 등 다른 여러 호출 방법들이 있다.) 만약, 요청을 하는 클라이언트 입장에서 응답을 주는 서버의 상태가 불안정 하다고 가정했을때, 어떤식으로 처리해야 할까? 예컨대, 요청 10번에 한번은 어떠한 이슈로 응답이 지연되거나 서버에러가 발생한다고 하면 클라이언트를 사용하는 사용자 입장에서는 간헐적인 오류응답에 답답함을 호소할 수도 있다. 그럼 잠시 눈을 감고 생각해보자. 가볍게 생각하면 아래처럼 아주 간단하게 &ldquo;예외처리&#34;를 이용할 수도 있다.
try { // http call } catch (Exception e){ // 서버에러가 아닌 약속된 에러응답을 리턴 } 하지만 이것도 정답이 아닐수 있는게, &ldquo;간헐적인 오류&#34;로 인해 사용자는 오류화면을 봐야하기 때문에 클라이언트에 대한 신뢰를 저버릴 수밖에 없다. 그럼 어떻게 해야할까? 여러가지 해결방법이 있겠지만 간단하면서도 강력하다고 생각되는 방법이 바로 &ldquo;재시도&rdquo; 라고 생각한다. 클라이언트를 사용하는 사용자가 눈치 못챌만큼 빠르게 재시도를 한다면 에러가 나도 다시한번 호출해서 성공할 수 있는 가능성이 높기 때문이다. (그치만 근본적인 원인은 해결해야&mldr;)
실제로 조금있다 해보면 되는 경우가 많으니 안될때는 조금 (천천히) 시도해보자. 출처 : http://www.segye.com/newsView/20200302504384&#34; 실제로 조금있다 해보면 되는 경우가 많으니 안될때는 조금 (천천히) 시도해보자. 출처 : http://www.segye.com/newsView/20200302504384  이번 포스팅에서는 RestTemplate 를 이용할때 &ldquo;재시도&rdquo; 할 수 있는 방법에 대해 알아보고자 한다. 아주 간단할지 모르지만 노력에 비해 효과가 상당하다고 생각하기 때문에 정리해 두고 싶었다.
Spring Retry 공식 Github에 소개를 빌리자면, Spring 어플리케이션에 대한 재시도 지원을 제공한다고 한다. 위에서 이야기 했던 &ldquo;RestTemplate&#34;과는 사실 무관하고, 이를 활용해서 재시도 하는 &ldquo;RetryRestTemplate&#34;를 구현해보려 하는것이다. 우선 이 &ldquo;Spring-Retry&#34;의 예제를 보면 아주 심플하게 사용할 수 있다. 우선 pom에 구현에 필요한 dependency 를 추가하고 아래 코드를 보자.
<dependency> <groupId>org.springframework.retry</groupId> <artifactId>spring-retry</artifactId> </dependency> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-aop</artifactId> </dependency> @Configuration @EnableRetry // 1 public class Application { @Bean public Service service() { return new Service(); } } @Service class Service { @Retryable(RemoteAccessException.class) // 2  public void service() { // ... do something  } @Recover // 3  public void recover(RemoteAccessException e) { // ... panic  } }  @EnableRetry 어노테이션을 @Configuration을 지정한 클래스 중 하나에 추가한다. 재시도 하려는 메소드에 @Retryable 어노테이션을 지정해준다. 재시도가 완료되는 시점에서 실행하고 싶을때 선언하는 어노테이션, @Retryable 동일한 클래스에서 선언되어야 하고 return type 은 @Retryable을 지정한 메소드와 동일해야 한다.  Retry Rest Template 이렇게 springframework 에서 제공해주는 spring-retry 를 이용해서 이번 포스팅의 목표인 재시도를 하는 Retry Rest Template 를 구성해보자. 우선, RestTemplate 를 Bean 으로 등록하고, 위에서 이야기 한 어노테이션들로 구성해보자.
@EnableRetry @Configuration public class RetryableRestTemplateConfiguration { @Bean public RestTemplate retryableRestTemplate() { SimpleClientHttpRequestFactory clientHttpRequestFactory = new SimpleClientHttpRequestFactory(); // 1 	clientHttpRequestFactory.setReadTimeout(2000); clientHttpRequestFactory.setConnectTimeout(500); RestTemplate restTemplate = new RestTemplate(clientHttpRequestFactory) { @Override @Retryable(value = RestClientException.class, maxAttempts = 3, backoff = @Backoff(delay = 1000)) // 2 	public <T> ResponseEntity<T> exchange(URI url, HttpMethod method, HttpEntity<?> requestEntity, Class<T> responseType) throws RestClientException { return super.exchange(url, method, requestEntity, responseType); } @Recover public <T> ResponseEntity<String> exchangeRecover(RestClientException e) { return ResponseEntity.badRequest().body(&#34;bad request T.T&#34;); // 3 	} }; return restTemplate; } }  SimpleClientHttpRequestFactory 를 만들고 각 타임아웃을 설정해준 다음 RestTemplate 파라미터로 넘겨준다. 사용하는 곳에서 exchange 메소드를 이용할 것이므로 해당 메소드를 오버라이드 해준다."><meta property="og:type" content="article"><meta property="og:url" content="https://taetaetae.github.io/2020/03/22/better-rest-template-1-retryable/"><meta property="og:image" content="https://taetaetae.github.io/images/better-rest-template-1-retryable/icons8.png"><meta property="article:published_time" content="2020-03-22T15:30:35+00:00"><meta property="article:modified_time" content="2020-03-22T15:30:35+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://taetaetae.github.io/images/better-rest-template-1-retryable/icons8.png"><meta name=twitter:title content="조금 더 괜찮은 Rest Template 1부 - Retryable"><meta name=twitter:description content="웹 어플리케이션을 만들면서 꼭 한번 쯤 만나게 되는 &ldquo;RestTemplate&rdquo;. 접근 가능한 외부 HTTP URL(보통 API)을 호출하는 방법중에 하나로 springframework 에서 제공해주는 모듈이다. 특히 큰 한덩어리로 관리되던 Monolithic Architecture 에서 요청을 하고(client) 응답을 주는(server) 즉, Endpoint가 작은 단위로 분리되는 Microservice Architecture 로 바뀌면서 각 서비스간 호출방식이 HTTP 일 경우 자주 사용되곤 하는 것 같다. (webClient 등 다른 여러 호출 방법들이 있다.) 만약, 요청을 하는 클라이언트 입장에서 응답을 주는 서버의 상태가 불안정 하다고 가정했을때, 어떤식으로 처리해야 할까? 예컨대, 요청 10번에 한번은 어떠한 이슈로 응답이 지연되거나 서버에러가 발생한다고 하면 클라이언트를 사용하는 사용자 입장에서는 간헐적인 오류응답에 답답함을 호소할 수도 있다. 그럼 잠시 눈을 감고 생각해보자. 가볍게 생각하면 아래처럼 아주 간단하게 &ldquo;예외처리&#34;를 이용할 수도 있다.
try { // http call } catch (Exception e){ // 서버에러가 아닌 약속된 에러응답을 리턴 } 하지만 이것도 정답이 아닐수 있는게, &ldquo;간헐적인 오류&#34;로 인해 사용자는 오류화면을 봐야하기 때문에 클라이언트에 대한 신뢰를 저버릴 수밖에 없다. 그럼 어떻게 해야할까? 여러가지 해결방법이 있겠지만 간단하면서도 강력하다고 생각되는 방법이 바로 &ldquo;재시도&rdquo; 라고 생각한다. 클라이언트를 사용하는 사용자가 눈치 못챌만큼 빠르게 재시도를 한다면 에러가 나도 다시한번 호출해서 성공할 수 있는 가능성이 높기 때문이다. (그치만 근본적인 원인은 해결해야&mldr;)
실제로 조금있다 해보면 되는 경우가 많으니 안될때는 조금 (천천히) 시도해보자. 출처 : http://www.segye.com/newsView/20200302504384&#34; 실제로 조금있다 해보면 되는 경우가 많으니 안될때는 조금 (천천히) 시도해보자. 출처 : http://www.segye.com/newsView/20200302504384  이번 포스팅에서는 RestTemplate 를 이용할때 &ldquo;재시도&rdquo; 할 수 있는 방법에 대해 알아보고자 한다. 아주 간단할지 모르지만 노력에 비해 효과가 상당하다고 생각하기 때문에 정리해 두고 싶었다.
Spring Retry 공식 Github에 소개를 빌리자면, Spring 어플리케이션에 대한 재시도 지원을 제공한다고 한다. 위에서 이야기 했던 &ldquo;RestTemplate&#34;과는 사실 무관하고, 이를 활용해서 재시도 하는 &ldquo;RetryRestTemplate&#34;를 구현해보려 하는것이다. 우선 이 &ldquo;Spring-Retry&#34;의 예제를 보면 아주 심플하게 사용할 수 있다. 우선 pom에 구현에 필요한 dependency 를 추가하고 아래 코드를 보자.
<dependency> <groupId>org.springframework.retry</groupId> <artifactId>spring-retry</artifactId> </dependency> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-aop</artifactId> </dependency> @Configuration @EnableRetry // 1 public class Application { @Bean public Service service() { return new Service(); } } @Service class Service { @Retryable(RemoteAccessException.class) // 2  public void service() { // ... do something  } @Recover // 3  public void recover(RemoteAccessException e) { // ... panic  } }  @EnableRetry 어노테이션을 @Configuration을 지정한 클래스 중 하나에 추가한다. 재시도 하려는 메소드에 @Retryable 어노테이션을 지정해준다. 재시도가 완료되는 시점에서 실행하고 싶을때 선언하는 어노테이션, @Retryable 동일한 클래스에서 선언되어야 하고 return type 은 @Retryable을 지정한 메소드와 동일해야 한다.  Retry Rest Template 이렇게 springframework 에서 제공해주는 spring-retry 를 이용해서 이번 포스팅의 목표인 재시도를 하는 Retry Rest Template 를 구성해보자. 우선, RestTemplate 를 Bean 으로 등록하고, 위에서 이야기 한 어노테이션들로 구성해보자.
@EnableRetry @Configuration public class RetryableRestTemplateConfiguration { @Bean public RestTemplate retryableRestTemplate() { SimpleClientHttpRequestFactory clientHttpRequestFactory = new SimpleClientHttpRequestFactory(); // 1 	clientHttpRequestFactory.setReadTimeout(2000); clientHttpRequestFactory.setConnectTimeout(500); RestTemplate restTemplate = new RestTemplate(clientHttpRequestFactory) { @Override @Retryable(value = RestClientException.class, maxAttempts = 3, backoff = @Backoff(delay = 1000)) // 2 	public <T> ResponseEntity<T> exchange(URI url, HttpMethod method, HttpEntity<?> requestEntity, Class<T> responseType) throws RestClientException { return super.exchange(url, method, requestEntity, responseType); } @Recover public <T> ResponseEntity<String> exchangeRecover(RestClientException e) { return ResponseEntity.badRequest().body(&#34;bad request T.T&#34;); // 3 	} }; return restTemplate; } }  SimpleClientHttpRequestFactory 를 만들고 각 타임아웃을 설정해준 다음 RestTemplate 파라미터로 넘겨준다. 사용하는 곳에서 exchange 메소드를 이용할 것이므로 해당 메소드를 오버라이드 해준다."><meta name=application-name content="👨‍💻꿈꾸는 태태태의 공간"><meta name=apple-mobile-web-app-title content="👨‍💻꿈꾸는 태태태의 공간"><meta name=naver-site-verification content="2d1cdbb963ba178aa7cbf58500afc668cae1e645"><meta name=google-site-verification content="vvFCdv0-GuQhEWG8vtNJfA7YSY2HYQ1hpHh9P-a6Pv8"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://taetaetae.github.io/2020/03/22/better-rest-template-1-retryable/><link rel=prev href=https://taetaetae.github.io/2020/03/08/spring-rest-docs-in-spring-boot/><link rel=next href=https://taetaetae.github.io/2020/03/26/7-years-of-development-1st-day-of-manager/><link rel=stylesheet href=/lib/normalize/normalize.min.css><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=/lib/fontawesome-free/all.min.css><link rel=stylesheet href=/lib/animate/animate.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"조금 더 괜찮은 Rest Template 1부 - Retryable","inLanguage":"en","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/taetaetae.github.io\/2020\/03\/22\/better-rest-template-1-retryable\/"},"genre":"posts","keywords":"spring boot, retryable, archives-2020","wordcount":929,"url":"https:\/\/taetaetae.github.io\/2020\/03\/22\/better-rest-template-1-retryable\/","datePublished":"2020-03-22T15:30:35+00:00","dateModified":"2020-03-22T15:30:35+00:00","publisher":{"@type":"Organization","name":"태태태"},"author":{"@type":"Person","name":"태태태"},"description":""}</script></head><body header-desktop=auto header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem('theme')?localStorage.getItem('theme')==='dark':('auto'==='auto'?window.matchMedia('(prefers-color-scheme: dark)').matches:'auto'==='dark'))&&document.body.setAttribute('theme','dark');</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title="👨‍💻꿈꾸는 태태태의 공간">👨‍💻꿈꾸는 태태태의 공간</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/>Posts </a><a class=menu-item href=/tags/>Tags </a><a class=menu-item href=/categories/>Categories </a><span class="menu-item delimiter"></span><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme"><i class="fas fa-adjust fa-fw"></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title="👨‍💻꿈꾸는 태태태의 공간">👨‍💻꿈꾸는 태태태의 공간</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><a class=menu-item href=/posts/>Posts</a><a class=menu-item href=/tags/>Tags</a><a class=menu-item href=/categories/>Categories</a><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme">
<i class="fas fa-adjust fa-fw"></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>Contents</h2><div class=toc-content id=toc-content-auto></div><script async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script><ins class=adsbygoogle style=display:inline-block;width:260px;height:600px data-ad-client=ca-pub-5788330009690816 data-ad-slot=2248955907></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({});</script></div><article class="page single"><h1 class="single-title animated flipInX">조금 더 괜찮은 Rest Template 1부 - Retryable</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=https://taetaetae.github.io/resume title=Author target=_blank rel="noopener noreffer author" class=author><i class="fas fa-user-circle fa-fw"></i>태태태</a></span>&nbsp;<span class=post-category>included in <a href=/categories/tech/><i class="far fa-folder fa-fw"></i>Tech</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime=2020-03-22>2020-03-22</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;929 words&nbsp;
<i class="far fa-clock fa-fw"></i>&nbsp;5 minutes&nbsp;</div></div><div class=featured-image><img class=lazyload src=/svg/loading.min.svg data-src=/images/better-rest-template-1-retryable/icons8.png data-srcset="/images/better-rest-template-1-retryable/icons8.png, /images/better-rest-template-1-retryable/icons8.png 1.5x, /images/better-rest-template-1-retryable/icons8.png 2x" data-sizes=auto alt=/images/better-rest-template-1-retryable/icons8.png title=/images/better-rest-template-1-retryable/icons8.png></div><div class="details toc" id=toc-static kept><div class="details-summary toc-title"><span>Contents</span>
<span><i class="details-icon fas fa-angle-right"></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#spring-retry>Spring Retry</a></li><li><a href=#retry-rest-template>Retry Rest Template</a></li><li><a href=#마치며>마치며</a></li></ul></nav></div></div><div class=content id=content><script src=https://ads-partners.coupang.com/g.js></script><script>new PartnersCoupang.G({"id":195296,"trackingCode":"AF5596407","subId":null,"template":"carousel","width":"680","height":"140"});</script><p>※ 쿠팡 파트너스 활동을 통해 일정액의 수수료를 제공받을 수 있습니다.</p><p>웹 어플리케이션을 만들면서 꼭 한번 쯤 만나게 되는 &ldquo;RestTemplate&rdquo;. 접근 가능한 외부 HTTP URL(보통 API)을 호출하는 방법중에 하나로 springframework 에서 제공해주는 모듈이다. 특히 큰 한덩어리로 관리되던 Monolithic Architecture 에서 요청을 하고(client) 응답을 주는(server) 즉, Endpoint가 작은 단위로 분리되는 Microservice Architecture 로 바뀌면서 각 서비스간 호출방식이 HTTP 일 경우 자주 사용되곤 하는 것 같다. (webClient 등 다른 여러 호출 방법들이 있다.)
만약, 요청을 하는 클라이언트 입장에서 응답을 주는 서버의 상태가 불안정 하다고 가정했을때, 어떤식으로 처리해야 할까? 예컨대, 요청 10번에 한번은 어떠한 이슈로 응답이 지연되거나 서버에러가 발생한다고 하면 클라이언트를 사용하는 사용자 입장에서는 간헐적인 오류응답에 답답함을 호소할 수도 있다. 그럼 잠시 눈을 감고 생각해보자.
가볍게 생각하면 아래처럼 아주 간단하게 &ldquo;예외처리"를 이용할 수도 있다.</p><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=k>try</span> <span class=o>{</span>
	<span class=c1>// http call
</span><span class=c1></span><span class=o>}</span> <span class=k>catch</span> <span class=o>(</span><span class=n>Exception</span> <span class=n>e</span><span class=o>){</span>
	<span class=c1>// 서버에러가 아닌 약속된 에러응답을 리턴
</span><span class=c1></span><span class=o>}</span>
</code></pre></div><p>하지만 이것도 정답이 아닐수 있는게, &ldquo;간헐적인 오류"로 인해 사용자는 오류화면을 봐야하기 때문에 클라이언트에 대한 신뢰를 저버릴 수밖에 없다. 그럼 어떻게 해야할까? 여러가지 해결방법이 있겠지만 간단하면서도 강력하다고 생각되는 방법이 바로 &ldquo;재시도&rdquo; 라고 생각한다. 클라이언트를 사용하는 사용자가 눈치 못챌만큼 빠르게 재시도를 한다면 에러가 나도 다시한번 호출해서 성공할 수 있는 가능성이 높기 때문이다. (그치만 근본적인 원인은 해결해야&mldr;)</p><figure><a class=lightgallery href=/images/better-rest-template-1-retryable/retry.png title=/images/better-rest-template-1-retryable/retry.png data-thumbnail=/images/better-rest-template-1-retryable/retry.png data-sub-html="<h2>실제로 조금있다 해보면 되는 경우가 많으니 안될때는 조금 (천천히) 시도해보자. 출처 : http://www.segye.com/newsView/20200302504384</h2>"><img class=lazyload src=/svg/loading.min.svg data-src=/images/better-rest-template-1-retryable/retry.png data-srcset="/images/better-rest-template-1-retryable/retry.png, /images/better-rest-template-1-retryable/retry.png 1.5x, /images/better-rest-template-1-retryable/retry.png 2x" data-sizes=auto alt=/images/better-rest-template-1-retryable/retry.png width=40%></a><figcaption class=image-caption>실제로 조금있다 해보면 되는 경우가 많으니 안될때는 조금 (천천히) 시도해보자.<br>출처 : <a href=http://www.segye.com/newsView/20200302504384>http://www.segye.com/newsView/20200302504384</a></figcaption></figure><p>이번 포스팅에서는 RestTemplate 를 이용할때 &ldquo;재시도&rdquo; 할 수 있는 방법에 대해 알아보고자 한다. 아주 간단할지 모르지만 노력에 비해 효과가 상당하다고 생각하기 때문에 정리해 두고 싶었다.</p><h2 id=spring-retry>Spring Retry</h2><p><a href=https://github.com/spring-projects/spring-retry target=_blank rel="noopener noreffer">공식 Github</a>에 소개를 빌리자면, Spring 어플리케이션에 대한 재시도 지원을 제공한다고 한다. 위에서 이야기 했던 &ldquo;RestTemplate"과는 사실 무관하고, 이를 활용해서 재시도 하는 &ldquo;RetryRestTemplate"를 구현해보려 하는것이다. 우선 이 &ldquo;Spring-Retry"의 예제를 보면 아주 심플하게 사용할 수 있다. 우선 pom에 구현에 필요한 dependency 를 추가하고 아래 코드를 보자.</p><div class=highlight><pre class=chroma><code class=language-xml data-lang=xml><span class=nt>&lt;dependency&gt;</span>
	<span class=nt>&lt;groupId&gt;</span>org.springframework.retry<span class=nt>&lt;/groupId&gt;</span>
	<span class=nt>&lt;artifactId&gt;</span>spring-retry<span class=nt>&lt;/artifactId&gt;</span>
<span class=nt>&lt;/dependency&gt;</span>
<span class=nt>&lt;dependency&gt;</span>
	<span class=nt>&lt;groupId&gt;</span>org.springframework.boot<span class=nt>&lt;/groupId&gt;</span>
	<span class=nt>&lt;artifactId&gt;</span>spring-boot-starter-aop<span class=nt>&lt;/artifactId&gt;</span>
<span class=nt>&lt;/dependency&gt;</span>
</code></pre></div><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=nd>@Configuration</span>
<span class=nd>@EnableRetry</span> <span class=c1>// 1
</span><span class=c1></span><span class=kd>public</span> <span class=kd>class</span> <span class=nc>Application</span> <span class=o>{</span>

    <span class=nd>@Bean</span>
    <span class=kd>public</span> <span class=n>Service</span> <span class=nf>service</span><span class=o>()</span> <span class=o>{</span>
        <span class=k>return</span> <span class=k>new</span> <span class=n>Service</span><span class=o>();</span>
    <span class=o>}</span>

<span class=o>}</span>

<span class=nd>@Service</span>
<span class=kd>class</span> <span class=nc>Service</span> <span class=o>{</span>
    <span class=nd>@Retryable</span><span class=o>(</span><span class=n>RemoteAccessException</span><span class=o>.</span><span class=na>class</span><span class=o>)</span> <span class=c1>// 2
</span><span class=c1></span>    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>service</span><span class=o>()</span> <span class=o>{</span>
        <span class=c1>// ... do something
</span><span class=c1></span>    <span class=o>}</span>
    <span class=nd>@Recover</span> <span class=c1>// 3
</span><span class=c1></span>    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>recover</span><span class=o>(</span><span class=n>RemoteAccessException</span> <span class=n>e</span><span class=o>)</span> <span class=o>{</span>
       <span class=c1>// ... panic
</span><span class=c1></span>    <span class=o>}</span>
<span class=o>}</span>
</code></pre></div><ol><li>@EnableRetry 어노테이션을 @Configuration을 지정한 클래스 중 하나에 추가한다.</li><li>재시도 하려는 메소드에 @Retryable 어노테이션을 지정해준다.</li><li>재시도가 완료되는 시점에서 실행하고 싶을때 선언하는 어노테이션, @Retryable 동일한 클래스에서 선언되어야 하고 return type 은 @Retryable을 지정한 메소드와 동일해야 한다.</li></ol><h2 id=retry-rest-template>Retry Rest Template</h2><p>이렇게 springframework 에서 제공해주는 spring-retry 를 이용해서 이번 포스팅의 목표인 재시도를 하는 Retry Rest Template 를 구성해보자. 우선, RestTemplate 를 Bean 으로 등록하고, 위에서 이야기 한 어노테이션들로 구성해보자.</p><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=nd>@EnableRetry</span>
<span class=nd>@Configuration</span>
<span class=kd>public</span> <span class=kd>class</span> <span class=nc>RetryableRestTemplateConfiguration</span> <span class=o>{</span>

	<span class=nd>@Bean</span>
	<span class=kd>public</span> <span class=n>RestTemplate</span> <span class=nf>retryableRestTemplate</span><span class=o>()</span> <span class=o>{</span>
		<span class=n>SimpleClientHttpRequestFactory</span> <span class=n>clientHttpRequestFactory</span> <span class=o>=</span> <span class=k>new</span> <span class=n>SimpleClientHttpRequestFactory</span><span class=o>();</span> <span class=c1>// 1
</span><span class=c1></span>		<span class=n>clientHttpRequestFactory</span><span class=o>.</span><span class=na>setReadTimeout</span><span class=o>(</span><span class=n>2000</span><span class=o>);</span>
		<span class=n>clientHttpRequestFactory</span><span class=o>.</span><span class=na>setConnectTimeout</span><span class=o>(</span><span class=n>500</span><span class=o>);</span>

		<span class=n>RestTemplate</span> <span class=n>restTemplate</span> <span class=o>=</span> <span class=k>new</span> <span class=n>RestTemplate</span><span class=o>(</span><span class=n>clientHttpRequestFactory</span><span class=o>)</span> <span class=o>{</span>
			<span class=nd>@Override</span>
			<span class=nd>@Retryable</span><span class=o>(</span><span class=n>value</span> <span class=o>=</span> <span class=n>RestClientException</span><span class=o>.</span><span class=na>class</span><span class=o>,</span> <span class=n>maxAttempts</span> <span class=o>=</span> <span class=n>3</span><span class=o>,</span> <span class=n>backoff</span> <span class=o>=</span> <span class=nd>@Backoff</span><span class=o>(</span><span class=n>delay</span> <span class=o>=</span> <span class=n>1000</span><span class=o>))</span> <span class=c1>// 2
</span><span class=c1></span>			<span class=kd>public</span> <span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=n>ResponseEntity</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=nf>exchange</span><span class=o>(</span><span class=n>URI</span> <span class=n>url</span><span class=o>,</span> <span class=n>HttpMethod</span> <span class=n>method</span><span class=o>,</span> <span class=n>HttpEntity</span><span class=o>&lt;?&gt;</span> <span class=n>requestEntity</span><span class=o>,</span> <span class=n>Class</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=n>responseType</span><span class=o>)</span>
				<span class=kd>throws</span> <span class=n>RestClientException</span> <span class=o>{</span>
				<span class=k>return</span> <span class=kd>super</span><span class=o>.</span><span class=na>exchange</span><span class=o>(</span><span class=n>url</span><span class=o>,</span> <span class=n>method</span><span class=o>,</span> <span class=n>requestEntity</span><span class=o>,</span> <span class=n>responseType</span><span class=o>);</span> 
			<span class=o>}</span>

			<span class=nd>@Recover</span>
			<span class=kd>public</span> <span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=n>ResponseEntity</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=nf>exchangeRecover</span><span class=o>(</span><span class=n>RestClientException</span> <span class=n>e</span><span class=o>)</span> <span class=o>{</span>
				<span class=k>return</span> <span class=n>ResponseEntity</span><span class=o>.</span><span class=na>badRequest</span><span class=o>().</span><span class=na>body</span><span class=o>(</span><span class=s>&#34;bad request T.T&#34;</span><span class=o>);</span> <span class=c1>// 3
</span><span class=c1></span>			<span class=o>}</span>
		<span class=o>};</span>

		<span class=k>return</span> <span class=n>restTemplate</span><span class=o>;</span>
	<span class=o>}</span>
<span class=o>}</span>
</code></pre></div><ol><li>SimpleClientHttpRequestFactory 를 만들고 각 타임아웃을 설정해준 다음 RestTemplate 파라미터로 넘겨준다.</li><li>사용하는 곳에서 exchange 메소드를 이용할 것이므로 해당 메소드를 오버라이드 해준다. 먼저 해당 메소드에서 &ldquo;RestClientException"이 발생할 경우 Retry 로직을 수행한다고 정해주고, 최대 시도는 3번, backoff 설정중 delay를 1000ms(1초)로 지정해서 재시도가 진행되도록 해준다.</li><li>2 에서 지정한 재시도가 끝나면 (재시도를 전부 다 하면) 해당 메소드를 수행하게 되어있고, 임의로 응답에 지정한 문구를 넘겨준다.</li></ol><p>이렇게 하고 실제로 사용하는 로직에서 일부러 잘못된 URL을 호출해 보도록 하자. 그리고서 로그를 자세히 보도록 application.properties 에 &ldquo;debug=true&rdquo; 설정을 해준다.</p><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=nd>@RestController</span>
<span class=kd>public</span> <span class=kd>class</span> <span class=nc>TestController</span> <span class=o>{</span>

	<span class=nd>@Autowired</span>
	<span class=kd>private</span> <span class=n>RestTemplate</span> <span class=n>retryableRestTemplate</span><span class=o>;</span>

	<span class=nd>@GetMapping</span><span class=o>(</span><span class=n>value</span> <span class=o>=</span> <span class=s>&#34;/employees&#34;</span><span class=o>,</span> <span class=n>produces</span> <span class=o>=</span> <span class=n>MediaType</span><span class=o>.</span><span class=na>APPLICATION_JSON_VALUE</span><span class=o>)</span>
	<span class=nd>@ResponseBody</span>
	<span class=kd>public</span> <span class=n>String</span> <span class=nf>employees</span><span class=o>()</span> <span class=kd>throws</span> <span class=n>URISyntaxException</span> <span class=o>{</span>
		<span class=kd>final</span> <span class=n>String</span> <span class=n>baseUrl</span> <span class=o>=</span> <span class=s>&#34;http://dummy.restapiexample.com/api/v1/employeeszzz&#34;</span><span class=o>;</span> <span class=c1>// zzz 가 빠져야 한다.
</span><span class=c1></span>		<span class=n>URI</span> <span class=n>uri</span> <span class=o>=</span> <span class=k>new</span> <span class=n>URI</span><span class=o>(</span><span class=n>baseUrl</span><span class=o>);</span>
		<span class=n>ResponseEntity</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>exchange</span> <span class=o>=</span> <span class=n>retryableRestTemplate</span><span class=o>.</span><span class=na>exchange</span><span class=o>(</span><span class=n>uri</span><span class=o>,</span> <span class=n>HttpMethod</span><span class=o>.</span><span class=na>GET</span><span class=o>,</span> <span class=kc>null</span><span class=o>,</span> <span class=n>String</span><span class=o>.</span><span class=na>class</span><span class=o>);</span>
		<span class=k>return</span> <span class=n>exchange</span><span class=o>.</span><span class=na>getBody</span><span class=o>();</span>
	<span class=o>}</span>
<span class=o>}</span>
</code></pre></div><p>이렇게 하고 실행을 시켜보면 다음과 같이 재시도 관련 로깅이 찍히는 것을 볼 수 있고</p><div class=highlight><pre class=chroma><code class=language-shell data-lang=shell>23:05:50.893 DEBUG <span class=m>21016</span> --- <span class=o>[</span>nio-8080-exec-1<span class=o>]</span> o.s.web.servlet.DispatcherServlet        : GET <span class=s2>&#34;/employees&#34;</span>, <span class=nv>parameters</span><span class=o>={}</span>
23:05:50.898 DEBUG <span class=m>21016</span> --- <span class=o>[</span>nio-8080-exec-1<span class=o>]</span> s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped to com.taetaetae.retryableresttemplate.TestController#employees<span class=o>()</span>
23:05:50.994 DEBUG <span class=m>21016</span> --- <span class=o>[</span>nio-8080-exec-1<span class=o>]</span> org.springframework.web.HttpLogging      : HTTP GET http://dummy.restapiexample.com/api/v1/employeeszzz
23:05:50.999 DEBUG <span class=m>21016</span> --- <span class=o>[</span>nio-8080-exec-1<span class=o>]</span> org.springframework.web.HttpLogging      : <span class=nv>Accept</span><span class=o>=[</span>text/plain, application/json, application/*+json, */*<span class=o>]</span>
23:05:51.861 DEBUG <span class=m>21016</span> --- <span class=o>[</span>nio-8080-exec-1<span class=o>]</span> org.springframework.web.HttpLogging      : Response <span class=m>404</span> NOT_FOUND
23:05:52.869 DEBUG <span class=m>21016</span> --- <span class=o>[</span>nio-8080-exec-1<span class=o>]</span> org.springframework.web.HttpLogging      : HTTP GET http://dummy.restapiexample.com/api/v1/employeeszzz
23:05:52.869 DEBUG <span class=m>21016</span> --- <span class=o>[</span>nio-8080-exec-1<span class=o>]</span> org.springframework.web.HttpLogging      : <span class=nv>Accept</span><span class=o>=[</span>text/plain, application/json, application/*+json, */*<span class=o>]</span>
23:05:53.603 DEBUG <span class=m>21016</span> --- <span class=o>[</span>nio-8080-exec-1<span class=o>]</span> org.springframework.web.HttpLogging      : Response <span class=m>404</span> NOT_FOUND
23:05:54.605 DEBUG <span class=m>21016</span> --- <span class=o>[</span>nio-8080-exec-1<span class=o>]</span> org.springframework.web.HttpLogging      : HTTP GET http://dummy.restapiexample.com/api/v1/employeeszzz
23:05:54.606 DEBUG <span class=m>21016</span> --- <span class=o>[</span>nio-8080-exec-1<span class=o>]</span> org.springframework.web.HttpLogging      : <span class=nv>Accept</span><span class=o>=[</span>text/plain, application/json, application/*+json, */*<span class=o>]</span>
23:05:55.305 DEBUG <span class=m>21016</span> --- <span class=o>[</span>nio-8080-exec-1<span class=o>]</span> org.springframework.web.HttpLogging      : Response <span class=m>404</span> NOT_FOUND
23:05:57.192 DEBUG <span class=m>21016</span> --- <span class=o>[</span>nio-8080-exec-1<span class=o>]</span> m.m.a.RequestResponseBodyMethodProcessor : Using <span class=s1>&#39;application/json;q=0.8&#39;</span>, given <span class=o>[</span>text/html, application/xhtml+xml, image/webp, image/apng, application/xml<span class=p>;</span><span class=nv>q</span><span class=o>=</span>0.9, application/signed-exchange<span class=p>;</span><span class=nv>v</span><span class=o>=</span>b3<span class=p>;</span><span class=nv>q</span><span class=o>=</span>0.9, */*<span class=p>;</span><span class=nv>q</span><span class=o>=</span>0.8<span class=o>]</span> and supported <span class=o>[</span>application/json<span class=o>]</span>
23:05:57.193 DEBUG <span class=m>21016</span> --- <span class=o>[</span>nio-8080-exec-1<span class=o>]</span> m.m.a.RequestResponseBodyMethodProcessor : Writing <span class=o>[</span><span class=s2>&#34;bad request T.T&#34;</span><span class=o>]</span>
23:05:57.202 DEBUG <span class=m>21016</span> --- <span class=o>[</span>nio-8080-exec-1<span class=o>]</span> o.s.web.servlet.DispatcherServlet        : Completed <span class=m>200</span> OK
</code></pre></div><p>브라우저에서 해당 url을 접근해보면 @Recover 에서 지정했던 결과를 볼 수 있게 된다. 사실 이러한 방법에 대해 삽질하기 전에 다른 방법들을 찾아봤지만 restTemplate 을 사용하는 곳에서 각각 retry관련 로직을 추가해야 했기에 뭔가 어글리해 보여서 삽질을 시작하게 되었다. 다행히 성공.</p><figure><a class=lightgallery href=/images/better-rest-template-1-retryable/response.jpg title=/images/better-rest-template-1-retryable/response.jpg data-thumbnail=/images/better-rest-template-1-retryable/response.jpg data-sub-html="<h2>예제로 임의 문자열을 리턴했지만 상황에 따라 얼마든지 커스터마이징이 가능하다.</h2>"><img class=lazyload src=/svg/loading.min.svg data-src=/images/better-rest-template-1-retryable/response.jpg data-srcset="/images/better-rest-template-1-retryable/response.jpg, /images/better-rest-template-1-retryable/response.jpg 1.5x, /images/better-rest-template-1-retryable/response.jpg 2x" data-sizes=auto alt=/images/better-rest-template-1-retryable/response.jpg width=50%></a><figcaption class=image-caption>예제로 임의 문자열을 리턴했지만 상황에 따라 얼마든지 커스터마이징이 가능하다.</figcaption></figure><h2 id=마치며>마치며</h2><p>어떻게 보면 너무나 당연하게 &ldquo;여러번 재시도 요청하면 되지?&rdquo; 라는 말을 할 수 있지만, &ldquo;입코딩&rdquo; 하는 것과 실제로 코드를 구현하는건 다른 이야기인것 같다. 정말 작은 로직 추가로 꽤 큰 효과를 볼 수 있어 다행이라 생각한다.
이러한 &ldquo;재시도&rdquo; 말고도 요청하고자 하는 곳의 서버의 상태가 안좋을 때 서버에러가 아닌 다른 명시적인 에러를 반환할 수 있는 방법이 다양할 것 같다. 모든것엔 정답이 없는 것 처럼.
제목에서 알 수 있듯이 다음 &ldquo;2부&rdquo; 에서는 &ldquo;Retry"가 아닌 &ldquo;Circuit Breaker"를 사용하여 &ldquo;재시도"의 방법보다 조금 다른 측면에서 조금 더 괜찮은 방법으로 RestTemplate 를 사용해 보고자 한다.</p><p>위에서 사용한 코드는 <a href=https://github.com/taetaetae/retryable-resttemplate target=_blank rel="noopener noreffer">필자의 Github Repo</a>에서 확인이 가능하다.</p><p>참고 url</p><ul><li><a href=https://dzone.com/articles/how-to-use-spring-retry>https://dzone.com/articles/how-to-use-spring-retry</a></li><li><a href=https://www.baeldung.com/spring-retry>https://www.baeldung.com/spring-retry</a></li><li><a href=https://github.com/spring-projects/spring-retry>https://github.com/spring-projects/spring-retry</a></li><li><a href=https://docs.spring.io/spring-batch/docs/current/reference/html/retry.html>https://docs.spring.io/spring-batch/docs/current/reference/html/retry.html</a></li></ul><script src=https://ads-partners.coupang.com/g.js></script><script>new PartnersCoupang.G({"id":195296,"trackingCode":"AF5596407","subId":null,"template":"carousel","width":"680","height":"140"});</script><p>※ 쿠팡 파트너스 활동을 통해 일정액의 수수료를 제공받을 수 있습니다.</p></div><center><style>.bmc-button img{width:27px!important;margin-bottom:1px!important;box-shadow:none!important;border:none!important;vertical-align:middle!important}.bmc-button{line-height:29px!important;height:30px!important;text-decoration:none!important;display:inline-flex!important;color:#000!important;background-color:#fd0!important;border-radius:3px!important;border:1px solid transparent!important;padding:1px 9px!important;font-size:22px!important;letter-spacing:.6px!important;box-shadow:0 1px 2px rgba(190,190,190,.5)!important;-webkit-box-shadow:0 1px 2px 2px rgba(190,190,190,.5)!important;margin:0 auto!important;font-family:cookie,cursive!important;-webkit-box-sizing:border-box!important;box-sizing:border-box!important;-o-transition:.3s all linear!important;-webkit-transition:.3s all linear!important;-moz-transition:.3s all linear!important;-ms-transition:.3s all linear!important;transition:.3s all linear!important}.bmc-button:hover,.bmc-button:active,.bmc-button:focus{-webkit-box-shadow:0 1px 2px 2px rgba(190,190,190,.5)!important;text-decoration:none!important;box-shadow:0 1px 2px 2px rgba(190,190,190,.5)!important;opacity:.85!important;color:#000!important}</style><link href="https://fonts.googleapis.com/css?family=Cookie" rel=stylesheet><center><br><a class=bmc-button target=_blank href=https://www.buymeacoffee.com/taetaetae><img src=https://www.buymeacoffee.com/assets/img/BMC-btn-logo.svg alt="Buy me a coffee"><span style=margin-left:5px>Buy me a coffee</span></a>
<a href=https://bit.ly/ddbSupport target=_blank><img src=https://i.imgur.com/peaYpjh.png style=height:28px></a></center><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>Updated on 2020-03-22</span></div><div class=post-info-license></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span><a href=javascript:void(0); title="Share on Twitter" data-sharer=twitter data-url=https://taetaetae.github.io/2020/03/22/better-rest-template-1-retryable/ data-title="조금 더 괜찮은 Rest Template 1부 - Retryable" data-hashtags="spring boot,retryable,archives-2020"><i class="fab fa-twitter fa-fw"></i></a><a href=javascript:void(0); title="Share on Facebook" data-sharer=facebook data-url=https://taetaetae.github.io/2020/03/22/better-rest-template-1-retryable/ data-hashtag="spring boot"><i class="fab fa-facebook-square fa-fw"></i></a><a href=javascript:void(0); title="Share on Linkedin" data-sharer=linkedin data-url=https://taetaetae.github.io/2020/03/22/better-rest-template-1-retryable/><i class="fab fa-linkedin fa-fw"></i></a><a href=javascript:void(0); title="Share on Blogger" data-sharer=blogger data-url=https://taetaetae.github.io/2020/03/22/better-rest-template-1-retryable/ data-title="조금 더 괜찮은 Rest Template 1부 - Retryable" data-description><i class="fab fa-blogger fa-fw"></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fas fa-tags fa-fw"></i>&nbsp;<a href=/tags/spring-boot/>spring boot</a>,&nbsp;<a href=/tags/retryable/>retryable</a>,&nbsp;<a href=/tags/archives-2020/>archives-2020</a></section><section><span><a href=javascript:void(0); onclick=window.history.back();>Back</a></span>&nbsp;|&nbsp;<span><a href=/>Home</a></span></section></div><div class=post-nav><a href=/2020/03/08/spring-rest-docs-in-spring-boot/ class=prev rel=prev title="SpringRestDocs를 SpringBoot에 적용하기"><i class="fas fa-angle-left fa-fw"></i>SpringRestDocs를 SpringBoot에 적용하기</a>
<a href=/2020/03/26/7-years-of-development-1st-day-of-manager/ class=next rel=next title="매니저는 정말 개발자의 무덤일까? (리뷰 - 개발자 7년차, 매니저 1일차)">매니저는 정말 개발자의 무덤일까? (리뷰 - 개발자 7년차, 매니저 1일차)<i class="fas fa-angle-right fa-fw"></i></a></div></div><div id=comments><div id=utterances></div><noscript>Please enable JavaScript to view the comments powered by <a href=https://utteranc.es/>Utterances</a>.</noscript></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line>Powered by <a href=https://gohugo.io/ target=_blank rel="noopener noreffer" title="Hugo 0.74.3">Hugo</a> | Theme - <a href=https://github.com/dillonzq/LoveIt target=_blank rel="noopener noreffer" title="LoveIt 0.2.10"><i class="far fa-kiss-wink-heart fa-fw"></i>LoveIt</a></div><div class=footer-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2016 - 2021</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=https://taetaetae.github.io/resume target=_blank>태태태</a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title="Back to Top"><i class="fas fa-arrow-up fa-fw"></i></a><a href=# id=view-comments class=fixed-button title="View Comments"><i class="fas fa-comment fa-fw"></i></a></div><link rel=stylesheet href=/lib/lightgallery/lightgallery.min.css><script type=text/javascript src=/lib/smooth-scroll/smooth-scroll.min.js></script><script type=text/javascript src=/lib/lazysizes/lazysizes.min.js></script><script type=text/javascript src=/lib/lightgallery/lightgallery.min.js></script><script type=text/javascript src=/lib/lightgallery/lg-thumbnail.min.js></script><script type=text/javascript src=/lib/lightgallery/lg-zoom.min.js></script><script type=text/javascript src=/lib/clipboard/clipboard.min.js></script><script type=text/javascript src=/lib/sharer/sharer.min.js></script><script type=text/javascript>window.config={"code":{"copyTitle":"Copy to clipboard","maxShownLines":500},"comment":{"utterances":{"darkTheme":"github-dark","issueTerm":"pathname","label":"Comment","lightTheme":"github-light","repo":"taetaetae/blog-comment"}},"lightGallery":{"actualSize":false,"exThumbImage":"data-thumbnail","hideBarsDelay":2000,"selector":".lightgallery","speed":400,"thumbContHeight":80,"thumbWidth":80,"thumbnail":true}};</script><script type=text/javascript src=/js/theme.min.js></script><script type=text/javascript>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}gtag('js',new Date());gtag('config','UA-86432198-1',{'anonymize_ip':true});</script><script type=text/javascript src="https://www.googletagmanager.com/gtag/js?id=UA-86432198-1" async></script></body></html>