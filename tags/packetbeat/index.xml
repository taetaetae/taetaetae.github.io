<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Packetbeat on</title><link>https://taetaetae.github.io/tags/packetbeat/</link><description>Recent content in Packetbeat on</description><generator>Hugo</generator><language>en</language><lastBuildDate>Sun, 08 Sep 2019 18:11:34 +0000</lastBuildDate><atom:link href="https://taetaetae.github.io/tags/packetbeat/index.xml" rel="self" type="application/rss+xml"/><item><title>네트워크 모니터링이 궁금할땐 ? Packetbeat !</title><link>https://taetaetae.github.io/2019/09/08/network-monitor-by-packetbeat/</link><pubDate>Sun, 08 Sep 2019 18:11:34 +0000</pubDate><guid>https://taetaetae.github.io/2019/09/08/network-monitor-by-packetbeat/</guid><description>&lt;p>모니터링은 서비스 로직 개발 만큼 한번씩 고민해보고 경험해 봤을 중요한 영역이라 할 수 있다. 그중 웹서버에서 제공해주는 엑세스 로그는 운영하고 있는 웹서비스에 대해 여러가지 측면에서 분석할 수 있는 가장 강력한 아이템 중에 하나라고 생각한다. &lt;!--more -->이를 통해 사용자들이 어떤 url을 많이 호출하고, 어떤 user-agent형태를 사용하는지 알게 되면 그에 따라 서비스 전략을 변경할수도 있고 악의적으로 공격적인 요청에 대해 웹서버단에서 차단을 할 수 있기 때문이다.
이렇게 &lt;code>inbound 트래픽(외부에서 들어오는 요청)&lt;/code>에 대해서는 엑세스 로그를 잘 분석하면 기존의 웹 어플리케이션과는 전혀 무관하게 모니터링이 가능하지만 반대로 &lt;code>outbund 트래픽(외부로 나가는 요청)&lt;/code>에 대해서는 어떤식으로 모니터링을 할 수 있을까?&lt;/p>
&lt;figure>&lt;a class="lightgallery" href="https://taetaetae.github.io/images/network-monitor-by-packetbeat/passbook.jpg" title="/images/network-monitor-by-packetbeat/passbook.jpg" data-thumbnail="/images/network-monitor-by-packetbeat/passbook.jpg" data-sub-html="&lt;h2>월급통장의 inbound 트래픽보다 outbound 트래픽이 너무 많은 요즘&amp;hellip;이미지 출처 : https://www.app24moa.com/feedDetail/2/2002&lt;/h2>">
 &lt;img
 class="lazyload"
 src="https://taetaetae.github.io/svg/loading.min.svg"
 data-src="https://taetaetae.github.io/images/network-monitor-by-packetbeat/passbook.jpg"
 data-srcset="https://taetaetae.github.io/images/network-monitor-by-packetbeat/passbook.jpg, https://taetaetae.github.io/images/network-monitor-by-packetbeat/passbook.jpg 1.5x, https://taetaetae.github.io/images/network-monitor-by-packetbeat/passbook.jpg 2x"
 data-sizes="auto"
 alt="/images/network-monitor-by-packetbeat/passbook.jpg" width="80%" />
 &lt;/a>&lt;figcaption class="image-caption">월급통장의 inbound 트래픽보다 outbound 트래픽이 너무 많은 요즘&amp;hellip;&lt;br>이미지 출처 : &lt;a href="https://www.app24moa.com/feedDetail/2/2002" target="_blank" rel="noopener noreffer ">https://www.app24moa.com/feedDetail/2/2002&lt;/a>&lt;/figcaption>
 &lt;/figure>
&lt;p>예컨데, 날씨 서비스를 하기 위해 외부에서 &lt;code>서울날씨&lt;/code>라는 페이지를 조회했을 경우 기상청 API에서 넘겨받은 데이터를 가공하여 보여준다고 가정해보자. 이때 기상청에서 제공해주는 특정 API중에 어느 하나가 늦게 응답이 온다거나, 특정시간대에 에러응답을 받을경우 과연 이를 어떤식으로 모니터링 할수 있을까? 어플리케이션 코드에 &lt;code>모니터링을 위한 코드&lt;/code>를 추가할 것인가? 혹 하나의 서버에서 A모듈은 java로, B모듈은 python으로 개발되었을 경우 각각 모듈마다 모니터링을 위한 코드를 추가하는 식으로 하다보면 비지니스 로직을 방해하거나 오히려 추가한 코드 또한 관리해야 하는 배보다 배꼽이 더 커져버릴 상황도 생길수 있다.
어플리케이션의 비지니스 로직과는 무관하게 서버 자체에서 외부로 나가는 네트워크 트래픽에 대해 모니터링을 할 수 있는 &lt;code>가벼우면서도 심플한 모듈&lt;/code>을 찾고 싶었다. 어플리케이션의 개발언어가 무엇이든 상관없이 별도의 에이전트 형식으로 띄워두기만 하면 네트워크 트래픽을 수집 및 분석, 나아가서는 모니터링까지 할수있는&amp;hellip; 그래서 찾다보니 역시나 이러한 고민을 누군가는 하고 있었고 오픈소스까지 되어있는 Elastic Stack 의 Beat중 &lt;code>Packetbeat&lt;/code>라는 데이터 수집모듈을 알게 되었다.&lt;/p>
&lt;blockquote>
&lt;p>역시 내가 하고있는 고민은 이미 누군가 했던 고민들&amp;hellip; 이러한 고민에 대해 해결하는 방법을 보다 빨리 찾는게 경쟁력이 될텐데&amp;hellip;&lt;/p>&lt;/blockquote>
&lt;p>이번 포스팅에서는 Packetbeat 에 대해 간단히 알아보고 이를 활용하여 outbound 트래픽에 대해 모니터링을 해보며 어떤식으로 활용할 수 있는지에 대해 알아보고자 한다.&lt;/p>
&lt;h2 id="packetbeat-">Packetbeat ?&lt;/h2>
&lt;p>ElasticStack 중에 데이터 수집기 플랫폼인 &lt;code>Beats&lt;/code>중 네트워크 트래픽 데이터에 대해 수집을 할 수 있는 데이터 수집기를 제공하고 있다. &lt;a href="https://ko.wikipedia.org/wiki/Pcap" target="_blank" rel="noopener noreffer ">pcap&lt;/a>라이브러리를 이용하여 서버의 네트워크 레벨에서 데이터를 수집 및 분석한 후 외부로(Elasticsearch, Logstash, Kafka 등) 전송해주는 &lt;code>경량 네트워크 패킷 분석기&lt;/code>라고 &lt;a href="https://www.elastic.co/kr/products/beats/packetbeat" target="_blank" rel="noopener noreffer ">공식 홈페이지&lt;/a>에 소개되고 있다.
몇번 사용해보면서 느낀 장점들은 다음과 같다.&lt;/p>
&lt;ul>
&lt;li>설치 및 실행이 너무 간단하다.&lt;/li>
&lt;li>설정값 튜닝을 통해 간단하지만, 그러한 간단함에 비해서 너무 강력한 수집이 가능하다.&lt;/li>
&lt;li>앞서 이야기 했던 어플리케이션 코드와는 전혀 무관하게 작동한다.&lt;/li>
&lt;/ul>
&lt;h2 id="무엇을-해볼것인가-aka-목표">무엇을 해볼것인가?! (a.k.a. 목표)&lt;/h2>
&lt;p>필자가 운영하는 &lt;a href="http://daily-devblog.com" target="_blank" rel="noopener noreffer ">Daily-DevBlog&lt;/a> 라는 서비스가 있다. &lt;del>(갑분 서비스 홍보)&lt;/del> 여러 사람들의 rss를 조회하고 파싱해서 메일을 보내주는 서비스 인데, packetbeat 사용 예시를 들기위해 조금 변형하여 모든 rss를 접근하고 가장 최신글의 제목을 출력하는 아주 간단한 python 스크립트로 outbound 트래픽을 발생시켜 보고자 한다.
그리고 packetbeat 를 이용하여 외부로 호출되는 트래픽을 수집하고 Elasticsearch 로 인덱싱 하여 최종적으로는 어느 rss의 속도가 가장 느린지 실행되는 python코드와는 전혀 관련없이 모니터링 해보고자 한다.
python 코드는 다음과 같다.&lt;/p>
&lt;blockquote>
&lt;p>참고로 필자는 &lt;code>awesome-devblog&lt;/code>의 운영자분께 해당 데이터 사용에 대해 허락을 받은 상태이다.&lt;/p>&lt;/blockquote>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="kn">import&lt;/span> &lt;span class="nn">requests&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="nn">yaml&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="nn">feedparser&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">blog_info_list_yml_url&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s1">&amp;#39;https://raw.githubusercontent.com/sarojaba/awesome-devblog/master/db.yml&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">blog_info_list_yml&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">requests&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">get&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">url&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">blog_info_list_yml_url&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">text&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">blog_info_yaml_parse_list&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">yaml&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">load&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">blog_info_list_yml&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">for&lt;/span> &lt;span class="n">blog_info&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="n">blog_info_yaml_parse_list&lt;/span> &lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="s1">&amp;#39;rss&amp;#39;&lt;/span> &lt;span class="ow">not&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="n">blog_info&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">keys&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="ow">or&lt;/span> &lt;span class="ow">not&lt;/span> &lt;span class="n">blog_info&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s1">&amp;#39;rss&amp;#39;&lt;/span>&lt;span class="p">]:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">continue&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">rss_url&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">blog_info&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s1">&amp;#39;rss&amp;#39;&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">try&lt;/span> &lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">parse_feed&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">feedparser&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">parse&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">rss_url&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">except&lt;/span> &lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">continue&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">parse_feed_data&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">parse_feed&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">entries&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">blog_info&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s1">&amp;#39;name&amp;#39;&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="s1">&amp;#39;|&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">parse_feed_data&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s1">&amp;#39;title&amp;#39;&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="s1">&amp;#39;|&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">parse_feed_data&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s1">&amp;#39;link&amp;#39;&lt;/span>&lt;span class="p">])&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>위 코드를 실행하면 아래처럼 아주 간단하게 &lt;code>블로그 주인의 이름&lt;/code>과 &lt;code>최신글 제목&lt;/code>, &lt;code>링크&lt;/code>가 출력이 된다.&lt;/p>
&lt;figure>&lt;a class="lightgallery" href="https://taetaetae.github.io/images/network-monitor-by-packetbeat/rss_python_script.jpg" title="/images/network-monitor-by-packetbeat/rss_python_script.jpg" data-thumbnail="/images/network-monitor-by-packetbeat/rss_python_script.jpg" data-sub-html="&lt;h2>그러고 보니 너무 오랜만에 글쓰네&amp;hellip; (숙연)&lt;/h2>">
 &lt;img
 class="lazyload"
 src="https://taetaetae.github.io/svg/loading.min.svg"
 data-src="https://taetaetae.github.io/images/network-monitor-by-packetbeat/rss_python_script.jpg"
 data-srcset="https://taetaetae.github.io/images/network-monitor-by-packetbeat/rss_python_script.jpg, https://taetaetae.github.io/images/network-monitor-by-packetbeat/rss_python_script.jpg 1.5x, https://taetaetae.github.io/images/network-monitor-by-packetbeat/rss_python_script.jpg 2x"
 data-sizes="auto"
 alt="/images/network-monitor-by-packetbeat/rss_python_script.jpg" width="80%" />
 &lt;/a>&lt;figcaption class="image-caption">그러고 보니 너무 오랜만에 글쓰네&amp;hellip; (숙연)&lt;/figcaption>
 &lt;/figure>
&lt;h2 id="백문이-불여일견-백견이-불여일타">백문이 불여일견? 백견이 불여일타!&lt;/h2>
&lt;p>언제 어디서부터 유래된 이야기 인지는 모르지만 &amp;ldquo;백번 듣는것이 한번 보는것보다 못하고, 백번 보는것이 한번 타자 치는것보다 못하다&amp;rdquo; 라는 &lt;code>개발버전&lt;/code> 속담이 있다. 자, 위에서 정의한 목표를 이루기 위해 실제로 각종 모듈을 설치해 보도록 하자! ( 필자가 테스트 했던 서버의 환경은 CentOS 7.4 64Bit 이니 참고 )&lt;/p></description></item></channel></rss>